File: C1.MAIN.TEXT                                                Page   1


                           1*            list on
                           2* 
                           3* ;DRAGONFLY.TEXT
                           4* ; Date: 10-APRIL-85
                           5* ; By:   ROCKY CHANG
                           6* ; modified by Mike Cook   1 May 85
                           7* ;                        +-----+----------------+
                           8* ; Stag PROM checksums:   |     |                |
                           9* ;                        |  H  |                |
                          10* ;                        |     |                |
                          11* ;                        +-----+----------------+
                          12* ;                        |     |                |
                          13* ;                        |  L  |                |
                          14* ;                        |     |                |
                          15* ;                        +-----+----------------+
File: C1.MAIN.TEXT                                                Page   2


                          17*         include 'C1.EQU'     ;PROM equates
                          18* ; File: VSD.EQU.TEXT
                          19* ; Date: 19-JUL-84
                          20* ;
                          21* ;
      00000001            22* on         equ     1
      00000000            23* off        equ     0
      00000000            24* PROMvers   equ     0               ;current prom version
      00000002            25* PROMlevl   equ     2               ;Current PROM level number
      00000067            26* PROMilvl   equ     'g'             ;intermediate version
      00800000            27* SYSbase    equ     $800000         ;Base address of system
      00800000            28* RAMbase    equ     SYSbase         ;Base address of static RAM
      00001000            29* RAMlen     equ     $1000           ;Length of static RAM (4k bytes)
      00800300            30* RAMkbbuf   equ     RAMbase+$300    ;Start of keyboard buffer
      00000100            31* RAMkblen   equ     $100            ;Length of keyboard buffer
      00800400            32* RAMDebug   equ     RAMbase+$400    ;Start of debug prom ram
      00800700            33* RAMwksta   equ     RAMbase+$700    ;start of valid scorpion debugger RAM
      00801000            34* RAMend     equ     RAMbase+RAMLen  ;End address + 1 of low RAM
      00810000            35* ROM0base   equ     SYSbase+$10000  ;Start of rom 0-vsd
      00002000            36* ROM0len    equ     $2000           ;Length of PROM
      00812000            37* ROM0end    equ     ROM0base+ROM0len;End address + 1 of workstation PROM
      00820000            38* ROM1base   equ     SYSbase+$20000  ;Base address of DEBUG PROM
      00004000            39* ROM1len    equ     $4000           ;Length of DEBUG PROM
      00824000            40* ROM1end    equ     ROM1base+ROM1len;End address + 1 of DEBUG PROM
      00820004            41* DBGinit    equ     ROM1base+4     ;initialization vector for debug
      00820008            42* DBGentry   equ     ROM1base+8     ;entry vector for debug
      00830000            43* IOPbase    equ     SYSbase+$30000   ;Base address of I/O pg
                          44* ;IOPprom    equ     IOPbase+$0200   ;Base address of slot PROMs
                          45* 
      00880000            46* Vidbase    equ     SYSbase+$80000  ;video ram base Use DSPbase
      00010000            47* VIDlen     equ     $10000          ;length of video ram (64k)
      00890000            48* VIDend     equ     VIDbase+VIDlen  ;end+1 of video ram
      00880000            49* DSPbase    equ     VIDbase         ;{!UC}Base address of display buffer
      0000FF00            50* DSPlen     equ     $00ff00         ;{!UC}Length of display buffer
      0088FF00            51* DSPend     equ     DSPbase+DSPlen  ;{!UC}End address + 1 of display buffer
      00880030            52* USRbase    equ     SYSbase+$080030         ;{!UC}Base address of user RAM
                          53*                                  ;
      00000000            54* DRbase    equ      0               ;base address of dynamic Ram
      00100000            55* OneMeg    equ      $100000         ;one megabyte
      00200000            56* TwoMeg    equ      OneMeg*2        ;two megabytes
      00300000            57* ThreeMeg   equ     OneMeg*3        ;three megabyte
      00400000            58* FourMeg   equ      OneMeg*4        ;Four megabytes
      00400000            59* MapBase   equ      OneMeg*4        ;Four megabytes
      00400000            60* HighMap   equ      FourMeg         ;High Map of board
File: C1.MAIN.TEXT                                                Page   3


                          62* ; Corvus UNIPLEX Exception vector definitions
                          63* ;
      00000008            64* BEvec      equ    $08             ;Bus error vector
      0000000C            65* AEvec      equ    $0C             ;Address error vector
      00000010            66* InstVec    equ    $10             ;Illegal instruction vector
      00000020            67* PrivVec    equ    $20             ;Privilege violation vector
      00000060            68* SpIVec     equ    $60             ;Spurious interrupt vector
      00000064            69* IVlvl1     equ    $64             ;level 1 timeout interrupt vector
      00000068            70* IVlvl2     equ    $68             ;level 2 interrupt vector not used
      0000006C            71* IVlvl3     equ    $6C             ;level 3 interrupt vector not used
      00000070            72* IVlvl4     equ    $70             ;level 4 interrupt vector not used
      00000074            73* IVlvl5     equ    $74             ;level 5 disc controller interrupt vector
      00000078            74* IVlvl6     equ    $78             ;level 6 timer interrupt vector
      0000007C            75* IVlvl7     equ    $7C             ;level 7 memory interrupt vector
      00000080            76* Trap0vec   equ    $80             ;Trap 0 vector
      00000084            77* Trap1vec   equ    $84             ;Trap 1 vector
      00000088            78* Trap2vec   equ    $88             ;Trap 2 vector
      0000008C            79* Trap3vec   equ    $8C             ;Trap 3 vector
      00000090            80* Trap4vec   equ    $90             ;Trap 4 vector
      00000094            81* Trap5vec   equ    $94             ;Trap 5 vector
      00000098            82* Trap6vec   equ    $98             ;Trap 6 vector
      0000009C            83* Trap7vec   equ    $9C             ;Trap 7 vector
      000000A0            84* Trap8vec   equ    $A0             ;Trap 8 vector
      00000100            85* GP7        equ    $100            ;Omninet ready       (no interrupt)
      00000104            86* GP6        equ    $104            ;Monitor orientation (no interrupt)
      00000108            87* timeraI    equ    $108            ;clock tick (no int, use external level 6)
      0000010C            88* kbdrxfull  equ    $10c            ;keyboard data interrupt
      00000110            89* kbdrxerr   equ    $110            ;keyboard break interrupt
      00000114            90* kbdtxfull  equ    $114            ;keyboard txdata (no interrupt)
      00000118            91* kbdtxerrl  equ    $118            ;keyboard txerr (no interrupt)
      0000011C            92* timerbI    equ    $11c            ;baud rate      (no interrupt)
      00000110            93* GP5        equ    $110            ;Omninet interrupt
      00000124            94* GP4        equ    $124            ;Real time clock calendar (no interrupt)
      00000128            95* timercI    equ    $128            ;beeper         (no interrupt)
      0000012C            96* timerdI    equ    $12c            ;unused
      00000130            97* GP3        equ    $130            ;IRQ1
      00000134            98* GP2        equ    $134            ;NMI1
      00000138            99* GP1        equ    $138            ;IRQ0
      0000013C           100* GP0        equ    $13c            ;NMI0
      00000140           101* DuartI     equ    $140            ;Duart vector
      00000180           102* Dusart0I   equ    $180            ;Dusart level 0 vector
      00000184           103* Dusart1I   equ    $184            ;Dusart level 1 vector
      00000188           104* Dusart2I   equ    $188            ;Dusart level 2 vector
      0000018C           105* Dusart3I   equ    $18c            ;Dusart level 3 vector
      00000190           106* Dusart4I   equ    $190            ;Dusart level 4 vector
      00000194           107* Dusart5I   equ    $194            ;Dusart level 5 vector
      00000198           108* Dusart6I   equ    $198            ;Dusart level 6 vector
      0000019C           109* Dusart7I   equ    $19c            ;Dusart level 7 vector
      00000380           110* DMACInt    equ    $380            ;Dusart level 0 vector
                         111* 
                         112* ;
                         113* ; Corvus CONCEPT Workstation static RAM address definition
                         114* ;
      00800C00           115* Ramwksa   equ   SYSbase+$C00
File: C1.MAIN.TEXT                                                Page   4


      00800C00           116* ustack    equ     Ramwksa         ;user stack pointer
      0000003E           117* prompt0   equ     '>'             ;Main
      0000002A           118* prompt1   equ     '*'             ;Dragonfly
      00000023           119* prompt2   equ     '#'             ;MapMenu
      0000002D           120* prompt3   equ     '-'             ;Dynamic ram
      00000024           121* prompt4   equ     '$'             ;error tests
      00000021           122* prompt5   equ     '!'             ;omni
      0000002B           123* prompt6   equ     '+'             ;loops
      00000026           124* prompt7   equ     '&'             ;IO
      00800D00           125* iobuff    equ     RAMwksa+$100   ;(D00-D63) I/O buffer (100 bytes)
      00000064           126* bufflen   equ     $64             ;length of io buffer
      00800D63           127* iobfend   equ     iobuff+bufflen-1 ;
      00800D64           128* sysflag   equ     iobuff+bufflen  ;(D64-D64) system initialization status
      00800D65           129* Memsz     equ     sysflag+1       ;D65-number of banks
      00800D66           130* curmem    equ     Memsz+1         ;D66-D69 offset for incrementing mode
      00800D6A           131* InSegD    equ     curmem+$4       ;(D6A-D6B) Initial segment data for set segments
      00800D6C           132* InPagD    equ     InSegD+$2       ;(D6C-D9D) Initial page data for set page map
      00800D6E           133* wndrcd    equ     InPagD+$2      ;(D6E-D9F) system window record (36 bytes)
      00800D92           134* scnofs    equ     wndrcd+$24      ;(DA0-DA1) bytes per display scan line
      00800D94           135* BEflag    equ     Scnofs+2        ;DA2-DA2 bus error flag
      00800D95           136* DrvDflt   equ     BEflag+1        ;DA3drive number default
      00800D96           137* DlyVal    equ     DrvDflt+1       ;DA4-DA7 delay value
      00800D9A           138* IOaddr    equ     DlyVal+4        ;DA8-DAB defaul io address
      00800D9E           139* ETstack   equ     IOaddr+4        ;DAC-DAF error test stack ptr save location
      00800DA2           140* loopctr   equ     ETstack+4       ;DB0-DB3 loop counter
      00800DA6           141* errctr    equ     loopctr+4       ;DB4-DB7 error counter
      00800DAA           142* expdata   equ     errctr+4        ;DB8-DBB expected data
      00800DAE           143* errdata   equ     expdata+4       ;DBC-DBF data read
      00800DB2           144* erradd    equ     errdata+4       ;DC0-DC3 error address
      00800DB6           145* TstStat   equ     erradd+4        ;DC4-DC4 test status flag
      00800E00           146* stack     equ     RAMwksa+$200   ;(E00-FFF) initial system stack
      00800FFC           147* istack    equ     stack+$1FC   ;(1000) initial system stack pointer
                         148*                                 ;
      00880000           149* omnibf   equ    USRbase-$30     ;OMNINET driver buffer (48 bytes)
                         150*                                 ;   (OMNINET can't access below $80000)
                         151* ;bit   equates for sysflag
      00000000           152* Xcrtbit   equ     0               ;external crt 1-yes 0-no
      00000001           153* Alfbit    equ     1               ;auto linefeed insert 1-yes 0-no
      00000002           154* Echobit   equ     2               ;Echo mode 1-on 0-off
      00000003           155* DBGbit    equ     3               ;debug flag 0-not present 1 present
      00000004           156* Tranbit   equ     4               ;segments and pages transparent 1y 0n
      00000005           157* TSegbit   equ     5               ;1-Segments transp 0-not transparent
      00000006           158* Trcebit   equ     6               ;1-trace mode 0-normal
      00000007           159* excbit    equ     7               ;1-exception occured 0-no exception
                         160* ;bit equates for TstStat
      00000000           161* RegBit    equ     0               ;level 0(registers)
      00000001           162* SmapBit   equ     1               ;level 1(segment map)
      00000002           163* PmapBit   equ     2               ;level 2(page maps)
      00000003           164* DramBit   equ     3               ;level 3(Dynamic Ram)
      00000004           165* Protbit   equ     4               ;level 4(protection circuits)
                         166* ;values for bus error flag
                         167* ;
      00000000           168* NormOP    equ     0               ;table offset for normal operations
      00000001           169* PETop     equ     1
File: C1.MAIN.TEXT                                                Page   5


      00000002           170* SETop     equ     2               ;offset for segment error test operations
File: C1.MAIN.TEXT                                                Page   6


                         172* ;
                         173* 
                         174* 
                         175* 
                         176* ;************ Cheetah ***********************************
                         177* ;      ----- 68901 MFP EQUATES -----
                         178* ;
      00830200           179* MFPbase    equ     $830200       ;BASE ADDR OF MFP REGS
      00000001           180* GPIR     equ       $01     ;general purpose interrupt I/
      00000003           181* AER      equ       $03     ;active edge reg
      00000005           182* DDR      equ       $05     ;data direction reg
      00000007           183* IERA     equ       $07     ;INTERRUPT enable reg A
      00000009           184* IERB     equ       $09     ;interrupt enable reg B
      0000000B           185* IPRA     equ       $0b     ;interrupt pending reg A
      0000000D           186* IPRB     equ       $0d     ;interrupt pending reg B
      0000000F           187* ISRA     equ       $0f     ;interrupt in-service reg A
      00000011           188* ISRB     equ       $11     ;interrupt in-service reg B
      00000013           189* IMRA     equ       $13     ;interrupt mask reg A
      00000015           190* IMRB     equ       $15     ;interrupt mask reg B
      00000017           191* VR       equ       $17     ;Vector reg
      00000019           192* TACR     equ       $19     ;timer control reg A
      0000001B           193* TBCR     equ       $1b     ;timer control reg B
      0000001D           194* TCDCR    equ       $1d     ;timer control reg C&D
      0000001F           195* TADR     equ       $1f     ;timer a data reg(sys timer)
      00000021           196* TBDR     equ       $21     ;timer b data reg(baud rate)
      00000023           197* TCDR     equ       $23     ;timer c data reg(bell)
      00000025           198* TDDR     equ       $25     ;timer d data reg
      00000027           199* SCR      equ       $27     ;sync char reg
      00000029           200* KBCON    equ       $29     ;usart control reg
      00000029           201* UCR      equ       $29     ;usart control reg
      0000002B           202* KBSTAT   equ       $2b     ;receiver status reg
      0000002D           203* TSR      equ       $2d     ;transmitter status reg
      0000002F           204* KBDATA   equ       $2f     ;usart data reg
                         205* 
File: C1.MAIN.TEXT                                                Page   7


                         207* ;
                         208* ;      ----- 68681 DUART EQUATES -----
                         209* ;
                         210* 
      00830300           211* DUARTbase    equ  $830300         ;Base addr of regs
      00000001           212* MR1A     equ    $01     ;mode reg 1 A, R/W
      00000001           213* MR2A     equ    $01     ;mode reg 2 A, R/W
      00000003           214* SRA      equ    $03     ;status reg A
      00000003           215* CSRA     equ    $03     ;clock-select reg A
                         216*                       ;DO NOT READ!
      00000005           217* CRA      equ    $05     ;commond reg A, write only
      00000007           218* RBA      equ    $07     ;receiver buffer A
      00000007           219* MSuDa    equ    $07     ;receiver buffer A mouse
      00000007           220* TBA      equ    $07     ;transmitter buffer B
      00000009           221* IPCR     equ    $09     ;input port change reg
      00000009           222* ACR      equ    $09     ;auxiliary control reg
      0000000B           223* ISR      equ    $0b     ;interrupt status reg
      0000000B           224* IMR      equ    $0b     ;interrupt mask reg
      0000000D           225* CTU      equ    $0d     ;MSB of counter
      0000000D           226* CTUR     equ    $0d     ;MSB of counter upper reg
      0000000F           227* CTL      equ    $0f     ;LSB of counter
      0000000F           228* CTLR     equ    $0f     ;LSB of counter lower reg
      00000011           229* MR1B     equ    $11     ;mode reg 1 B, R/W
      00000011           230* MR2B     equ    $11     ;mode reg 2 B  R/W
      00000013           231* SRB      equ    $13     ;status reg B
      00000013           232* CSRB     equ    $13     ;clock-select reg B
                         233*                       ;DO NOT READ!
      00000015           234* CRB      equ    $15     ;commond reg B
      00000017           235* RBB      equ    $17     ;receiver buffer B, R
      00000017           236* TBB      equ    $17     ;transmitter buffer B, W
      00000019           237* IVR      equ    $19     ;interrupt vector reg, R/W
      0000001B           238* IP       equ    $1b     ;input port
      0000001B           239* OPCR     equ    $1b     ;output port configuration re
      0000001D           240* STCC     equ    $1d     ;start counter commond
      0000001D           241* SOPR     equ    $1d     ;set output port reg
      0000001F           242* SPCC     equ    $1f     ;stop counter commond
      0000001F           243* ROPR     equ    $1f     ;reset output port reg
File: C1.MAIN.TEXT                                                Page   8


                         245* ;-----------------------------------------------------
                         246* ;
                         247* ; DEFAULTS
                         248* ;
                         249* 
                         250* ;
                         251* ;      ----- MFP DEFAULT VALUE -----
                         252* ;
                         253* ; Timer A - Control is $08, set to event count mode, countin
                         254* ;           pulses from timer B.
                         255* ;           Data is $A0 = 160 -> positive edge at 10 ms.
                         256* ;           Reset interrupt flipflop by writing $10 to TACR
                         257* ;           writing $08 to re-enable.
                         258* ;
                         259* ; Timer B - Control is 05, set to delay mode divide by 64 pr
                         260* ;           Data is $c0 = > 9600 Hz
                         261* ;
                         262* ; Timer C & D - Control is $71,
                         263* ;                set C to delay mode divide by 200 prescale.
                         264* ;                set D to delay mode divide by 4 prescale.
                         265* ;               Data C is $10 = 16 -> tone of ???
                         266* ;               Data D is don't care.
                         267* 
                         268* ;GPIR   set up to read and general purpose interrupt
      00000000           269* AERd     equ      00     ;active edge falling
      00000000           270* DDRd     equ      00     ;data direction inbound
      00000018           271* IERAd    equ     $18     ;see above
      0000008F           272* IERBd    equ     $8f
                         273* ;IPRA    read
                         274* ;IPRB    read
                         275* ;ISRA    read
                         276* ;ISRB    read
      000000D8           277* IMRAd    equ     $d8
      000000CF           278* IMRBd    equ     $cf
      00000044           279* VRd      equ     $44
      00000008           280* TACRd    equ     $08
      00000001           281* TBCRd    equ     $01
      00000010           282* TCDCRd   equ     $10
      000000A0           283* TADRd    equ     $a0
      00000030           284* TBDRd    equ     $30
      00000010           285* TCDRd    equ     $10
      00000000           286* TDDRd    equ     $00
      00000000           287* SCRd     equ     $00    ;sync char reg
      00000089           288* UCRd     equ     $89    ;usart, 7 bits long, start=stop=1, asy
      00000001           289* RSRd     equ     $01     ;receiver status, receiver on
      00000002           290* TSR0d    equ     $02     ;transmitter status, output low
      00000004           291* TSR1d    equ     $04     ;transmitter status, output high
      000000C0           292* KBCONd   equ     $c0     ;keyboard control reg data
                         293* ;KBSTAT                  ;receiver status reg  read
                         294* ;TSRd                    ;transmitter status reg unused
                         295* ;KBDATA                  ;usart data UDR read
      00000007           296* kbrRdBit  equ   $7              ;1=data ready to read
                         297* ;kbrdTabl   equ  KeyBoardTable
      00830200           298* kbrdbase   equ   mfpbase
File: C1.MAIN.TEXT                                                Page   9


      00000070           299* startCtrC  equ   $70
      0000000F           300* stopCtrC   equ   $0f
                         301* ;ioport bits
      00000007           302* OMready  equ       7
      00000006           303* vertical equ       6
      00000005           304* OMint    equ       5
      00000004           305* clockcal equ       4
      00000003           306* nirq1    equ       3
      00000002           307* nmi1     equ       2
      00000001           308* nirq0    equ       1
      00000000           309* nmi0     equ       0
File: C1.MAIN.TEXT                                                Page  10


                         311* ;
                         312* ;      ----- DUART DEFAULT VALUE -----
                         313* ;
                         314* ;
                         315* ; Channel A (Mouse receive only 1200 Baud)
                         316* ;
                         317* ; MR1A Rx RTS disabled, RxRDY, Char mode, no parity, 7 bits
                         318* ; MR2A Normal mode, TxRTS, CTS disabled, stop bit = 1
                         319* ; CSRA receive clock = 1200 baud, transmit clock = 1200 baud
                         320* ; CRA  reset pointer to MR1, transmitter disabled,receiver
                         321* ;      enable
                         322* ;
                         323* ; Channel B (General purpose async serial port 9600 Baud,
                         324* ;            8 bit no parity)
                         325* ;
                         326* ; MR1B Rx RTS disabled, RxRDY, Char mode, no parity, 8 bits
                         327* ; MR2B Normal mode, TxRTS, CTS disabled, stop bit = 1
                         328* ; CSRB receive clock = 9600 baud, transmit clock = 9600 baud
                         329* ; CRB  reset pointer to MR2, transmitter, receiver enable
                         330* ;
      00000012           331* MR1Ad    equ     $12     ;channel A default(details see above)
      00000007           332* MR2Ad    equ      07      ;
      0000000C           333* SRAd     equ     $0c     ;status reg A
      00000066           334* CSRAd    equ     $66     ;clock select reg A
      00000019           335* CRAd     equ     $19     ;command reg A
                         336* ;IPCRd    equ     00      ;read
      0000000B           337* ACRd     equ     $b      ;write
                         338* ;ISRd     equ     00      ;read
      000000F2           339* IMRd     equ     $f2
                         340* 
      00000013           341* MR1Bd    equ     $13     ;CHANNAL B DEFAULT
      00000007           342* MR2Bd    equ      07
                         343* ;SRBd     equ     $0c
      000000BB           344* CSRBd    equ     $bb
      00000015           345* CRBd     equ     $15
      00000050           346* IVRd     equ     $50
      000000FA           347* OPCRd    equ     $fa     ;output port Config. reg
                         348* 
                         349* ;
                         350* ;      ----- 68564 DUSART EQUATES -----
                         351* ;
                         352* 
      00830400           353* DUSARTbase     equ     $830400 ;dusart base addr
      00000001           354* CMDREGA        equ     $01     ;command reg A
      00000003           355* MODCTLA        equ     $03     ;mode reg A
      00000005           356* INTCTLA        equ     $05     ;interrupt control reg A
      00000007           357* SYNC1A         equ     $07     ;sync word reg 1 A
      00000009           358* SYNC2A         equ     $09     ;sync word reg 2 A
      0000000B           359* RCVCTLA        equ     $0b     ;receiver control reg A
      0000000D           360* XMTCTLA        equ     $0d     ;transmitter control reg A
      0000000F           361* STAT0A         equ     $0f     ;status reg 0 A
      00000011           362* STAT1A         equ     $11     ;status reg 1 A
      00000013           363* DATREGA        equ     $13     ;data reg A
      00000015           364* TCREGA         equ     $15     ;time constant reg A
File: C1.MAIN.TEXT                                                Page  11


      00000017           365* BRGCTLA        equ     $17     ;baud rate generator crtl A
      00000019           366* VECTRGA        equ     $19     ;interrupt vector reg A/B
                         367* 
      00000021           368* CMDREGB        equ     $21     ;command reg B
      00000023           369* MODCTLB        equ     $23     ;mode reg B
      00000025           370* INTCTLB        equ     $25     ;interrupt control reg B
      00000027           371* SYNC1B         equ     $27     ;sync word reg 1 B
      00000029           372* SYNC2B         equ     $29     ;sync word reg 2 B
      0000002B           373* RCVCTLB        equ     $2b     ;receiver control reg B
      0000002D           374* XMTCTLB        equ     $2d     ;transmitter control reg B
      0000002F           375* STAT0B         equ     $2f     ;status reg 0 B
      00000031           376* STAT1B         equ     $31     ;status reg 1 B
      00000033           377* DATREGB        equ     $33     ;data reg B
      00000035           378* TCREGB         equ     $35     ;time constant reg B
      00000037           379* BRGCTLB        equ     $37     ;baud rate generator crtl B
      00000039           380* VECTRGB        equ     $39     ;interrupt vector reg B/B
                         381* ;
                         382* ;      ----- DUSART DEFAULT VALUES -----
                         383* ;
                         384* ;                      Port A                  Port B
                         385* ;                      9600 baud, 8 bits       9600 baud, 8 bit
                         386* ;                      no parity, async        no parity, sync
                         387* ;MODCTL: clk prescaler 16x                     1x
                         388* ;        Synchronous   ignored                 8 bit
                         389* ;        Stop bits     1 async                 0 sync
                         390* ;        parity        none                    none
                         391* ;INTCTL: CRC16/SDLC    SDLC                    SDLC
                         392* ;        TxRDY         enabled                 enabled
                         393* ;        RxRDY         enabled                 enabled
                         394* ;        RxINT MODE 1  enabled                 disabled
                         395* ;        RxINT MODE 0  disabled                enabled
                         396* ;       STATUS AFFECTS enabled                 enabled
                         397* ;        TxINT         enabled                 enabled
                         398* ;        ExINT         enabled                 enabled
                         399* ;
                         400* ;** vector register accessable in both places
                         401* ;
                         402* ;Command Register: clears CRC generator/checker
                         403* ;                 resets external status
                         404* ;                 enables interrupts
                         405* ;
                         406* ;                                      Channel A  Chann
                         407* ;
                         408* ;Mode Control:     Clock prescaler        16x       1x
                         409* ;                 Synchronous mode       ignored   8-bi
                         410* ;                 Stop bits              1 async   0 sy
                         411* ;                 Parity                 none      none
                         412* ;
                         413* ;Interrupt Control: d7 CRC16/SDLC         SDLC      SDLC
                         414* ;                  d6 TxRDY              enabled   enab
                         415* ;                  d5 RxRDY Enable       enabled   enab
                         416* ;                  d4/3 RxInt Mode       int all   int
                         417* ;                  d2 Status affects     enabled   enab
                         418* ;                  d1 TxInt enable       enabled   enab
File: C1.MAIN.TEXT                                                Page  12


                         419* ;                  d0 Ext Int Enable     enabled   enab
                         420* ;
                         421* ;Receiver Control:  Bits per char         8         8
                         422* ;                  DCD/Hunt mode         off       off
                         423* ;                  CRC enable            ignored   on
                         424* ;                  Address search        ignored   on
                         425* ;                  Sync load inhibit     on **     igno
                         426* ;                  ** no interrupt for nulls
                         427* ;
                         428* ;Transmitter Ctrl:  Bits per char         8         8
                         429* ;                  Send break            off       off
                         430* ;                  CTS enable            off       off
                         431* ;                  CRC enable            ignored   on
                         432* ;                  DTR level             on        on
                         433* ;                  RTS level             on        on
                         434* ;                  Transmitter enable    on        on
                         435* ;
                         436* ;Control I/O:
                         437* ;
                         438* ;There is no explicit input or output register, but the
                         439* ;signals are affected by transmitter and receiver condit
                         440* ;
                         441* ;Inputs    Channel A        Channel B
                         442* ;
                         443* ;          DCD C            DCD D not used
                         444* ;          CTS C            CTS D not used
                         445* ;          DSR C            DSR D not used
                         446* ;          RXC C *          RXC D **
                         447* ;          TXC C *          TXC D **
                         448* ;
                         449* ;Outputs    RTS C            RTS D not used
                         450* ;          DTR C            DTR D not used
                         451* ;          RXC C *          RXC D **
                         452* ;          TXC C *          TXC D **
                         453* ;
                         454* ;* RXC C can be received from the RS-232 line DD if a sw
                         455* ;
                         456* ;* TXC C can be received from the RS-232 line DB if a sw
                         457* ;
                         458* ;* TXC C is always transmitted on RS-232 line DA.
                         459* ;
                         460* ;** RXD D is connected to TXD D at the USART.  This sign
                         461* ;always driven on the RS-422 connector pins 2 and 7 (bal
                         462* ;pair). This signal can be received on RS-422 connector
                         463* ;8.  The senses of both ports C and D should be such tha
                         464* ;conflicts do not arise.  For example, on port D, disass
                         465* ;before setting the USART to produce TXC or RXC.  On por
                         466* ;the USART to accept clocks before closing the switches.
                         467* 
                         468* ;    The 9-pin subminiature D connector has RS-422 leve
                         469* ;    it. It is NOT a Macintosh connector.  If this port
                         470* ;    connected to an AppleTalk cable attached to a Maci
                         471* ;    serious damage can result.
                         472* 
File: C1.MAIN.TEXT                                                Page  13


                         473* ;Interrupt vector number is 96 = $60.
                         474* ;Vector base address is at $180.
                         475* ;
                         476* ;Interrupt Source Vector Number     Vector Address
                         477* ;
                         478* ;Transmit Buffer Empty  B   96           $180
                         479* ;External status change B   97           $184
                         480* ;Receive Char Available B   98           $188
                         481* ;Special rcv  condition B   99           $18c
                         482* ;Transmit Buffer Empty  A  100           $190
                         483* ;External status change A  101           $194
                         484* ;Receive Char Available A  102           $198
                         485* ;Special rcv  condition A  103           $19c
                         486* ;
                         487* ;      ----- 68564 Baud Rate Generator Time Const -----
                         488* ; (at 3.6864 Mhz)
                         489* ;Baud Rate       x16 Clock Mode
                         490* ;
                         491* ;19200                  3    prescale = 4
                         492* ; 9600                  6    prescale = 4
                         493* ; 7200                  8    prescale = 4
                         494* ; 4800                 12    prescale = 4
                         495* ; 3600                 16    prescale = 4
                         496* ; 2400                 24    prescale = 4
                         497* ; 2000                 29 *  prescale = 4
                         498* ; 1800                 32    prescale = 4
                         499* ; 1200                 48    prescale = 4
                         500* ;  600                 96    prescale = 4
                         501* ;  300                192    prescale = 4
                         502* ;  200                 18    prescale = 16
                         503* ;  150                 24    prescale = 16
                         504* ;  134.5               27 *  prescale = 16
                         505* ;  110                 33 *  prescale = 16
                         506* ;   75                 48    prescale = 16
                         507* ;   50                 72    prescale = 16
                         508* ;
                         509* ;*Actual baud rate does not exactly equal desired baud rate
                         510* ;
                         511* ;         ACTUAL = 3.6864x106/(PS) (CM) (TC)
                         512* ;
                         513* ;         where:
                         514* ;
                         515* ;               PS = Prescale = divided by 4 or 64
                         516* ;               CM = Clock Mode = divided by 1, 16, 32,
                         517* ;               TC = Time Constant, as shown above
                         518* ;
                         519* ;68564 Baud Rate Generator
                         520* ;
                         521* ;Error analysis @ 3.6864 Mhz
                         522* ;
                         523* ;      Percent Deviation
                         524* ;
                         525* ;Baud Rate       x16 Clock Mode
                         526* ;
File: C1.MAIN.TEXT                                                Page  14


                         527* ;2000                 -0.7
                         528* ; 134.5               -0.9
                         529* ; 110                 -0.8
                         530* ;
                         531* ;Percent Deviation = Actual - Desired x 100
                         532* ;                         Desired
                         533* ;
                         534* ;Refer to the Mostek Microelectronic Data Book.
                         535* 
      00000000           536* CMDREGAd       equ     $00     ;command reg A
      00000044           537* MODCTLAd       equ     $44     ;mode reg A
      00000077           538* INTCTLAd       equ     $77     ;interrupt control reg A
      00000000           539* SYNC1Ad        equ     $00     ;sync word reg 1 A
      00000000           540* SYNC2Ad        equ     $00     ;sync word reg 2 A
      000000C1           541* RCVCTLAd       equ     $c1     ;receiver control reg A
      000000C7           542* XMTCTLAd       equ     $c7     ;transmitter control reg A
                         543* ;STAT0Ad       equ    $        ;status reg 0 A
                         544* ;STAT1Ad       equ     $       ;status reg 1 A
                         545* ;DATREGAd      equ     $       ;data reg A
      00000060           546* TCREGAd        equ     $60     ;time constant reg A
      0000000D           547* BRGCTLAd       equ     $0d     ;baud rate generator crtl A
      00000060           548* VECTRGAd       equ     $60     ;interrupt vector reg A/B
                         549* 
      00000000           550* CMDREGBd       equ     $00     ;command reg B
      00000020           551* MODCTLBd       equ     $20     ;mode reg B
      0000006F           552* INTCTLBd       equ     $6f     ;interrupt control reg B
                         553* ;SYNC1Bd       equ     $       ;sync word reg 1 B
      0000007E           554* SYNC2Bd        equ     $7e     ;sync word reg 2 B
      000000C1           555* RCVCTLBd       equ     $c1     ;receiver control reg B
      000000C7           556* XMTCTLBd       equ     $c7     ;transmitter control reg B
                         557* ;STAT0Bd       equ     $       ;status reg 0 B
                         558* ;STAT1Bd       equ     $       ;status reg 1 B
                         559* ;DATREGBd      equ     $       ;data reg B
      00000060           560* TCREGBd        equ     $60     ;time constant reg B
      0000000D           561* BRGCTLBd       equ     $0d     ;baud rate generator crtl B
      00000060           562* VECTRGBd       equ     $60     ;interrupt vector reg B/B
                         563* 
                         564* ;
                         565* ; External CRT equates
                         566* ;
      00830300           567* DC0      EQU    duartbase         ;DATA INPUT PORT base
      00830317           568* DC0data  EQU    dc0+$17               ;DATA INPUT PORT
      00830313           569* DC0stat  EQU    dc0+$13               ;STATUS REGISTER
      00830315           570* DC0cmnd  EQU    dc0+$15               ;COMMAND REGISTER
      00000017           571* dc0d   equ     $17
                         572* ;
      00830217           573* KBcPort equ     mfpbase+$17          ;data comm 0 UART pointer
      00000017           574* KBuDa   equ     $17             ;UART data port offset
      00000013           575* KBuSt   equ     $13             ;UART status port offset
      00000000           576* KBrdBit equ     0               ;busy bit for input
                         577* 
                         578* 
                         579* ;68681 mouse equates
                         580* 
File: C1.MAIN.TEXT                                                Page  15


                         581* ;MS
      00000000           582* MSrdBit      equ    $0  ; receive bit
      00000003           583* MSuSt        equ    $03
                         584* 
                         585* 
                         586* 
                         587* ;
                         588* ; CC.PROM.DS -- Display driver equates
                         589* ;
      00880000           590* DShomeH  equ    DSPbase       ;{!UC}horizontal home location
      0088FB78           591* DShomHD  equ    DSPbase+619*104 ;{!UC}horizontal home down location
      00880064           592* DShomeV  equ    DSPbase+100   ;{!UC}vertical home location ok?, offset?
                         593* ;is 100 too much?  Where is vert offset; must be on word boundary
      00000068           594* DSdefOf  equ    104             ;default bytes per scan line
      00000006           595* DScellW  equ    6               ;character cell width
      0000000A           596* DScellY  equ    10              ;character cell height
      00000317           597* DSmaxXH  equ    791             ;132*DScellW-1
      0000026B           598* DSmaxYH  equ    619             ;62*DScellY-1
      00000269           599* DSmaxXV  equ    617             ;103*DScellW-1
      0000031F           600* DSmaxYV  equ    799             ;80*DScellY-1
                         601* ;
                         602* ; External CRT equates
                         603* ;
      00830217           604* DScPort equ     mfpbase+$17          ;data comm 0 UART pointer
      00000000           605* DSuDa   equ     0               ;UART data port offset
      00000013           606* DSuSt   equ     $13             ;UART status port offset
      00000002           607* DSwrBit equ     2               ;busy bit for output
                         608* ;
                         609* ; CC.PROM.OD -- Omninet disk driver equates
                         610* ;
      00830601           611* StrAdr  EQU     SYSbase+$30601  ;address of Transporter register
      00830200           612* RdyAdr EQU      mfpbase ;address of mfpio register A, used for Omninet ready
                         613* ;
      00010000           614* SegOfst equ     $10000          ;loww address of segments is xa16
      00001000           615* PagOfst equ     $1000           ;low address of pages is xa12
      00000080           616* numsegs equ     curmem/SegOfst ;number of segments currently on board
      00000800           617* numpags equ     curmem/pagOfst ;number of pages currently on board
                         618* ;
                         619* ; Memory management register equates
                         620* ;
      00840003           621* CtxReg  equ     $840003         ;Context register
      00840005           622* ErrReg  Equ     CtxReg+2        ;Error Register
      00840007           623* StatReg equ     ErrReg+2        ;Status Register
                         624* ;Status register equates
      0000003F           625* TestOn  equ     $3F             ;anding value to turn on both leds
      00000080           626* TestOK  equ     $80             ;oring value to turn off red led
      00000040           627* TestBad equ     $40             ;oring value to turn off green led
      00000006           628* GrLed   equ     6               ;bit value in stat reg of green led
      00000007           629* RedLed  equ     7               ;bit value in stat reg of red led
                         630* ;
      00000007           631* AMAbit  equ     7               ;allow map access bit
      00000006           632* SLMbit  equ     6               ;select high map bit
      00000004           633* SUMbit  equ     4               ;select user mode bit
      00000005           634* SegBit  equ     5               ;select segment map bit
File: C1.MAIN.TEXT                                                Page  16


      00000002           635* MdPerMp equ     2               ;number of modes(usr/sup) per map (high/low)
      00000010           636* CxPerMp equ     $10             ;number of contexts per map
      00000040           637* SgPerCx equ     $40             ;number of segments per context {for 4meg}
      00000010           638* PgPerSg equ     $10             ;number of pages per segment
      00000400           639* PgPerCx equ     PgPerSg*SgPerCx ;number of pages per context
      00000800           640* WdPerPg equ     $800            ;number of words per page
      00000F00           641* InSDTp  equ     $0F00           ;initial segment data for transparent map
      00000000           642* InPDTp  equ     0               ;initial page data for transparent map
                         643* ;
      00000010           644* Alt0dat equ     $10             ;data to write to set altmap back to 0
      00000050           645* Alt1dat equ     $50             ;data to write to set altmap 1
      0000008B           646* Bootoff equ     $8B             ;make boot state high (altmap 1)
      00000000           647* Booton  equ     0               ;assert boot state (altmap 0)
      00830701           648* csrp   equ     $830701         ;command & status regs
      00830701           649* iobootsw equ   csrp
      00000001           650* notboot equ    1
      00000002           651* diag   equ     2
      00000004           652* enclk   equ    4
      00000008           653* videoon equ    8
      00000010           654* halfbright equ $10
      00000020           655* altvid  equ    $20
      00000040           656* notgreen   equ $40
      00000080           657* notred     equ $80
      00000005           658* bootsw1    equ 5
      00000004           659* bootsw2    equ 4
      00000003           660* bootsw3    equ 3
      00000002           661* bootsw4    equ 2
                         662* ;
                         663* ;special equates for 68010 instructions
                         664* ;
                         665* ;move between d0 and vector base register
                         666* ;
      4E7B0801           667* MCD0VBR equ     $4E7B0801       ;movec d0,VBR
      4E7A0801           668* MCVBRD0 equ     $4E7A0801       ;movec VBR,D0
                         669* 
      00830500           670* Calbase equ     $830500         ;clock calendar
      00830800           671* DMAbase equ     $830800         ;DMA chip
      00830900           672* FPUbase equ     $830900         ;floating point processor
                         673* 
                         674* ; Character Set Record Equates
                         675* ;
                         676* ;Stblloc equ    0      ;character set data pointer (not used)
      00000004           677* CSlpch   equ    4      ;scanlines per character
      00000006           678* CSbpch   equ    6      ;bits per character
      00000008           679* CSfrstch equ    8      ;first character code - ascii
      0000000A           680* CSlastch equ    10     ;last character code - ascii
      0000000C           681* CSmask   equ    12     ;mask used in positioning cells
      00000010           682* CSattr1  equ    16     ;attributes
                         683*                        ;  bit 0 = 1 - vertical orientation
      00000011           684* CSattr2  equ    17     ;currently unused
      00000012           685* CSdata   equ    18     ;offset of char data from char record
                         686* ;
                         687* ; Window Record Equates
                         688* ;
File: C1.MAIN.TEXT                                                Page  17


      00000000           689* WRcharpt equ    0       ;character set pointer
      00000004           690* WRhomept equ    4       ;home (upper left) pointer
      00000008           691* WRcuradr equ    8       ;current location pointer
      0000000C           692* WRhomeof equ    12      ;bit offset of home location
      0000000E           693* WRbasex  equ    14      ;home x value, relative to root window
      00000010           694* WRbasey  equ    16      ;home y value, relative to root window
      00000012           695* WRlngthx equ    18      ;maximum x value, relative to window (bits)
      00000014           696* WRlngthy equ    20      ;maximum y value, relative to window (bits)
      00000016           697* WRcursx  equ    22      ;current x value (bits)
      00000018           698* WRcursy  equ    24      ;current y value (bits)
      0000001A           699* WRbitofs equ    26      ;bit offset of current address
      0000001C           700* WRgrorgx equ    28      ;graphics - origin x (bits relative to home loc)
      0000001E           701* WRgrorgy equ    30      ;graphics - origin y (bits relative to home loc)
      00000020           702* WRattr1  equ    32      ;attributes
      00000021           703* WRattr2  equ    33      ;attributes
      00000000           704* vert     equ    0       ;  1 = vertical, 0 = horizontal
      00000022           705* WRstate  equ    34      ;used for decoding escape sequences
      00000023           706* WRrcdlen equ    35      ;window description record length
                         707*                         ;
      00000024           708* WRlength equ    36      ;actual window record length
                         709* 
                         710* 
                         711* ;       include 'os.gbl.asm.text' ;  (for drive stuff)
File: C1.MAIN.TEXT                                                Page  18


                         713* ; Corvus CONCEPT Workstation PROM address vectors
                         714* ;
0000                     715*         org     ROM0base         ;Don't use org until ready for prom
0000  00000000           716* Zero    data.l  0          ;0    ;(10000) initial stack pointer
0004  00810030+          717*         data.l  DFinit     ;4   ;initial program counter
0008  0081026C+          718*         data.l  Command    ;8   ;command set up and handling routine
000C  00                 719*         data.b  PROMvers    ;C   ;version
000D  02                 720*         data.b  PROMlevl    ;D   ;level
000E  FFFF               721*         data.w  $FFFF      ;E   ;checksum
0010  008102B0+          722*         data.l  mainmenu    ;10  ;menu manager
0014  601A               723*         bra.s   DFinit     ;14  ;for bootprom jump
0016  0000               724*         data.w  0
      00810018           725* outchar equ     $810018
0018  008120A2+          726*         data.l  DSoutch    ;18
      0081001C           727* outstr  equ     $81001C
001C  00812078+          728*         data.l  DSoutst    ;1c
      00810020           729* getchar equ     $810020
0020  0081268C+          730*         data.l  KBgetch    ;20
      00810024           731* gethexp equ     $810024
0024  00810440+          732*         data.l  getpara    ;24
      00810028           733* instr   equ     $810028
0028  008103FA+          734*         data.l  input      ;28
      0081002C           735* SEVec   equ     $81002C
002C  00811760+          736* SEVect  data.l  SETerr
      00000010           737* highbeep equ    $10
      000000D0           738* lowbeep  equ    $d0
                         739* ;
                         740*         include  'siv.init'
                         741* ;Initialise
0030  46FC  2700         742* DFinit  move    #$2700,SR              ;mask interrupts
0034  4FF9  0080  0FFC   743*         lea     istack.l,SP            ;initial stack pointer
003A  203C  0080  0000   744*         move.l  #RAMBase,d0            ;68010 - use static ram base for vector
0040  4E7B0801           745*         data.l  MCD0VBR                ;movec  d0,vbr--change vector base reg
                         746* 
                         747* ;initialise Multi Function Peripheral 68901
0044  227C  0083  0200   748* mfp     move.l  #mfpbase,a1
004A  137C  0000  0003   749*         move.b  #AERd   ,   AER(a1)   ;  active edge
0050  137C  0000  0005   750*         move.b  #DDRd   ,   DDR(a1)   ;  data direction
0056  137C  0018  0007   751*         move.b  #IERAd  ,   IERA(a1)  ;  interrupt enable A
005C  137C  008F  0009   752*         move.b  #IERBd  ,   IERB(a1)  ;  interrupt enable B
0062  137C  00D8  0013   753*         move.b  #IMRAd  ,   IMRA(a1)  ;  interrupt mask A
0068  137C  00CF  0015   754*         move.b  #IMRBd  ,   IMRB(a1)  ;  interrupt mask B
006E  137C  0044  0017   755*         move.b  #VRd    ,   VR(a1)    ;  interrupt vector
0074  137C  0008  0019   756*         move.b  #TACRd  ,   TACR(a1)  ;  timer A control
007A  137C  0001  001B   757*         move.b  #TBCRd  ,   TBCR(a1)  ;  timer B control
0080  137C  0010  001D   758*         move.b  #TCDCRd ,   TCDCR(a1) ;  timer C,D control
0086  137C  00A0  001F   759*         move.b  #TADRd  ,   TADR(a1)  ;  timer A data
008C  137C  0030  0021   760*         move.b  #TBDRd  ,   TBDR(a1)  ;  timer B data
0092  137C  0010  0023   761*         move.b  #TCDRd  ,   TCDR(a1)  ;  timer C data
0098  137C  0000  0025   762*         move.b  #TDDRd  ,   TDDR(a1)  ;  timer D data
009E  137C  0000  0027   763*         move.b  #SCRd   ,   SCR(a1)   ;  sync char
00A4  137C  0089  0029   764*         move.b  #UCRd   ,   UCR(a1)   ;  usart control(kybd)
00AA  137C  00C0  0029   765*         move.b  #KBCONd ,   KBCON(a1) ;  keyboard control
00B0  137C  000F  000F   766*         move.b  #stopCtrCd, stopCtrC(a1) ;
File: C1.MAIN.TEXT                                                Page  19


00B6  137C  0001  002B   767*         move.b  #RSRd   ,   KBSTAT(a1) ;  turn on receiver
                         768* ;time to send initialise to keyboard and read ID
00BC  137C  0004  002D   769*         move.b  #TSR1d  ,   TSR(a1)   ;  reset keyboard
00C2  6100  2AB2         770*         bsr     beep
00C6  6100  134A         771*        bsr     delay         ;wait a bit
00CA  137C  0002  002D   772*         move.b  #TSR0d  ,   TSR(a1)   ;  enable keyboard
                         773* ;initialise uart
00D0  227C  0083  0300   774*        move.l  #duartbase,a1
00D6  137C  0012  0001   775*        move.b  #MR1Ad,MR1A(a1)  ;     $12 mode reg 1A
00DC  137C  0007  0001   776*        move.b  #MR2Ad,MR2A(a1)  ;      07 mode reg 2A
00E2  137C  000C  0003   777*        move.b  #SRAd ,SRA(a1)   ;     $0c status reg A
00E8  137C  0066  0003   778*        move.b  #CSRAd,CSRA(a1)  ;     $66 clock sel A
00EE  137C  0019  0005   779*        move.b  #CRAd ,CRA(a1)   ;     $19 command reg A
00F4  137C  000B  0009   780*        move.b  #ACRd ,ACR(a1)   ;     $0b Aux control
00FA  137C  00F2  000B   781*        move.b  #IMRd ,IMR(a1)   ;     $f2 Interrupt mask
0100  137C  0013  0011   782*        move.b  #MR1Bd,MR1B(a1)  ;     $13 mode reg 1B
0106  137C  0007  0011   783*        move.b  #MR2Bd,MR2B(a1)  ;      07 mode reg 2B
010C  137C  00BB  0013   784*        move.b  #CSRBd,CSRB(a1)  ;     $bb clock sel B
0112  137C  0015  0015   785*        move.b  #CRBd ,CRB(a1)   ;     $15 command reg B
0118  137C  0050  0019   786*        move.b  #IVRd ,IVR(a1)   ;     $50 Interrupt vector
011E  137C  00FA  001B   787*        move.b  #OPCRd,OPCR(a1)  ;     $fa Output port config
                         788* ;INITIALISE usart channel A(async)   '
0124  227C  0083  0400   789*        move.l  #dusartbase,a1
012A  137C  0000  0001   790*        move.b  #cmdregad,cmdrega(a1)  ;
0130  137C  0044  0003   791*        move.b  #MODCTLAd,MODCTLA(a1)  ;
                         792* ;      move.b  #INTCTLAd ,INTCTLA(a1)   ;
                         793* ;      move.b  #SYNC1Ad,SYNC1A(a1)  ;
                         794* ;      move.b  #SYNC2Ad ,SYNC2A(a1)   ;
0136  137C  00C1  000B   795*        move.b  #RCVCTLAd ,RCVCTLA(a1)   ;
013C  137C  00C7  000D   796*        move.b  #XMTCTLAd ,XMTCTLA(a1)   ;
                         797* ;      move.b  #STAT0Ad,STAT0A(a1)  ;
                         798* ;      move.b  #STAT1Ad,STAT1A(a1)  ;
                         799* ;      move.b  #DATREGAd,DATREGA(a1)  ;
0142  137C  0060  0015   800*        move.b  #TCREGAd ,TCREGA(a1)   ;
0148  137C  000D  0017   801*        move.b  #BRGCTLAd ,BRGCTLA(a1)   ;
014E  137C  0060  0019   802*        move.b  #VECTRGAd,VECTRGA(a1)  ;
                         803* 
0154  137C  0000  0021   804*        move.b  #cmdregbd,cmdregb(a1)  ;
015A  137C  0020  0023   805*        move.b  #MODCTLBd,MODCTLB(a1)  ;
0160  137C  006F  0025   806*        move.b  #INTCTLBd ,INTCTLB(a1)   ;
                         807* ;      move.b  #SYNC1Bd,SYNC1B(a1)  ;
0166  137C  007E  0029   808*        move.b  #SYNC2Bd ,SYNC2B(a1)   ;
016C  137C  00C1  002B   809*        move.b  #RCVCTLBd ,RCVCTLB(a1)   ;
0172  137C  00C7  002D   810*        move.b  #XMTCTLBd ,XMTCTLB(a1)   ;
                         811* ;      move.b  #STAT0Bd,STAT0B(a1)  ;
                         812* ;      move.b  #STAT1Bd,STAT1B(a1)  ;
                         813* ;      move.b  #DATREGBd,DATREGB(a1)  ;
0178  137C  0060  0035   814*        move.b  #TCREGBd ,TCREGB(a1)   ;
017E  137C  000D  0037   815*        move.b  #BRGCTLBd ,BRGCTLB(a1)   ;
0184  137C  0060  0039   816*        move.b  #VECTRGBd,VECTRGB(a1)  ;
                         817* 
                         818* 
                         819* ;clear static RAM (what about video?)
018A  41F9  0080  0000   820*         lea     SYSbase.l,A0      ;zero static ram
File: C1.MAIN.TEXT                                                Page  20


0190  43F9  0080  0E00   821*         lea     Stack.l,A1    ;
0196  4218               822* clear   clr.b   (A0)+           ;clear mem
0198  B1C9               823*         cmpa.l  A1,A0
019A  6FFA               824*         ble.s   clear
019C  43F9  0088  0000   825*         lea     DSPbase.l,a1
01A2  4281               826*         clr.l   d1
01A4  303C  4000         827*         move.w  #$4000,d0
01A8  22C1               828* clrvid  move.l  d1,(a1)+
01AA  51C8  FFFC         829*         dbra    d0,clrvid
                         830* ;note,  this is not clrscreen
01AE  303C  0080         831* mainwin move    #$80,d0         ;left of window            |.....
01B2  323C  026B         832*         move    #619,d1         ;number of screen lines    |    .
01B6  43F9  0088  0000   833*         lea     DShomeH.l,a1    ;top left corner           |.....
01BC  243C  0000  0068   834*         move.l  #DSdefOf,d2      ;scan offset
01C2  1280               835* winloop0 move.b  d0,(a1)
01C4  D3C2               836*          adda.l  d2,a1           ;add scan offset
01C6  51C9  FFFA         837*          dbra    d1,winloop0
                         838* 
01CA  303C  0001         839*         move    #$01,d0         ;right of window            |....|
01CE  323C  026B         840*         move    #619,d1         ;number of screen lines     |    |
01D2  43F9  0088  0064   841*         lea     DShomeV.l,a1    ;top right corner           |....|
01D8  243C  0000  0068   842*         move.l  #DSdefOf,d2      ;scan offset
01DE  1280               843* winloop1 move.b  d0,(a1)
01E0  D3C2               844*          adda.l  d2,a1           ;add scan offset
01E2  51C9  FFFA         845*          dbra    d1,winloop1
                         846* 
01E6  203C  FFFF  FFFF   847*         move.l  #$ffffffff,d0   ;top of window              |----|
01EC  323C  0018         848*         move    #24,d1         ;number of screen lines      |    |
01F0  43F9  0088  0000   849*         lea     DShomeH.l,a1    ;top left corner            |....|
01F6  22C0               850* winloop2 move.l  d0,(a1)+
01F8  51C9  FFFC         851*          dbra    d1,winloop2
                         852* 
01FC  203C  FFFF  FFFF   853*         move.l  #$ffffffff,d0     ; bottom of window
0202  323C  0018         854*         move    #24,d1            ;number of screen lines     |----|
0206  43F9  0088  FB78   855*         lea     DShomHD.l,a1      ;bottom left corner         |    |
020C  22C0               856* winloop3 move.l  d0,(a1)+         ;                           |____|
020E  51C9  FFFC         857*          dbra    d1,winloop3
                         858* ;test for boot switch 3   not for now, do it in ds
0212  08B9  0000  0080   859*         bclr    #Xcrtbit,SysFlag.l      ;terminal or display?
0218  0D64  
021A  0839  0002  0083   860*         btst    #bootsw4,IObootsw.l     ;using external CRT?            0.8
0220  0701  
0222  6700  000E         861*         boff    doboot                  ;yes, use data comm 0           0.8
0226  08F9  0000  0080   862*         bset    #Xcrtbit,SysFlag.l      ;terminal or display?
022C  0D64  
022E  6100  1EEE         863*         bsr     DSinit         ; go to - Initialize display driver
                         864* ;if bootswitch 0 then bclr #Xcrtbit,(a6)
                         865* 
                         866* ;dont forget boot status reg in memory and processor
      0000000B           867* firstcom equ    diag+videoon+notboot
      0000000A           868* seconcom equ    diag+videoon
                         869* 
0232  13FC  000B  0083   870* doboot  move.b  #firstcom,iobootsw.l;turn bootmode off processor
0238  0701  
File: C1.MAIN.TEXT                                                Page  21


023A  13FC  000B  0084   871*         move.b  #firstcom,StatReg.l;turn bootmode off memory
0240  0007  
0242  6100  08F2         872*         bsr     MapTran         ;map transparent -- for now.
                         873* ;       move.l  #$830021,IOaddr.l;default to port 1
                         874* ;       move.b  #1,DrvDflt.l    ;default drive #1
0246  13FC  0084  0080   875*         move.b  #$84,Memsz.l      ;assume 2 banks-1 megabyte
024C  0D65  
024E  23FC  0010  0000   876*         move.l  #onemeg,Curmem.l     ;assume 1 megabyte
0254  0080  0D66  
0258  6100  06B6         877*         bsr     MemSize
                         878* ;
                         879* ;init dusart
                         880* ;verify registers include ver
                         881* ;flash LEDs  do funny beep if wrong
                         882*  ; Display output message
025C  487A  000E+        883*         pea     command
0260  4BFA  2C1A+        884*         lea     msgInit,A5
0264  6100  1E12         885*         bsr     DSoutst
                         886* ;      ;bset    #Xcrtbit,(A6)   ;set for terminal
0268  6100  2534         887*         bsr     sexvec
                         888* ;if this means anything now it affects diag and boot
                         889* ;       bsr     setalt1         ;
                         890* 
026C  46FC  2700         891* command move.w  #$2700,SR       ;mask interrupts
0270  0839  0004  0080   892*         btst    #TranBit,SysFlag.l ;transparent flag
0276  0D64  
0278  6604               893*         bon.s   comnext
027A  6100  08BA         894*         bsr     MapTran         ;
027E  4BFA  293C+        895* Comnext lea     msgHelp1,A5     ;display help message
0282  6100  1DF4         896*         bsr     DSoutst
0286  6000  0068         897*         bra     dragon
File: C1.MAIN.TEXT                                                Page  22


028A  6100  1E16         899* MenuKey bsr     DSoutch         ;show prompt
028E  7000               900*         moveq   #0,D0           ;zero reg
0290  6100  23F4         901*         bsr     KBgetUC         ;read a character
0294  B03C  004D         902*         cmp.b   #'M',D0         ;display menu again
0298  6716               903*         beq.s   mainmenu        ;*
029A  903C  0030         904*         sub.b   #'0',D0         ;make sure number between 0-9 selected.
029E  4E75               905*         RTS
02A0  6100  0B06         906* Testall bsr     mtstall
02A4  660A               907*         bne.s   MainMenu
02A6  6100  0FA0         908*         bsr     Drall1
02AA  6604               909*         bne.s   MainMenu
02AC  6100  13E6         910*         bsr     allerrtst
                         911* ;
                         912* ;Main Menu
                         913* ;
02B0                     914* MainMenu
02B0  4FF9  0080  0FFC   915*         lea     istack.l,SP     ;set new stack
02B6  4BFA  2B3A+        916*         lea     msgmainmenu,A5
02BA  6100  1DBC         917*         bsr     DSoutST
02BE  6100  1DD6         918* MainPrmt bsr     DSoutcr
02C2  08F9  0000  0080   919*         bset    #normop,Beflag.l
02C8  0D94  
02CA  103C  003E         920*         move.b  #Prompt0,D0         ;prompt for test menu
02CE  61BA               921*         bsr.s   MenuKey         ;get response from user
02D0  487A  FFEC+        922*         pea     MainPrmt         ;return to prompt
02D4  41BC  0007         923*         chk     #7,D0         ;*
02D8  E300               924*         asl.b   #1,d0              ;double for table
02DA  303B  0006+        925*         move.w  maintbl(D0.W),D0
02DE  4EFB  0002+        926*         jmp     Maintbl(D0.W)
                         927* ;
02E2  000E               928* Maintbl  data.w  dragon-Maintbl
02E4  FFBE               929*         data.w  Testall-Maintbl
02E6  0A92               930*         data.w  MapMenu-Maintbl
02E8  0EFC               931*         data.w  DRMenu-Maintbl
02EA  1372               932*         data.w  ErrMenu-Maintbl
02EC  1736               933*         data.w  OMtest-Maintbl
                         934* ;       data.w  IOtsts-Maintbl
02EE  1ABC               935*         data.w  Loops-Maintbl
File: C1.MAIN.TEXT                                                Page  23


                         937* ;
02F0  4BFA  2BC9+        938* Dragon  lea     msg1,A5
02F4  6100  1D82         939*         bsr     DSoutst
02F8  13FC  0000  0080   940*         move.b  #NormOP,BEflag.l;bus error normal
02FE  0D94  
0300  4FF9  0080  0FFC   941*         lea     istack.l,SP     ;set new stack
0306  487A  FFE8+        942*         pea     dragon
030A  103C  002A         943*         move.b  #prompt1,D0
030E  6100  1D92         944*         bsr     DSoutch
0312  6100  00E6         945*         bsr     input
0316  0C15  000D         946*         cmpi.b  #DSCcr,(A5)     ;is first char a cr?
031A  67D4               947*         beq.s   dragon         ;yes prompt
031C  361D               948*         move.w  (A5)+,D3         ;get input word into d3
031E  3803               949*         move.w  D3,D4           ;save it
0320  7400               950*         moveq   #0,D2              ;use d2 as offset into command table
0322  303B  2048+        951* DFcloop move.w  dflycmd(D2),D0  ;get cmd from table for below
0326  5442               952*         addq    #2,D2           ;increment offset to table
0328  323B  2042+        953*         move.w  dflycmd(D2),D1  ;get offset to jump to
032C  B07C  FFFF         954*         cmp.w   #-1,D0          ;end of table?
0330  6714               955*         beq.s   unkcmd          ;unknown cmd
0332  1604               956*         move.b  D4,D3           ;restore d3
0334  B03C  002A         957*         cmp.b   #'*',D0          ;is 2nd char don't care?
0338  6602               958*         bne.s   dfc2            ;no, branch
033A  1600               959*         move.b  D0,D3           ;yes put char in d3
033C  5442               960* DFc2    addq    #2,D2           ;increment table offset to next command
033E  B043               961*         cmp.w   D3,D0         ;is it the command from above?
0340  66E0               962*         bne.s   dfcloop         ;no, loop
0342  4EFB  1028+        963*         jmp     dflycmd(D1)     ;jump to command address
                         964* ;
0346  4BFA  2C0C+        965* unkcmd  lea     msgunkcmd,A5
034A  6000  1D2C         966*         bra     DSoutst         ;output with cr
                         967* ;       bra.s   Mainprmt         ;prompt for command
                         968* ;
034E  4DF9  0081  0014   969* Restart lea     $810014.l,A6
0354  4ED6               970*         jmp     (A6)
0356                     971* Usrmode
0356  2A7C  0080  0C00   972*         movea.l #ustack,a5     ;initial user stack pointer
035C  4E65               973*         move.l  a5,usp          ;*
035E  46FC  0700         974*         move.w  #$0700,SR
0362  6000  FF4C         975*         bra     mainmenu
0366  4E40               976* Sprmode Trap    #0
0368  6000  FF46         977*         bra     mainmenu
                         978* ;
                         979*            ;*******************************************************
File: C1.MAIN.TEXT                                                Page  24


036C  3F2A               981* dflycmd data.w  '?*'            ;Set altmap to 1
036E  2848               982*         data.w  Help1-dflycmd  ;address offset from start of table
0370  4131               983*         data.w  'A1'            ;Set altmap to 1
0372  0682               984*         data.w  SetAlt1-dflycmd  ;address offset from start of table
0374  4130               985*         data.w  'A0'            ;Set altmap to 0
0376  0692               986*         data.w  SetAlt0-dflycmd  ;address offset from start of table
0378  414D               987*         data.w  'AM'             ;change memory command
037A  0466               988*         data.w  Chngmem-dflycmd    ;address offset from start of table
037C  4342               989*         data.w  'CB'             ;compare byte command
037E  0348               990*         data.w  Cmpbyt-dflycmd     ;address offset from start of table
0380  4349               991*         data.w  'CI'             ;compare byte command
0382  03B0               992*         data.w  Cmpiwrd-dflycmd     ;address offset from start of table
0384  434A               993*         data.w  'CJ'             ;compare byte command
0386  038C               994*         data.w  Cmpibyt-dflycmd     ;address offset from start of table
0388  4352               995*         data.w  'CR'             ;compare byte command
038A  06A2               996*         data.w  SetCr-dflycmd     ;address offset from start of table
038C  4357               997*         data.w  'CW'             ;compare command
038E  036A               998*         data.w  Cmpwrd-dflycmd     ;address offset from start of table
0390  4442               999*         data.w  'DB'             ;display command
0392  0272              1000*         data.w  display-dflycmd    ;address offset from start of table
0394  4450              1001*         data.w  'DP'             ;display command
0396  09C2              1002*         data.w  dmppag-dflycmd    ;address offset from start of table
0398  4453              1003*         data.w  'DS'             ;display command
039A  0954              1004*         data.w  dmpseg-dflycmd    ;address offset from start of table
039C  4457              1005*         data.w  'DW'             ;display command
039E  02AC              1006*         data.w  dmpword-dflycmd    ;address offset from start of table
03A0  4552              1007*         data.w  'ER'             ;compare byte command
03A2  06D6              1008*         data.w  SetEr-dflycmd     ;address offset from start of table
03A4  4649              1009*         data.w  'FI'             ;fill with incrementing data
03A6  0318              1010*         data.w  FillInc-dflycmd    ;address offset from start of table
03A8  464A              1011*         data.w  'FJ'             ;fill with incrementing data
03AA  0334              1012*         data.w  FllIncB-dflycmd    ;address offset from start of table
03AC  4642              1013*         data.w  'FB'             ;fill command
03AE  02F4              1014*         data.w  Fillbyt-dflycmd    ;address offset from start of table
03B0  4657              1015*         data.w  'FW'             ;fill command
03B2  0306              1016*         data.w  Fillwrd-dflycmd    ;address offset from start of table
03B4  472A              1017*         data.w  'G*'             ;compare  word command
03B6  073A              1018*         data.w  Gocmd-dflycmd     ;address offset from start of table
03B8  4C4D              1019*         data.w  'LM'             ;Loop menu command
03BA  1A32              1020*         data.w  Loops-dflycmd      ;address offset from start of table
03BC  4D4D              1021*         data.w  'MM'             ;move memory command
03BE  03D4              1022*         data.w  Movemem-dflycmd     ;address offset from start of table
03C0  4D53              1023*         data.w  'MS'             ;go to command
03C2  05E6              1024*         data.w  MemStat-dflycmd    ;address offset from start of table
03C4  4D2A              1025*         data.w  'M*'             ;display menu
03C6  FF44              1026*         data.w  Mainmenu-Dflycmd ;address offset from start of table
03C8  4E4D              1027*         data.w  'NM'             ;go to command
03CA  0644              1028*         data.w  NewMem-dflycmd    ;address offset from start of table
03CC  5253              1029*         data.w  'RS'             ;restart
03CE  FFE2              1030*         data.w  Restart-dflycmd  ;address offset from start of table
03D0  5352              1031*         data.w  'SR'             ;compare byte command
03D2  070A              1032*         data.w  SetSr-dflycmd     ;address offset from start of table
03D4  534D              1033*         data.w  'SM'             ;Test menu command
03D6  FFFA              1034*         data.w  Sprmode-dflycmd      ;address offset from start of table
File: C1.MAIN.TEXT                                                Page  25


03D8  554D              1035*         data.w  'UM'             ;Test menu command
03DA  FFEA              1036*         data.w  Usrmode-dflycmd      ;address offset from start of table
03DC  FFFF              1037*         data.w  $FFFF
File: C1.MAIN.TEXT                                                Page  26


03DE  103C  0008        1039* Rubout  move.b  #DSCbs,D0       ;output a back space
03E2  6100  1CBE        1040*         bsr     DSoutch         ;*
03E6  103C  0020        1041* Backsp  move.b  #DSCblnk,D0     ;output a space
03EA  6100  1CB6        1042*         bsr     DSoutch         ;*
03EE  103C  0008        1043*         move.b  #DSCbs,D0       ;output a back space
03F2  6100  1CAE        1044*         bsr     DSoutch         ;*
03F6  4225              1045*         clr.b   -(A5)           ;fix buffer pointer
03F8  4E75              1046*         RTS
                        1047* ;
                        1048* ;Input ascii characters into io buff until return
                        1049* ;ignore initial spaces
                        1050* ;Exit A5-start of iobufff
03FA                    1051* Input
03FA  2A7C  0080  0D00  1052*         movea.l #iobuff,A5      ;point to iobuffer
0400  48E7  8004        1053*         movem.l D0/A5,-(SP)     ;save registers
0404  4280              1054*         clr.l   D0              ;zero
0406  4295              1055*         clr.l   (A5)
                        1056*        ;bset    #Echobit,SysFlag.l;set echo mode
0408  6100  227C        1057* Input2  bsr     KBgetUC         ;get next ascii and convert to UC
040C  B03C  0008        1058*         cmp.b   #DSCbs,D0        ;is it a back space?
0410  6604              1059*         bne.s   Input3          ;no, continue
0412  61D2              1060*         bsr.s   Backsp          ;yes process
0414  60F2              1061*         bra.s   input2          ;get next
0416  B03C  007F        1062* Input3  cmp.b   #DSCdel,D0       ;is it a delete?
041A  6604              1063*         bne.s   Input31         ;no continue
041C  61C0              1064*         bsr.s   Rubout          ;yes, output a space between to backspaces.
041E  60E8              1065*         bra.s   Input2          ;get a new character
                        1066* ;
0420  B03C  000A        1067* Input31 cmp.b   #DSClf,D0       ;is it a lf?
0424  6710              1068*         beq.s   InputE          ;yes, don't put in buffer
0426  1AC0              1069*         move.b  D0,(A5)+        ;put in buffer
0428  BBFC  0080  0D63  1070*         cmpa.l  #iobfend,A5     ;at end of buffer?
042E  6706              1071*         beq.s   inputE          ;yes, do not overrun
0430  B03C  000D        1072* Input4  cmp.b   #DSCcr,D0       ;is it a cr?
0434  66D2              1073*         bne.s   Input2          ;no, continue input
0436  1ABC  000D        1074* inputE  move.b  #DSCcr,(A5)    ;end of input-make sure its a CR
                        1075*        ;bclr    #Echobit,SysFlag.l;clear echo mode
043A  4CDF  2001        1076*         movem.l (SP)+,D0/A5     ;restore registers
043E  4E75              1077*         RTS                     ;return
File: C1.MAIN.TEXT                                                Page  27


                        1079* ;GetPara - Routine to translate upper-case ascii characters in a buffer to
                        1080* ;          binary(hex) numbers. Initial spaces are ignored and characters
                        1081* ;          are read until a space or return is encountered.  If a non-hex
                        1082* ;          character is read a message is output & the 2nd address on stack is
                        1083* ;          returned to.  On exit from the loop A5 points to the space or return
                        1084* ;          character.
                        1085* ;     Enter - A5 points to ascii string to be converted
                        1086* ;     Exit  - D0 contain the hex parameter
                        1087* ;             A5 points to the CR or space character if no errors
0440  48E7  6000        1088* GetPara movem.l D1/D2,-(SP)     ;save registers
0444  4280              1089*         clr.l   D0              ;zero
0446  4281              1090*         clr.l   D1              ;zero
0448  121D              1091* Getpar1 move.b  (A5)+,D1        ;read first character
044A  675A              1092*         beq.s   EndPara
044C  B23C  0020        1093*         cmp.b   #DSCblnk,D1     ;ignore leading spaces
0450  67F6              1094*         beq.s   Getpar1         ;*
0452  6004              1095*         bra.s   Firstch         ;branch for first char
0454  121D              1096* NextCh  move.b  (A5)+,D1        ;get next ascii
0456  674E              1097*         beq.s   EndPara         ;exit on zero
0458  B23C  0030        1098* Firstch cmp.b   #'0',D1         ;is it a zero?
045C  6B24              1099*         bmi.s   ChkCtl          ;if it is less than check for control char
045E  B23C  0039        1100*         cmp.b   #'9',D1         ;is it a nine?
0462  6E06              1101*         bgt.s   ChkAlph         ;greater than check for alphanumeric char
0464  0401  0030        1102*         subi.b  #$30,D1         ;make binary from decimal
0468  6010              1103*         bra.s   SetReg          ;set the registers up
046A  B23C  0041        1104* ChkAlph cmp.b   #'A',D1         ;is it an A?
046E  6B24              1105*         bmi.s   NotHex          ;less than-not hex
0470  B23C  0046        1106*         cmp.b   #'F',D1         ;is it an F?
0474  6E1E              1107*         bgt.s   NotHex          ;greater than-not hex
0476  0401  0037        1108*         subi.b  #$37,D1         ;make binary from ascii alpha char
047A  2400              1109* SetReg  move.l  D0,D2           ;save previous character
047C  E980              1110*         asl.l   #4,D0           ;move d1 up a nibble
047E  8001              1111*         or.b    D1,D0           ;put new lower nibble in D1
0480  60D2              1112*         bra.s   NextCh          ;get the next character
0482  B23C  000D        1113* ChkCtl  cmp.b   #DSCcr,D1       ;is it a carriage return?
0486  671E              1114*         beq.s   EndPara         ;yes, finish routine
0488  B23C  000A        1115*         cmp.b   #DSClf,D1       ;is it a line feed?
048C  6718              1116*         beq.s   EndPara         ;yes, finish routine.
048E  B23C  0020        1117*         cmp.b   #DSCblnk,D1     ;is it a space?
0492  6712              1118*         beq.s   EndPara         ;yes, finish routine
0494  1001              1119* NotHex  move.b  D1,D0           ;get bad char
0496  6100  1C0A        1120*         bsr     DSoutch         ;display character
049A  4BFA  2A9D+       1121*         lea     msgNotHex,A5    ;get message
049E  6100  1BD8        1122*         bsr     DSoutst         ;output it
04A2  6000  FE4C        1123*         bra     Dragon          ;go to dragonfly
04A6  4A25              1124* EndPara tst.b   -(a5)           ;adust a5
04A8  4CDF  0006        1125*         movem.l (SP)+,D1/D2
04AC  4E75              1126*         RTS
File: C1.MAIN.TEXT                                                Page  28


                        1128* ;
                        1129* ;outline-put cr,0 at end of buffer and output entire buffer
                        1130* ;outbuff-put 0 at end of buffer and output entire buffer
                        1131* ;Enter A5 current io buffer pointer
                        1132* ;Exit  A5 start of io buffer
04AE  1AFC  000D        1133* outline move.b  #DSccr,(A5)+     ;put carriage return
04B2  1ABC  0000        1134* outbuff move.b  #0,(A5)         ;put zero in buffer
04B6  4BF9  0080  0D00  1135*         lea     iobuff.l,A5     ;point to start of buffer
04BC  6000  1BBA        1136*         bra     DSoutst         ;output it
                        1137* ;out hex--Subroutine to output hexbytes
                        1138* ;  Enter-D6 size to output0-nibble 1-byte 2-word 3-3bytes 4-longword
                        1139* ;        D0 hex value to be output
04C0  48E7  8204        1140* OutHex  movem.l A5/D0/D6,-(SP)     ;save registers
04C4  4BF9  0080  0D00  1141*         lea     iobuff.l,A5     ;point to iobuffer
04CA  1C3B  600E+       1142*         move.b  Hextbl(D6),D6   ;get offset from table below
04CE  4EBB  600A+       1143*         jsr     Hextbl(D6)      ;execute routine
04D2  61DE              1144*         bsr.s   outbuff         ;display
04D4  4CDF  2041        1145*         movem.l (SP)+,A5/D6/D0  ;restore registers
04D8  4E75              1146*         RTS
04DA  26                1147* Hextbl  data.b  put1hx-hextbl
04DB  1A                1148*         data.b  put2hx-hextbl
04DC  14                1149*         data.b  put4hx-hextbl
04DD  0E                1150*         data.b  put6hx-hextbl
04DE  06                1151*         data.b  put8hx-hextbl
                        1152* ;Routines to put hex bytes into the iobuff
                        1153* ;Enter D0 - hexadecimal to be printed
                        1154* ;      A5 - current io buffer pointer
04E0  4840              1155* put8hx  swap    d0              ;flip reg halves
04E2  610A              1156*         bsr.s   put4hx          ;do top word
04E4  4840              1157*         swap    d0              ;flip reg halves
04E6  6006              1158*         bra.s   put4hx          ;do bottom word
04E8  4840              1159* put6hx  swap    d0              ;flip reg halves
04EA  6108              1160*         bsr.s   put2hx          ;do top word
04EC  4840              1161*         swap    d0              ;flip reg halves
04EE  E058              1162* put4hx  ror.w   #8,d0           ;do upper nibble first
04F0  6102              1163*         bsr.s   put2hx          ;put byte into  buffer
04F2  E058              1164*         ror.w   #8,d0           ;do bottom nibble
04F4  2F07              1165* put2hx  move.l  d7,-(a7)
04F6  3E00              1166*         move.w  d0,d7           ;save d0 in d7 temporarily
04F8  E858              1167*         ror.w   #4,d0
04FA  6104              1168*         bsr.s   put1hx
04FC  3007              1169*         move.w  d7,d0           ;get back from d7
04FE  2E1F              1170*         move.l  (A7)+,D7
0500  0200  000F        1171* put1hx  andi.b  #$0f,d0         ;save lower nibble
0504  0000  0030        1172*         ori.b   #$30,d0         ;convert to ascii
0508  B03C  0039        1173*         cmp.b   #$39,d0         ;see if > '9'
050C  6F02              1174*         ble.s   puthx           ;no, put in buffer
050E  5E40              1175*         addq    #7,d0           ;make it a letter
0510  1AC0              1176* puthx   move.b  d0,(A5)+        ;put it in print buffer
0512  4E75              1177*         rts
File: C1.MAIN.TEXT                                                Page  29


                        1179* ;miscompare--output failing address data expected and data read
                        1180* ;       Enter:  A2 address of failure
                        1181* ;               D1 data read
                        1182* ;               D0 data expected
0514  48E7  8200        1183* MisCmp  movem.l D0/D6,-(SP)     ;save registers (d0 on top)
0518  4BFA  059A+       1184*         lea     msgmiscmp,A5    ;messg-miscompare @
051C  6100  1B5A        1185*         bsr     Dsoutst         ;*
0520  200A              1186*         move.l  A2,D0           ;get failing address
0522  7C03              1187*         moveq   #3,D6           ;parameter for #bytes on outhex
0524  6100  FF9A        1188*         bsr     outhex          ;output
0528  4CDF  0041        1189*         movem.l (SP)+,D0/D6     ;get data expected from top of stack
052C  2F00              1190* MCdata  move.l  D0,-(SP)        ;parameter for #bytes on outhex
052E  4BFA  05A1+       1191*         lea     msgDatex,A5     ;messg-data expected
0532  6100  1B44        1192*         bsr     Dsoutst         ;*
0536  6100  FF88        1193*         bsr     outhex          ;output from d0 above
053A  4BFA  0587+       1194*         lea     msgDatrd,A5     ;messg data read
053E  6100  1B38        1195*         bsr     Dsoutst         ;*
0542  2001              1196*         move.l  D1,D0           ;get data read
0544  6100  FF7A        1197*         bsr     outhex          ;output
0548  6100  1B4C        1198*         BSR     DSoutcr         ;carriage return
054C  201F              1199*         move.l  (SP)+,D0        ;registers restored.
054E  4E75              1200*         RTS
                        1201* ;miscompare--output failing address data expected and data read
                        1202* ;       Enter:  A2 address of failure
                        1203* ;               D1 data read
                        1204* ;               D0 data expected
0550  2F06              1205* MisCmpl move.l  D6,-(SP)        ;save current value of d6
0552  7C04              1206*         moveq   #4,D6           ;long word
0554  61BE              1207*         bsr.s   MisCmp          ;do it
0556  2C1F              1208*         move.l  (SP)+,D6        ;restore
0558  4E75              1209*         RTS                     ;return
055A  2F06              1210* MisCmpw move.l  D6,-(SP)        ;save current value of d6
055C  7C02              1211*         moveq   #2,D6           ;word
055E  61B4              1212*         bsr.s   MisCmp          ;do it
0560  2C1F              1213*         move.l  (SP)+,D6        ;restore
0562  4E75              1214*         RTS                     ;return
0564  2F06              1215* MisCmpb move.l  D6,-(SP)        ;save current value of d6
0566  7C01              1216*         moveq   #1,D6           ;byte
0568  61AA              1217*         bsr.s   MisCmp          ;do it
056A  2C1F              1218*         move.l  (SP)+,D6        ;restore
056C  4E75              1219*         RTS                     ;return
                        1220* ;
056E                    1221* Keypress
056E  48E7  8004        1222*         movem.l A5/D0,-(SP)     ;save um registers
0572  4BFA  299C+       1223*         lea     msgKeypress,A5  ;say '<press space to continue-escape to exit>'
0576  6100  1B00        1224*         bsr     Dsoutst
057A  6100  2110        1225*         bsr     KBgetch         ;wait for any key
057E  6100  1B16        1226*         bsr     DSoutCR         ;carriage return
0582  B03C  001B        1227*         cmp.b   #$1B,D0         ;an escape?
0586  4CDF  2001        1228*         movem.l (SP)+,A5/D0
058A  4E75              1229*         RTS
058C                    1230* Warn
058C  4BFA  2960+       1231*         lea     msgwarn,A5      ;say Results may not be valid
0590  6100  1AE6        1232*         bsr     Dsoutst
File: C1.MAIN.TEXT                                                Page  30


                        1233* ; ask user if he wishes to continue
                        1234* ; returns EQ if response was a y or Y
                        1235* ;         NE otherwise
0594  48E7  8004        1236* OPTcont movem.l A5/D0,-(SP)     ;save registers
0598  4BFA  0545+       1237*         lea     msgopt,A5       ;say option continue
059C  6100  1ADA        1238*         bsr     DSoutst
05A0  6100  20E4        1239*         bsr     KBgetUC
05A4  6100  1AF0        1240*         bsr     DSoutcr         ;carriage return
05A8  B03C  0059        1241*         cmp.b   #'Y',D0         ;is it a yes?
05AC  4CDF  2001        1242*         movem.l (SP)+,A5/D0     ;restore regs
05B0  4E75              1243*         RTS
                        1244* 
File: C1.MAIN.TEXT                                                Page  31


                        1246* ;outdot - output a dot subroutine
05B2  2F00              1247* outdot  move.l  D0,-(A7)        ;save reg
05B4  103C  002E        1248*         move.b  #'.',D0         ;output a period
05B8  6100  1AE8        1249*         bsr     DSoutch         ;*
05BC  201F              1250*         move.l  (A7)+,D0        ;restore reg.
05BE  4E75              1251*         RTS
                        1252* ;ExecTst - enter A6 as address of test- this routine turns both leds on through
                        1253* ;           the status register during testing and lights appropriately for
                        1254* ;           pass and fail.
                        1255* ;        - EXIT EQ&green led on is pass
                        1256* ;               NE&red led on is fail
                        1257* ;               A5 is trashed(stat reg)
05C0  4BF9  0084  0007  1258* ExecTst lea     StatReg.l,A5    ;get addres of status register
05C6  0215  003F        1259*         andi.b  #TestOn,(A5)    ;turn on both leds
05CA  4E96              1260*         jsr     (A6)            ;execute test
05CC  6606              1261*         bne.s   TstFail         ;failed
05CE  0015  0080        1262*         ori.b   #TestOk,(A5)    ;turn off red led
05D2  6004              1263*         bra.s   ExecEnd         ;exit routine
05D4  0015  0040        1264* TstFail ori.b   #TestBad,(A5)   ;turn off green led
05D8  0815  0006        1265* ExecEnd btst    #Grled,(A5)     ;sets eq if led on(bit6=0) or ne if off(bit6=1)
05DC  4E75              1266*         RTS
                        1267* ;          list off     ;in main
                        1268* ;
File: C1.MAIN.TEXT                                                Page  32


                        1270*         include 'SIV.CMD'
                        1271* ;
                        1272* ;Display memory  DM <start> <count> <increment>
                        1273* ;
05DE                    1274* Display ;pea     mainmenu         ;return here for bad parameters
05DE  6100  019A        1275*         bsr     getstrt         ;get start address in A2
05E2  6100  019E        1276*         bsr     GetCntU         ;get count in D5
05E6  E88D              1277*         lsr.l   #4,D5           ;get the number of rows to print(div 16)
05E8  6100  01B0        1278* DmpMem1 bsr     GetIncr         ;get incrementer in D3
05EC  4BF9  0080  0D00  1279* DmpMem2 lea     IObuff.l,A5      ;point to io buffer
05F2  200A              1280*         move.l  A2,D0           ;get current address
05F4  6100  FEF2        1281*         bsr     put6hx          ;put 6 hex characters into buffer
05F8  1AFC  0020        1282*         move.b  #DSCblnk,(A5)+  ;and a space
05FC  780F              1283*         moveq   #$F,D4          ;set count to display 16 hex characters
05FE  1AFC  0020        1284* DmpMem3 move.b  #DSCblnk,(A5)+  ;put a space in between hex bytes
0602  1012              1285*         move.b  (A2),D0         ;get value from memory
0604  6100  FEEE        1286*         bsr     put2hx          ;put 2 hex characters (1 byte) into buffer
0608  D5C3              1287*         adda.l  D3,A2           ;increment address
060A  51CC  FFF2        1288*         dbra    D4,Dmpmem3      ;loop
060E  6100  FE9E        1289*         bsr     outline         ;output 1 line from buffer
0612  51CD  FFD8        1290*         dbra    D5,Dmpmem2      ;loop until done
0616  4E75              1291*         RTS
                        1292* ;
                        1293* ;Display memory by words DW <start> <count> <increment>
                        1294* ;
0618  6100  0160        1295* Dmpword bsr     getstrt         ;get start address in A2
061C  6100  0164        1296*         bsr     GetCntU         ;get count in D5
0620  E68D              1297*         lsr.l   #3,D5           ;get the number of rows to print(div 8)
0622  6100  0176        1298* Dmpwrd1 bsr     GetIncr         ;get incrementer in D3
0626  6100  0146        1299*         bsr     Iword           ;make sure word size
062A  7C03              1300*         moveq   #3,D6           ;display 3 bytes
062C  200A              1301* Dmpwrd2 move.l  A2,D0           ;get current address
062E  6100  FE90        1302*         bsr     outhex          ;display hex characters
0632  6106              1303*         bsr.s   DmpLnW          ;dump a line of words
0634  51CD  FFF6        1304*         dbra    D5,Dmpwrd2      ;loop until done
0638  4E75              1305*         RTS
                        1306* ;
                        1307* ;Display one line of words
                        1308* ;       Enter - A2=pointer to memory being displayed
                        1309* ;               D3=incrementer
                        1310* ;
063A  48E7  8A00        1311* DmpLnW  movem.l D0/D4/D6,-(SP)  ;save registers
063E  7C02              1312*         moveq   #2,D6           ;display words
0640  7807              1313*         moveq   #7,D4          ;set count to display 8 hex words
0642  6100  1A46        1314*         bsr     DSoutSp
0646  6100  1A42        1315* DmpLnW1 bsr     DSoutSp         ;display a space
064A  3012              1316*         move.w  (A2),D0         ;get value from memory
064C  6100  FE72        1317*         bsr     outhex          ;put 4 hex characters (1 word) into buffer
0650  D5C3              1318*         adda.l  D3,A2           ;increment address
0652  51CC  FFF2        1319*         dbra    D4,DmpLnW1      ;loop
0656  6100  1A3E        1320*         bsr     DSoutCr         ;output 1 line from buffer
065A  4CDF  0051        1321*         movem.l (SP)+,D0/D4/D6  ;restore
065E  4E75              1322*         RTS                     ;return
                        1323* ;
File: C1.MAIN.TEXT                                                Page  33


                        1324* ;Fill memory by bytes FB <start> <count> <data> <increment>
                        1325* ;
0660                    1326* Fillbyt
0660  6100  0102        1327*         bsr     getscdi         ;get all of the above (same regs)
0664  1482              1328* Fllbyt2 move.b  D2,(A2)         ;write to mem
0666  D5C3              1329*         adda.l  D3,A2           ;increment address
0668  51CD  FFFA        1330*         dbra    D5,Fllbyt2      ;loop until done
066C  51CE  FFF6        1331*         dbra    D6,Fllbyt2      ;loop until done
0670  4E75              1332*         RTS
                        1333* ;
                        1334* ;Fill memory by words FW <start> <count> <data> <increment>
                        1335* ;
0672  6100  00F8        1336* FillWrd bsr     GtSCDIW        ;get start count data and inc as Fillbyt does
0676  3482              1337* FMW2    move.w  D2,(A2)         ;write to mem
0678  D5C3              1338*         adda.l  D3,A2           ;increment address
067A  51CD  FFFA        1339*         dbra    D5,FMw2         ;loop until done
067E  51CE  FFF6        1340*         dbra    D6,FMw2         ;loop until done
0682  4E75              1341*         RTS
                        1342* ;
                        1343* ;Fill memory on user parameters(word size)
                        1344* ;       EXIT    A2.L: start address
                        1345* ;               D5.W: count(1st 64K)
                        1346* ;               D6.W: count(number of 64K counts)
                        1347* ;               D2.W: initial data
                        1348* ;               D3.L: increment
                        1349* ;
0684  6100  00E6        1350* FillInc bsr     GtSCDIW        ;get start count data and increment as fillbyt
                        1351* ;
                        1352* ;Fill memory with incrementing<word> data
                        1353* ;       FI <start> <count> <data> <address increment>
                        1354* ;       ENTER   A2.L: start address
                        1355* ;               D5.W: count(1st 64K)
                        1356* ;               D6.W: count(number of 64K counts)
                        1357* ;               D2.W: initial data
                        1358* ;               D3.L: increment
                        1359* ;
0688  48E7  2620        1360* FIWord  movem.l D2/D5-D6/A2,-(SP)
068C  3482              1361* FIWordl move.w  D2,(A2)         ;write to mem
068E  5242              1362*         addq.w  #1,D2           ;increment data
0690  D5C3              1363*         adda.l  D3,A2           ;increment address
0692  51CD  FFF8        1364*         dbra    D5,FIWordl      ;loop until done
0696  51CE  FFF4        1365*         dbra    D6,FIWordl      ;loop until done
069A  4CDF  0464        1366*         movem.l (SP)+,D2/D5-D6/A2
069E  4E75              1367*         RTS
                        1368* ;
                        1369* ;Fill memory with incrementing<word> data
                        1370* ;       FI <start> <count> <data> <address increment>
                        1371* ;
06A0  6100  00C2        1372* FllIncB bsr     getscdi         ;get start count data and inc as fillbyt
06A4  1482              1373* FIB2    move.b  D2,(A2)         ;write to mem
06A6  5202              1374*         addq.b  #1,D2           ;increment data
06A8  D5C3              1375*         adda.l  D3,A2           ;increment address
06AA  51CD  FFF8        1376*         dbra    D5,FIB2         ;loop until done
06AE  51CE  FFF4        1377*         dbra    D6,FIB2         ;loop until done
File: C1.MAIN.TEXT                                                Page  34


06B2  4E75              1378*         RTS
                        1379* ;
                        1380* ;Compare memory by bytes CB <start> <count> <data> <increment>
                        1381* ;
06B4  6100  00AE        1382* Cmpbyt  bsr     getscdi         ;get start count data and increment as fillbyt
06B8  1002              1383*         move.b  D2,D0           ;use d0 for data expected
06BA  1212              1384* CmpMem2 move.b  (A2),D1         ;read
06BC  B001              1385*         cmp.b   D1,D0           ;Compare memory and data
06BE  670A              1386*         beq.s   CmpMem3         ;equal-continue
06C0  6100  FEA2        1387*         bsr     miscmpb         ;d0 is data expected
06C4  6100  FECE        1388*         bsr     OptCont         ;give user option to continue
06C8  660A              1389*         bne.s   CmpMemE         ;no, exit
06CA  D5C3              1390* CmpMem3 adda.l  D3,A2           ;increment address
06CC  51CD  FFEC        1391*         dbra    D5,CmpMem2      ;loop until done
06D0  51CE  FFE8        1392*         dbra    D6,CmpMem2      ;loop until done
06D4  4E75              1393* CmpMemE RTS
                        1394* ;
                        1395* ;Compare memory by words CW <start> <count> <data> <increment>
                        1396* ;
06D6  6100  0094        1397* CmpWrd  bsr     GtSCDIW        ;get start count data and increment as fillbyt
06DA  3002              1398*         move.w  D2,D0           ;data expected
06DC  3212              1399* CmpWrd2 move.w  (A2),D1         ;read
06DE  B041              1400*         cmp.w   D1,D0           ;Compare memory and data
06E0  67E8              1401*         beq.s   CmpMem3         ;equal-continue
06E2  6100  FE76        1402*         bsr     MisCmpW        ;report data errs
06E6  6100  FEAC        1403*         bsr     OptCont         ;give user option to continue
06EA  660A              1404*         bne.s   CmpWrdE         ;no, exit
06EC  D5C3              1405* CmpWrd3 adda.l  D3,A2           ;increment address
06EE  51CD  FFEC        1406*         dbra    D5,CmpWrd2      ;loop until done
06F2  51CE  FFE8        1407*         dbra    D6,CmpWrd2      ;loop until done
06F6  4E75              1408* CmpWrdE RTS
                        1409* ;
                        1410* ;Compare memory by bytes CB <start> <count> <data> <increment>
                        1411* ;     incrementing data
06F8  6100  006A        1412* CmpIbyt bsr     getscdi         ;get start count data and increment as fillbyt
06FC  1002              1413*         move.b  D2,D0           ;use d0 for data expected
06FE  1212              1414* CmpIb2  move.b  (A2),D1         ;read
0700  B001              1415*         cmp.b   D1,D0           ;Compare memory and data
0702  670A              1416*         beq.s   CmpIb3          ;equal-continue
0704  6100  FE5E        1417*         bsr     miscmpb         ;d0 is data expected
0708  6100  FE8A        1418*         bsr     OptCont         ;give user option to continue
070C  660C              1419*         bne.s   CmpIBex         ;no, exit
070E  D5C3              1420* CmpIB3  adda.l  D3,A2           ;increment address
0710  5240              1421*         addq    #1,D0
0712  51CD  FFEA        1422*         dbra    D5,CmpIB2       ;loop until done
0716  51CE  FFE6        1423*         dbra    D6,CmpIB2       ;loop until done
071A  4E75              1424* CmpIBex RTS
                        1425* ;
                        1426* ;Compare memory by words CW <start> <count> <data> <increment>
                        1427* ;       incrementing data
071C  6100  004E        1428* CmpIwrd bsr     GtSCDIW        ;get start count data and increment as fillbyt
0720  3002              1429*         move.w  D2,D0           ;data expected
0722  3212              1430* CmpIW2  move.w  (A2),D1         ;read
0724  B041              1431*         cmp.w   D1,D0           ;Compare memory and data
File: C1.MAIN.TEXT                                                Page  35


0726  670A              1432*         beq.s   CmpIW3          ;equal-continue
0728  6100  FE30        1433*         bsr     MisCmpW        ;report data errs
072C  6100  FE66        1434*         bsr     OptCont         ;give user option to continue
0730  660C              1435*         bne.s   CmpIWex         ;no, exit
0732  D5C3              1436* CmpIW3  adda.l  D3,A2           ;increment address
0734  5240              1437*         addq    #1,D0
0736  51CD  FFEA        1438*         dbra    D5,CmpIW2       ;loop until done
073A  51CE  FFE6        1439*         dbra    D6,CmpIW2       ;loop until done
073E  4E75              1440* CmpIWex RTS
                        1441* ;
                        1442* ;Move memory  MM <source> <destination> <count>
                        1443* ; moves data from source location to destination until count expired
                        1444* ; note: destination range cannot include unmoved source data--
                        1445* ; If s<d then s+c<d else overlap error
                        1446* ;
0740                    1447* MoveMem ;pea     mainmenu         ;return here for bad parameters
0740  6100  0038        1448*         bsr     getstrt         ;get start address in A2
0744  6100  FCFA        1449*         bsr     getpara         ;get destination address in d0
0748  2840              1450*         movea.l D0,A4           ;use a4 as pointer
074A  6100  0036        1451*         bsr     GetCntU         ;get count in D5 and d6
074E  B9CA              1452* MovMem1 cmpa.l  A2,A4           ;is destination>=source?
0750  6B06              1453*         bmi.s   MovMem2         ;no, continue
0752  D08A              1454*         add.l   A2,D0           ;add count and source
0754  B9C0              1455*         cmpa.l  D0,A4           ;is Destination>=source+count?
0756  6B4E              1456*         bmi.s   Overlap         ;no, destination will overwrite unmoved source.
                        1457* 
0758  18DA              1458* MovMem2 move.b  (A2)+,(A4)+     ;move data
075A  51CD  FFFC        1459*         dbra    D5,MovMem2      ;loop until done
075E  51CE  FFF8        1460*         dbra    D6,MovMem2      ;loop until done
0762  4E75              1461* MovMemE RTS
                        1462* ;
                        1463* ; Get start count data and increment
                        1464* ;       EXIT    A2.L: start address
                        1465* ;               D5.W: count(1st 64K)
                        1466* ;               D6.W: count(number of 64K counts)
                        1467* ;               D2.W: initial data
                        1468* ;               D3.W: increment
                        1469* ;
0764  6114              1470* GetSCDI bsr.s   getstrt
0766  611A              1471*         bsr.s   GetCntU
0768  6128              1472*         bsr.s   getdata
076A  602E              1473*         bra.s   getincr
                        1474* ;
076C  61F6              1475* GtSCDIW bsr.s   getscdi
076E  B6BC  0000  0001  1476* Iword   cmp.l   #1,D3           ;is it a one?
0774  6602              1477*         bne.s   GETIwxt         ;no, branch
0776  7602              1478*         moveq   #2,D3           ;yes make it a two
0778  4E75              1479* GetIWxt RTS
                        1480* ;
                        1481* ;Get starting address
                        1482* ;       EXIT    D0.L - start address
                        1483* ;               A2.L -   "      "
                        1484* ;
077A  6100  FCC4        1485* GetStrt bsr     getpara         ;get start address in d0
File: C1.MAIN.TEXT                                                Page  36


077E  2440              1486*         movea.l D0,A2           ;use A2 as pointer
0780  4E75              1487*         RTS
                        1488* ;
                        1489* ;GetCntU-Get hex count from user's ascii input
                        1490* ;GetCntD-Get count from register d0.l
                        1491* ;and return values in d5&d6 (for dbra loops)
                        1492* ;       EXIT    D0.L : hex conversion of input from user
                        1493* ;               D5.L : input from user - 1 for dbra loop
                        1494* ;               D6.L : upper half of input from user (for outside dbra loops)
                        1495* ;
0782  6100  FCBC        1496* GetCntU bsr     GetPara         ;get end or count
0786  2A00              1497* GetCntD move.l  D0,D5           ;save count in d5
0788  6706              1498*         beq.s   GetCntE         ;branch if zero
078A  5385              1499*         subq.l  #1,D5           ;decrement by 1
078C  2C05              1500*         move.l  D5,D6
078E  4846              1501*         swap    D6
0790  4E75              1502* GetcntE RTS
                        1503* ;
                        1504* ;Get a data value from user
                        1505* ;       EXIT    D0.L : value from user
                        1506* ;               D2.L : value from user
                        1507* ;
0792  6100  FCAC        1508* GetData bsr     GetPara         ;get data
0796  2400              1509*         move.l  D0,D2           ;put in d2
0798  4E75              1510*         RTS
                        1511* ;
                        1512* ;Get address incrementer from user and store in D3
                        1513* ; Ensure non-zero.
079A  6100  FCA4        1514* GetIncr bsr     GetPara         ;get incrementer
079E  2600              1515*         move.l  D0,D3           ;put in D3
07A0  6602              1516*         bne.s   GetIncE         ;branch if not zero
07A2  7601              1517*         moveq   #1,D3
07A4  4E75              1518* GetIncE RTS
                        1519* ;
                        1520* ;
07A6  4BFA  0357+       1521* Overlap lea     msgolap,A5      ;say Destination<>unmoved source
07AA  6000  18CC        1522*         bra     DSoutst         ;*
                        1523* 
                        1524* ;
07AE  48E7  8200        1525* CMaddr  movem.l D0/D6,-(SP)        ;save register
07B2  200A              1526*         move.l  A2,D0
07B4  7C03              1527*         moveq   #3,D6           ;d6 is parameter for #bytes on hexout
07B6  6100  FD08        1528*         bsr     outhex          ;output hex
07BA  4CDF  0041        1529*         movem.l  (SP)+,D0/D6     ;restore registerr
07BE  4E75              1530*         RTS
                        1531* ;
07C0  48E7  8200        1532* CMbyte  movem.l D0/D6,-(SP)        ;save register
07C4  1012              1533*         move.b  (A2),D0
07C6  7C01              1534*         moveq   #1,D6           ;d6 is parameter for #bytes on hexout
07C8  6100  FCF6        1535*         bsr     outhex          ;output hex
07CC  4CDF  0041        1536*         movem.l  (SP)+,D0/D6     ;restore registerr
07D0  4E75              1537*         RTS
                        1538* ;
                        1539* ;Change (Alter) memory  AM <start> <increment>
File: C1.MAIN.TEXT                                                Page  37


                        1540* ;
07D2                    1541* ChngMem
07D2  6100  FFA6        1542*         bsr     getStrt         ;get start address in A2
07D6  6100  FFC2        1543*         bsr     GetIncr         ;get incrementer in D3
07DA  6006              1544*         bra.s   NxtAdd1         ;skip ahead first time
07DC  95C3              1545* PrvAddr suba.l  D3,A2           ;decrement address
07DE  6002              1546*         bra.s   NxtAdd1
07E0  D5C3              1547* NxtAddr adda.l  D3,A2           ;increment address
07E2  6100  18B2        1548* NxtAdd1 bsr     DSoutCR
07E6  6100  FFC6        1549*         bsr     CMaddr          ;display address value of A2
07EA  4205              1550*         clr.b   D5              ;use d5 for counting bytes in same row
07EC  6002              1551*         bra.s   NxtByt1         ;do not reset iobuffer
07EE                    1552* NxtByte
07EE  D5C3              1553*         adda.l  D3,A2           ;increment address
07F0  6100  1898        1554* NxtByt1 bsr     DSOutsp         ;output a space
07F4  61CA              1555*         bsr.s   CMbyte          ;display a byte
07F6  4BF9  0080  0D00  1556*         lea     iobuff.l,A5     ;get buffer
07FC  4295              1557*         clr.l   (A5)            ;zero part of buffer
07FE  4287              1558*         clr.l   D7              ;use d7 as counter
0800  08F9  0002  0080  1559* CMinlp  bset    #Echobit,SysFlag.l;don't echo character
0806  0D64  
0808  6100  1E7C        1560*         bsr     KBgetUC         ;read in a character
080C  08B9  0002  0080  1561*         bclr    #Echobit,Sysflag.l;turn off before any possible exceptionram
0812  0D64  
0814  5207              1562*         addq.b  #1,D7           ;increment character counter
0816  BE3C  0001        1563*         cmp.b   #1,D7           ;is it first char?
081A  670C              1564*         beq.s   ChgMem1         ;yes branch
081C  B03C  007F        1565*         cmp.b   #DSCdel,D0       ;is it a backspace
0820  6768              1566*         beq.s   CMdelCH          ;yes process it
0822  B03C  0008        1567*         cmp.b   #DSCbs,D0       ;is it a backspace
0826  6766              1568*         beq.s   CMbsCH          ;yes process it
0828  BE3C  0002        1569* ChgMem1 cmp.b   #2,D7           ;is it 2nd char
082C  672C              1570*         beq.s   ChkHex          ;yes check for hex char
082E  B03C  0053        1571*         cmp.b   #'S',D0         ;same address
0832  6700  0068        1572*         beq     CMsamCH         ;
0836  B03C  002E        1573*         cmp.b   #'.',D0         ;end on period
083A  6700  00AA        1574*         beq     CMendCH         ;
083E  B03C  002D        1575*         cmp.b   #'-',D0         ;is it a minus
0842  6768              1576*         beq.s   CMprvCH         ;go to previous location
0844  B03C  0020        1577*         cmp.b   #DSCblnk,D0     ;is it a space?
0848  6772              1578*         beq.s   CMblaCH
084A  B03C  000A        1579*         cmp.b   #DSClf,D0
084E  6604              1580*         bne.s   ChgMem2
0850  103C  000D        1581*         move.b  #dscCR,D0       ;make it a cr
0854  B03C  000D        1582* ChgMem2 cmp.b   #DSCcr,D0       ;is it a cr
0858  677E              1583*         beq.s   CMcrCH
                        1584* ;
                        1585* ; ChkHex
                        1586* ; If we get here save and display valid hexadecimal ascii characters
                        1587* ; and beep otherwise.
                        1588* ;
085A                    1589* ChkHex
085A  BE3C  0003        1590*         cmp.b   #3,D7
085E  6718              1591*         beq.s   Chexbad         ;no hex on  third character
File: C1.MAIN.TEXT                                                Page  38


0860  B03C  0030        1592*         cmp.b   #'0',D0         ;verify hex
0864  6D12              1593*         blt.s   chexbad
0866  B03C  0039        1594*         cmp.b   #'9',D0
086A  6F14              1595*         ble.s   ChexOK
086C  B03C  0041        1596*         cmp.b   #'A',D0
0870  6D06              1597*         blt.s   Chexbad
0872  B03C  0046        1598*         cmp.b   #'F',D0
0876  6F08              1599*         ble.s   ChexOK
0878  5347              1600* ChexBad subq    #1,D7
087A  103C  0007        1601* Termbp    move.b  #7,D0           ;output a beep
087E  6002              1602*         bra.s   CHexit
0880  1AC0              1603* ChexOK  move.b  D0,(A5)+
0882  6100  181E        1604* CHexit  bsr     DSoutch         ;*
0886  6000  FF78        1605*         bra     CMinlp
                        1606* ;delete/rubout character
088A  103C  0008        1607* CMdelch move.b  #DSCbs,D0       ;treat like a backspace
                        1608* ;backspace
088E  5547              1609* CMbsCh  subq    #2,D7           ;adjust character counter
0890  6100  1810        1610*         bsr     DSoutch         ;display character
0894  6100  FB50        1611*         bsr     Backsp          ;backspace handler
0898  6000  FF66        1612*         bra     CMinlp          ;loopchar again
                        1613* ;Same address
089C  BE3C  0003        1614* CMsamCH cmp.b   #3,D7           ;is it 3rd char?
08A0  6602              1615*         bne.s   CMsc1           ;no, branch
08A2  6156              1616*         bsr.s   HexToA2         ;save hex from iobuff into (A2)
08A4  6100  17FC        1617* CMsc1   bsr     DSoutch         ;show 'S'
08A8  6000  FF38        1618*         bra     NxtAdd1         ;show same address
                        1619* ;
                        1620* ;minus sign
08AC  BE3C  0003        1621* CMprvCH cmp.b   #3,D7           ;is it 3rd char?
08B0  6602              1622*         bne.s   CMpc1           ;no, branch
08B2  6146              1623*         bsr.s   HexToA2         ;save hex from iobuff into (A2)
08B4  6100  17EC        1624* CMpc1   bsr     DSoutch         ;show '-'
08B8  6000  FF22        1625*         bra     PrvAddr         ;get previous address
                        1626* ;
08BC  5205              1627* CMblaCh addq.b  #1,D5
08BE  BE3C  0003        1628*         cmp.b   #3,D7           ;is it 3rd chr?
08C2  6604              1629*         bne.s   CMbla1          ;no, branch
08C4  6134              1630*         bsr.s   HexToA2         ;
08C6  6004              1631*         bra.s   CMbla2
08C8  6100  FEF6        1632* CMbla1  bsr     CMbyte
08CC  BA3C  0008        1633* CMbla2  cmp.b   #8,D5           ;have we displayed 8 in a row?
08D0  6A00  FF0E        1634*         bpl     NxtAddr         ;greater than-diplay address
08D4  6000  FF18        1635*         bra     NxtByte         ;go on
                        1636* ;
08D8  BE3C  0003        1637* CMcrCH  cmp.b   #3,D7           ;is it 3rd char?
08DC  6604              1638*         bne.s   CMcr1           ;no, branch
08DE  6100  001A        1639*         bsr     HexToA2         ;save hex from iobuff into (A2)
08E2  6000  FEFC        1640* CMcr1   bra     NxtAddr         ;loop
                        1641* ;
08E6  BE3C  0003        1642* CMendCh cmp.b   #3,D7           ;is it 3rd char?
08EA  6604              1643*         bne.s   CMec1           ;no, branch
08EC  6100  000C        1644*         bsr     HexToA2         ;save hex from iobuff into (A2)
08F0  6100  17B0        1645* CMec1   bsr     DSoutch         ;show it
File: C1.MAIN.TEXT                                                Page  39


08F4  6100  17A0        1646*         bsr     DSoutCR         ;display a cr
08F8                    1647* ChgMemE;tst.l   (SP)+           ;readjust stack
08F8  4E75              1648*         RTS
                        1649* ;
                        1650* ;HexToA2-convert data at beginning of IObuffer to hexadecimal
                        1651* ;       and put into memory pointed to by A2
                        1652* ;
08FA  48E7  8004        1653* HexToA2 movem.l D0/A5,-(SP)
08FE  4BF9  0080  0D00  1654*         lea     iobuff.l,A5      ;get buffer
0904  6100  FB3A        1655*         bsr     GetPara          ;convert ascii to binary
0908  1480              1656*         move.b  D0,(A2)         ;write it
090A  4CDF  2001        1657*         movem.l (SP)+,A5/D0
090E  4E75              1658*         RTS
File: C1.MAIN.TEXT                                                Page  40


                        1660* ;Memsize--Routine to determine memory size and ram type
                        1661* ;       writes 0001 to 0FFFFE, 0002 to 1FFFFE, 0003 to 2FFFFE, 0004 to 3FFFFE
                        1662* ;       and then reads back from 3FFFFE
0910  263C  0010  0000  1663* Memsize move.l  #onemeg,D3      ;incrementer
0916  41F9  000F  FFFE  1664*         lea     onemeg-2.l,A0   ;start at ffffe
091C  7001              1665*         moveq   #1,D0           ;start writing a 1
091E  3080              1666* Memsz1  move.w  D0,(A0)         ;write to memory
0920  B07C  0004        1667*         cmp.w   #4,D0           ;have we finished?
0924  670E              1668*         beq.s   Memsz1a         ;yes, branch
0926  5240              1669*         addq    #1,D0           ;increment bank pair counter
0928  D1C3              1670*         adda.l  D3,A0           ;increment address
092A  60F2              1671*         bra.s   Memsz1          ;continue
                        1672* ;report size error
092C  4BFA  266A+       1673* SizErr  lea     msgSizErr,A5    ;let the user know size error
0930  6000  1746        1674*         bra     DSoutst         ;*
                        1675* ;now we start checking from 3FFFFE-- if it is a 4 it is either 4meg 256kram
                        1676* ;or 1 meg 64kram
0934  B050              1677* Memsz1a cmp     (A0),D0         ;compare - last write
0936  670E              1678*         beq.s   Chk64k          ;definitely not 64ks if ne so branch
                        1679* ;at this point we know we are 256k rams and less than four meg
                        1680* ;if ram is good then the first equal on compare will give us the size
0938  91C3              1681* Memsz2  suba.l  D3,A0      ;decrement address
093A  5340              1682* Memsz2a subq    #1,D0           ;decremnt counter
093C  67EE              1683*         beq.s   SizErr          ;size error
093E  B050              1684*         cmp     (A0),D0         ;read mem
0940  66F6              1685*         bne.s   Memsz2       ;loop until eq
0942  613C              1686*         bsr.s   Sav256k
0944  6014              1687*         bra.s   Stat256         ;display status and return
                        1688* ; check to see if memory is 8 bank 1 meg (64k rams)
0946  91C3              1689* Chk64k  suba.l  D3,A0           ;decrement address
0948  B050              1690*         cmp.w   (A0),D0         ;if it is 64krams then still a 4
094A  6634              1691*         bne.s   Sav256k         ;
094C  4BFA  260C+       1692* Stat64k lea     msg64k,A5       ;say 64k
0950  600C              1693*         bra.s   DspStat         ;*
0952  4A39  0080  0D65  1694* MemStat tst.b   Memsz.l
0958  6BF2              1695*         bmi.s   Stat64k
095A  4BFA  2602+       1696* Stat256 lea     msg256k,A5      ;say 256k
095E  6100  1718        1697* DspStat bsr     dsoutst
0962  4BFA  25FF+       1698*         lea     msgRamtype,A5
0966  6100  1710        1699*         bsr     DSoutst         ;say it
096A  3039  0080  0D66  1700*         move.w  Curmem.l,D0      ;get size/10000
0970  E840              1701*         asr.w   #4,D0           ;
0972  7C00              1702*         moveq   #0,D6           ;output 1 hex char
0974  6100  FB4A        1703*         bsr     outhex          ;*
0978  4BFA  25F4+       1704*         lea     msgcapacity,A5  ;let the user know what we found
097C  6000  16FA        1705*         bra     DSoutst         ;*
                        1706* ;save 256k type ram info  enter d0 1-4
0980  43F9  0080  0D65  1707* Sav256k lea     Memsz.l,A1
0986  1280              1708*         move.b  D0,(A1)         ;save #banks div2
0988  223C  0000  0014  1709*         move.l  #20,D1          ;num of bits to shift
098E  E3A0              1710*         asl.l   D1,D0           ;make it actual size
0990  2340  0001        1711*         move.l  D0,1(A1)        ;save number of bytes
0994  4E75              1712*         RTS
                        1713* ;
File: C1.MAIN.TEXT                                                Page  41


0996  13FC  0084  0080  1714* Save64k move.b  #$84,MemSz.l
099C  0D65  
099E  23FC  0010  0000  1715*         move.l  #onemeg,Curmem.l
09A4  0080  0D66  
09A8  4E75              1716*         RTS
09AA  4BFA  017F+       1717* NMagain lea     msgReenter,A5
09AE  6008              1718*         bra.s   NM2
09B0  6100  16E4        1719* NewMem  bsr     DSoutcr
09B4  4BFA  25B8+       1720*         lea     Msgcapacity,A5      ;Enter capacitiy in megabytes:
09B8  6100  16BE        1721* NM2     bsr     DSoutSt         ;*
09BC  7000              1722*         moveq   #0,D0
09BE  6100  1CC6        1723*         bsr     KBgetUC         ;read ascii
09C2  903C  0030        1724*         sub.b   #'0',D0         ;make binary
09C6  6BE2              1725*         bmi.s   NMagain         ;negative reenter input
09C8  B03C  0001        1726*         cmp.b   #1,D0           ;is it one megabyte?
09CC  6708              1727*         beq.s   Ask64k          ;check for 64k rams
09CE  B03C  0004        1728*         cmp.b   #4,D0           ;is it an Illegal number?
09D2  6ED6              1729*         bgt.s   NMagain         ;yes re-enter input
09D4  60AA              1730*         bra.s   Sav256k         ;save
09D6  4BFA  25AA+       1731* Ask64k  lea     msgask64k,A5       ;are the rams 64K?
09DA  6100  169C        1732*         bsr     DSoutst
09DE  6100  1CA6        1733*         bsr     KBgetUC         ;read
09E2  B03C  004E        1734*         cmp.b   #'N',D0         ;get  user response.
09E6  66AE              1735*         bne.s   Save64k         ;if yes save proper params
09E8  7001              1736*         moveq   #1,D0           ;1 256k rams
09EA  6000  FF94        1737*         bra     Sav256k
                        1738* ;
                        1739* ;Set altmap to one and turnoff boot mode
                        1740* ;
09EE                    1741* SetAlt1
09EE  13FC  000B  0084  1742* AltSw1  move.b  #firstcom,StatReg.l;turn bootmode off
09F4  0007  
09F6  4BFA  2555+       1743*         lea     msgAlt1,A5
09FA  6000  167C        1744*         bra     DSoutst
                        1745* ;
                        1746* ;set altmap to zero and turn on bootmode
                        1747* ;
09FE                    1748* SetAlt0
09FE  13FC  000A  0084  1749* AltSw0  move.b  #seconcom,StatReg.l;turn bootmode off
0A04  0007  
0A06  4BFA  253E+       1750*         lea     msgAlt0,A5
0A0A  6000  166C        1751*         bra     DSoutst
                        1752* ;
0A0E  6114              1753* SETcr   bsr.s   showcr
0A10  6100  F9E8        1754*         bsr     input
0A14  0C15  0030        1755*         cmpi.b   #'0',(A5)
0A18  6B26              1756*         bmi.s   SCRexit
0A1A  6100  FA24        1757*         bsr     getpara
0A1E  13C0  0084  0003  1758*         move.b  D0,CtxReg.l
0A24                    1759* ShowCr
0A24  48E7  8204        1760*         movem.l A5/D0/D6,-(SP)     ;save um registers
0A28  4BFA  24B6+       1761*         lea     msgctxreg,A5  ;say 'context register'
0A2C  6100  164A        1762*         bsr     Dsoutst
0A30  1039  0084  0003  1763*         move.b  CtxReg.l,D0     ;get value
File: C1.MAIN.TEXT                                                Page  42


0A36  7C01              1764*         moveq   #1,D6           ;output 1 byte
0A38  6100  FA86        1765*         bsr     outhex
0A3C  4CDF  2041        1766*         movem.l (SP)+,A5/D0/D6
0A40  4E75              1767* SCRexit RTS
                        1768* ;
                        1769* ;view and/or clear error register
                        1770* ;
0A42                    1771* SetER
0A42  4BFA  2490+       1772*         lea     msgerrreg,A5     ;msg-err reg
0A46  6100  1630        1773*         bsr     DSoutst         ;display it
0A4A  1039  0084  0005  1774*         move.b  ErrReg.l,D0     ;get value
0A50  7C01              1775*         moveq   #1,D6           ;out put 1 hex byte
0A52  6100  FA6C        1776*         bsr     outhex          ;*
0A56  B03C  0000        1777*         cmp.b   #0,D0           ;WAS it a zero
0A5A  6718              1778*         beq.s   SetERxt         ;exit
0A5C  4BFA  0092+       1779* ClrER   lea     msgclear,A5     ;ask to clear it
0A60  6100  1616        1780*         bsr     DSoutSt         ;*
0A64  6100  1C20        1781*         bsr     KBgetUC         ;get user input
0A68  0C00  0059        1782*         cmpi.b  #'Y',D0         ;is it a yes?
0A6C  6606              1783*         bne.s   SetErxt         ;no,exit
0A6E  13C0  0084  0005  1784*         move.b  D0,ErrReg.l     ;any write is a clear
0A74                    1785* SetERxt
0A74  4E75              1786*         RTS
                        1787* ;
                        1788* ;
                        1789* ;view and/or set status register
                        1790* ;
0A76  48E7  8220        1791* SetSR   movem.l A2/D0/D6,-(SP)  ;save registers
0A7A  4BFA  244B+       1792*         lea     msgStatReg,A5     ;message-status register
0A7E  6100  15F8        1793*         bsr     DSoutst         ;display it
0A82  45F9  0084  0007  1794*         lea     StatReg.l,A2    ;get address
0A88  1012              1795*         move.b  (A2),D0         ;read it
0A8A  7C01              1796*         moveq   #1,D6           ;out put 1 hex byte
0A8C  6100  FA32        1797*         bsr     outhex          ;*
0A90  6100  F968        1798*         bsr     input
0A94  0C15  0030        1799*         cmpi.b   #'0',(A5)
0A98  6B06              1800*         bmi.s   SetSRxt
0A9A  6100  F9A4        1801*         bsr     getpara         ;get hex
0A9E  1480              1802*         move.b  D0,(A2)         ;save
0AA0  4CDF  0441        1803* SetSRxt movem.l (SP)+,A2/D0/D6  ;restore
0AA4  4E75              1804*         RTS
0AA6  4DFA  F848+       1805* GoCmd   lea     Dragon,A6
0AAA  6100  F994        1806*         bsr     GetPara
0AAE  6702              1807*         beq.s   GoDoIt
0AB0  2C40              1808*         movea.l D0,A6
0AB2  4ED6              1809* GoDoIt  jmp     (A6)
                        1810* ;
0AB4  0D 4D6973636F6D70 1811* msgmiscmp data.b  DSCcr,'Miscompare @ ',0
0ABC  61726520402000 
0AC3  0D 44617461207265 1812* msgDatrd  data.b  DSCcr,'Data read = ',0
0ACB  6164203D2000 
0AD1  0D 44617461206578 1813* msgDatex  data.b  DSCcr,'Data exp. = ',0
0AD9  702E203D2000 
0ADF  436F6E74696E7565  1814* msgOpt    data.b  'Continue? (Y/N) ',0
File: C1.MAIN.TEXT                                                Page  43


0AE7  3F2028592F4E2920
0AEF  00 
0AF0  0D 436C6561723F20 1815* msgClear  data.b  DSCcr,'Clear? (Y/N) ',0
0AF8  28592F4E292000 
0AFF  44657374696E6174  1816* msgolap   data.b  'Destination cannot include unmoved source.',DSCcr,0
0B07  696F6E2063616E6E
0B0F  6F7420696E636C75
0B17  646520756E6D6F76
0B1F  656420736F757263
0B27  652E0D 00 
0B2B  0D 52652D656E7465 1817* msgReenter data.b  DSCcr,'Re-enter ',0
0B33  722000 
0B36                    1818* labelxxx
File: C1.MAIN.TEXT                                                Page  44


                        1820*         include 'SIV.MAP'
                        1821* ;FILE :
                        1822* ;Subroutines
                        1823* ;1.MapTran
                        1824* ;2.MapSegs
                        1825* ;3.MapPages
                        1826* ;4.DmpSeg
                        1827* ;5.DmpMap
                        1828* ;6.DmpPag
                        1829* ;7.MtstAll
                        1830* ;8.SegTest
                        1831* ;9.SWTest
                        1832* ;10.SMtest
                        1833* ;11.PagTest
                        1834* ;12.PWTest
                        1835* ;13.PMtest
                        1836* ;equates for mapping memory transparently
                        1837* ;
                        1838* ;  Data format for context register is as follows
                        1839* ; bit
                        1840* ;  7    allow map access
                        1841* ;  6    select low map
                        1842* ;  5    select segment map
                        1843* ;  4    select user mode
                        1844* ; 0-3   context # (0-15)
                        1845* ;
                        1846* ;CtxReg  equ     $840003         ;defined in merc.exc
                        1847* ;SegOfst equ     $10000          ;loww address of segments is xa16
                        1848* ;PagOfst equ     $1000           ;low address of pages is xa12
                        1849* ;AMAbit  equ     7               ;allow map access bit
                        1850* ;SLMbit  equ     6               ;select high map bit
                        1851* ;SUMbit  equ     4               ;select user mode bit
                        1852* ;SegBit  equ     5               ;select segment map bit
      000000E0          1853* SMSupLo equ     $E0             ;CXreg Data to select Segment supervisor low map
      000000A0          1854* SMSupHi equ     $A0             ;CXreg Data to select Segment supervisor high map
      000000F0          1855* SMUsrLo equ     $F0             ;CXreg Data to select Segment user mode low map
      000000B0          1856* SMUsrHi equ     $B0             ;CXreg Data to select Segment user mode high map
      000000C0          1857* PMSupLo equ     $C0             ;CXreg Data to select Page supervisor low map
      00000080          1858* PMSupHi equ     $80             ;CXreg Data to select Page supervisor high map
      000000D0          1859* PMUsrLo equ     $D0             ;CXreg Data to select Page user mode low map
      00000090          1860* PMUsrHi equ     $90             ;CXreg Data to select Page user mode high map
                        1861* ;Map Transparent--Sets all the segments and pages contiguously and allows all
                        1862* ;                 accesses.
0B36                    1863* MapTran
0B36  4BFA  05E0+       1864*         lea     msgMapping,A5      ;
0B3A  6100  153C        1865*         bsr     DSoutSt         ;
0B3E  33FC  0F00  0080  1866*         move.w  #InSDTp,InSegD.l;start with $f00 in variable location.
0B44  0D6A  
0B46  33FC  0000  0080  1867*         move.w  #InPDTp,InpagD.l;start with $0000
0B4C  0D6C  
0B4E  6114              1868*         bsr.s   MapSegs         ;map the segments
0B50  6100  FA60        1869*         bsr     outdot
0B54  6100  00EC        1870*         bsr     MapPages        ;map the pages
0B58  6100  FA58        1871*         bsr     outdot
File: C1.MAIN.TEXT                                                Page  45


0B5C  4BFA  0605+       1872*         lea     msgDone,A5      ;
0B60  6000  1516        1873*         bra     DSoutSt         ;
                        1874* ;Map segments -- This routine maps the segments contiguously
                        1875* ;Description InSegD.W should be set to access mode desired in upper byte of word
                        1876* ;            The lower byte is cleared by the program and the data is written to
                        1877* ;            the segment map as follows(lower byte only is shown):
                        1878* ;       Supervisor Low : 00-3F
                        1879* ;       Supervisor High: 40-7F
                        1880* ;       User Low       : 80-BF
                        1881* ;       User High      : C0-FF
                        1882* ;       This is done for all sixteen Contexts
                        1883* ; Register definitions
                        1884* ;
                        1885* ; D0 - data to write to segment map
                        1886* ; D4 - loop counter: Segments per mode-1($3F)
                        1887* ; D5 - loop counter: Contexts per map -1($0F)
                        1888* ; D7 - data to write to context register
                        1889* ; A2 - map pointer
                        1890* ; A3 - context register pointer
                        1891* ;      Enter: InSegD.w must be set to $F00
0B64  08B9  0005  0080  1892* MapSegs bclr    #TsegBit,SysFlag.l
0B6A  0D64  
0B6C  47F9  0084  0003  1893*         lea     CtxReg.l,A3     ;get context register pointer
0B72  7A0F              1894*         moveq   #CxPerMp-1,D5   ;get loop counter for context loop
0B74  1E3C  00E0        1895* MapSeg1 move.b  #SMSupLo,D7     ;Start with supervisor low map
0B78  3039  0080  0D6A  1896*         move.w  InSegD.l,D0     ;get initial segment data for this context
0B7E  8E05              1897* MapSeg2 or.b    D5,D7           ;point to proper context and mode
0B80  1687              1898*         move.b  D7,(A3)         ;write to context register
0B82  45F9  0040  0000  1899*         lea     MapBase.l,A2    ;Set A2 to point to map rams
0B88  783F              1900*         moveq   #SgPerCx-1,D4   ;get loop counter for segment loop
0B8A  3480              1901* MapSeg3 move.w  D0,(A2)         ;write to segment map
0B8C  D5FC  0001  0000  1902*         adda.l  #SegOfst,A2     ;increment address
0B92  5240              1903*         addq.w  #1,D0           ;increment segment data
0B94  51CC  FFF4        1904*         dbra    D4,MapSeg3      ;loop segments per context
0B98  0847  0006        1905*         bchg    #SLMbit,D7      ;test and change select low map bit
0B9C  66E0              1906*         bne.s   MapSeg2         ;loops twice
0B9E  0847  0004        1907*         bchg    #SUMbit,D7      ;test and change select user mode bit
0BA2  67DA              1908*         beq.s   MapSeg2         ;loops twice
0BA4  51CD  FFCE        1909*         dbra    D5,MapSeg1      ;loop through contexts
                        1910* ;We've written now lets check 'em
0BA8  7A0F              1911*         moveq   #CxPerMp-1,D5   ;get loop counter for context loop
0BAA  1E3C  00E0        1912* MapSeg4 move.b  #SMSupLo,D7     ;First map
0BAE  3039  0080  0D6A  1913*         move.w  InSegD.l,D0     ;get initial segment data for this
0BB4  8E05              1914* MapSeg5 or.b    D5,D7           ;point to proper context
0BB6  1687              1915*         move.b  D7,(A3)         ;write to context register
0BB8  45F9  0040  0000  1916*         lea     MapBase.l,A2    ;Set A2
0BBE  783F              1917*         moveq   #SgPerCx-1,D4   ;get loop counter for segment loop
0BC0  3212              1918* MapSeg6 move.w  (A2),D1         ;read from segment map
0BC2  B240              1919*         cmp.w   D0,D1
0BC4  662A              1920*         bne.s   SmapErr         ;exit
0BC6  D5FC  0001  0000  1921*         adda.l  #SegOfst,A2     ;increment address
0BCC  5240              1922*         addq.w  #1,D0           ;increment segment data
0BCE  51CC  FFF0        1923*         dbra    D4,MapSeg6      ;loop segments per context
0BD2  0847  0006        1924*         bchg    #SLMbit,D7      ;test and changed select high map bit
File: C1.MAIN.TEXT                                                Page  46


0BD6  66DC              1925*         bne.s   MapSeg5         ;loop for number of modes
0BD8  0847  0004        1926*         bchg    #SUMbit,D7      ;select user mode
0BDC  67D6              1927*         beq.s   MapSeg5         ;
0BDE  51CD  FFCA        1928*         dbra    D5,MapSeg4      ;loop through contexts
0BE2  16BC  0000        1929*         move.b  #0,(A3)         ;clear cx reg
0BE6  08F9  0005  0080  1930*         bset    #Tsegbit,SysFlag.l;if we get here then it is done
0BEC  0D64  
0BEE  4E75              1931*         RTS
                        1932* ;
                        1933* ;
                        1934* ;map errors--output failing address data expected and data read
                        1935* ;               and context register value
                        1936* ;       Enter:  A2 address of failure
                        1937* ;               A3 context register
                        1938* ;               D1 data read
                        1939* ;               D0 data expected
                        1940* ;all data is bytes - address is 3 bytes.
                        1941* ;
                        1942* 
0BF0  4BFA  053B+       1943* SMapErr lea     msgsmaperr,A5    ;messg-segment map error
0BF4  08B9  0005  0080  1944*         bclr    #TsegBit,SysFlag.l
0BFA  0D64  
0BFC  08F9  0001  0080  1945*         bset    #Smapbit,TstStat.l
0C02  0DB6  
0C04  7C01              1946*         moveq   #1,D6           ;display  word
0C06  2F00              1947*         move.l  D0,-(SP)        ;save data expected
0C08  200A              1948*         move.l  A2,D0           ;get failing address
0C0A  4840              1949*         swap    D0              ;get upper half
0C0C  C07C  003F        1950*         and     #$3f,D0         ;clear A22 and up
0C10  6100  F8AE        1951*         bsr     outhex          ;display segment/page number
0C14  201F              1952*         move.l  (sp)+,D0        ;return data expected
0C16  601C              1953*         bra.s   maperr          ;
0C18  4BFA  0531+       1954* PMapErr lea     msgpmaperr,A5   ;message page map error
0C1C  6100  145A        1955*         bsr     Dsoutst         ;*
0C20  08B9  0004  0080  1956*         bclr    #TranBit,SysFlag.l
0C26  0D64  
0C28  08F9  0002  0080  1957*         bset    #Pmapbit,TstStat.l
0C2E  0DB6  
0C30  6100  0CBE        1958*         bsr     DspPgNo         ;display page # in hex
0C34                    1959* MapErr
0C34  7C02              1960*         moveq   #2,D6           ;display words
0C36  6100  F8F4        1961*         bsr     mcdata          ;miscompare--word data
0C3A  6100  FDE8        1962*         bsr     ShowCr          ;display context register value
0C3E  6000  0134        1963*         bra     mapmenu
                        1964* ;MapPages-Map pages contiguosly
                        1965* ;Description InPagD.W should be set to access mode desired in upper byte of word
                        1966* ;Supervisor Low,Supervisor High,User Low,User High in one ctx with 0-3FF written
                        1967* ; Register definitions
                        1968* ;
                        1969* ; D0 - data to write to page map
                        1970* ; D5 - loop counter: pages per mode-1($3FF)
                        1971* ; A2 - map pointer
                        1972* ; A3 - context register pointer
                        1973* ;      Enter: InSegD.w must be set to $F00
File: C1.MAIN.TEXT                                                Page  47


0C42                    1974* MapPages
0C42  08B9  0004  0080  1975*         bclr    #Tranbit,SysFlag.l;
0C48  0D64  
0C4A  47F9  0084  0003  1976*         lea     CtxReg.l,A3     ;get context register pointer
0C50  16BC  00C0        1977*         move.b  #PMSupLo,(A3)   ;Start with supervisor low map
0C54  3039  0080  0D6C  1978* MapPag1 move.w  InPagD.l,D0     ;get initial page data for this mode
0C5A  45F9  0040  0000  1979*         lea     MapBase.l,A2    ;Set A2 to point to map rams
0C60  383C  03FF        1980*         move.w  #PgPerCx-1,D4   ;get loop counter for page loop
0C64  3480              1981* MapPag2 move.w  D0,(A2)         ;write to page map
0C66  D5FC  0000  1000  1982*         adda.l  #PagOfst,A2     ;increment address
0C6C  5240              1983*         addq.w  #1,D0           ;increment page data
0C6E  51CC  FFF4        1984*         dbra    D4,MapPag2      ;loop pages per context
0C72  0853  0006        1985*         bchg    #SLMbit,(A3)    ;test and change select low map bit
0C76  66DC              1986*         bne.s   MapPag1         ;loops twice
0C78  0853  0004        1987*         bchg    #SUMbit,(A3)    ;test and change select user mode bit
0C7C  67D6              1988*         beq.s   MapPag1         ;loops twice
                        1989* ;We've written now lets check 'em
0C7E  16BC  00C0        1990*         move.b  #PMSupLo,(A3)   ;Start with supervisor low map
0C82  3039  0080  0D6C  1991* MapPag3 move.w  InPagD.l,D0     ;get initial page data for this mode
0C88  45F9  0040  0000  1992*         lea     MapBase.l,A2    ;Set A2 to point to map rams
0C8E  383C  03FF        1993*         move.w  #PgPerCx-1,D4   ;get loop counter for page loop
0C92  3212              1994* MapPag4 move.w  (A2),D1         ;read from page map
0C94  B240              1995*         cmp.w   D0,D1           ;check data
0C96  6600  FF80        1996*         bne     PMapErr         ;error
0C9A  D5FC  0000  1000  1997*         adda.l  #PagOfst,A2     ;increment address
0CA0  5240              1998*         addq.w  #1,D0           ;increment Page data
0CA2  51CC  FFEE        1999*         dbra    D4,MapPag4      ;loop pages per context
0CA6  0853  0006        2000*         bchg    #SLMbit,(A3)    ;test and change select low map bit
0CAA  66D6              2001*         bne.s   MapPag3         ;loops twice
0CAC  0853  0004        2002*         bchg    #SUMbit,(A3)    ;test and change select user mode bit
0CB0  67D0              2003*         beq.s   MapPag3         ;loops twice
0CB2  16BC  0000        2004*         move.b  #0,(A3)         ; clear reg
0CB6  08F9  0004  0080  2005*         bset    #Tranbit,SysFlag.l;the pages are now mapped
0CBC  0D64  
0CBE  4E75              2006*         RTS
                        2007* ;
                        2008* ;       Enter - A2=pointer to memory being displayed
                        2009* ;               D3=incrementer
                        2010* ;
                        2011* ;
                        2012* ;Display Segment Map
                        2013* ;
0CC0                    2014* DmpSeg
0CC0  263C  0001  0000  2015*         move.l  #SegOfst,D3     ;incrementer for segments
0CC6  47F9  0084  0003  2016*         lea     CtxReg.l,A3     ;point to context register
0CCC  1E13              2017*         move.b  (A3),D7         ;save context value
0CCE  0213  000F        2018*         andi.b  #$F,(A3)        ;clear upper nibble
0CD2  0013  00E0        2019*         ori.b   #SMsupLo,(A3)   ;First to show
0CD6  7400              2020* DmpSeg1 moveq   #0,D2           ;initial segment counter
0CD8  45F9  0040  0000  2021*         lea     mapbase.l,A2    ;get start address in A2
0CDE  6100  0394        2022*         bsr     CXout           ;dixplay context register in english
0CE2  6116              2023*         bsr.s   DmpMap          ;show one map
0CE4  6100  F888        2024*         bsr     Keypress        ;wait for any key
0CE8  670C              2025*         beq.s   DmpSegX         ;yes restore original context and exit
File: C1.MAIN.TEXT                                                Page  48


0CEA  0853  0006        2026*         bchg    #SLMbit,(A3)    ;get next map
0CEE  66E6              2027*         bon.s   DmpSeg1         ;loop
0CF0  0853  0004        2028*         bchg    #SUMbit,(A3)    ;get next map
0CF4  67E0              2029*         boff.s  DmpSeg1         ;loop
0CF6  1687              2030* DmpSegX move.b  D7,(A3)         ;set context reg back
0CF8  4E75              2031*         RTS
                        2032* ;
                        2033* ;Subroutine for dump segment and page maps
                        2034* ;       Enter-contxt register pointing to proper map
                        2035* ;               D3=offset
                        2036* ;               D2=initial seg/pag number
                        2037* ;               A2=Start address
                        2038* ;
0CFA                    2039* DmpMap
0CFA  48E7  8E00        2040*         movem.l D0/D4-D6,-(SP)  ;save registers
0CFE  7A07              2041*         moveq   #7,D5           ;number of lines - 1 to print
0D00  7C02              2042*         moveq   #2,D6           ;display 1 word
0D02  2002              2043* Dmpmap2 move.l  D2,D0           ;get current address
0D04  6100  F7BA        2044*         bsr     outhex          ;display hex characters
0D08  7807              2045*         moveq   #7,D4          ;set count to display 8 hex words
0D0A  6100  137E        2046*         bsr     DSoutSp
0D0E  6100  137A        2047* DmpMap3 bsr     DSoutSp         ;display a space
0D12  3012              2048*         move.w  (A2),D0         ;get value from memory
0D14  6100  F7AA        2049*         bsr     outhex          ;put 4 hex characters (1 word) into buffer
0D18  5242              2050*         addq    #1,D2           ;up counter
0D1A  D5C3              2051*         adda.l  D3,A2           ;increment address
0D1C  51CC  FFF0        2052*         dbra    D4,DmpMap3      ;loop
0D20  6100  1374        2053*         bsr     DSoutCr         ;output 1 line from buffer
0D24  51CD  FFDC        2054*         dbra    D5,Dmpmap2      ;loop until done
0D28  4CDF  0071        2055*         movem.l (SP)+,D0/D4-D6  ;restore
0D2C  4E75              2056*         RTS
                        2057* ;
                        2058* ;Display Page Map
                        2059* ;
0D2E                    2060* DmpPag
0D2E  47F9  0084  0003  2061*         lea     CtxReg.l,A3
0D34  1E13              2062*         move.b  (A3),D7         ;save context value
0D36  0213  000F        2063*         andi.b  #$F,(A3)        ;clear upper nibble
0D3A  263C  0000  1000  2064*         move.l  #PagOfst,D3     ;incrementer for pages
0D40  0013  00C0        2065*         ori.b   #PMsupLo,(A3)   ;allow map and page accesses
0D44  7400              2066* DmpPag1 moveq   #0,D2           ;initial page counter
0D46  45F9  0040  0000  2067*         lea     mapbase.l,A2    ;get start address in A2
0D4C  6100  0326        2068*         bsr     CXout           ;dixplay context register in english
0D50  7C07              2069*         moveq   #7,D6           ;dump 8 blocks
0D52  7A01              2070* DmpPag2 moveq   #1,D5           ;dump 2 blocks
0D54  61A4              2071* DmpPag3 bsr.s   DmpMap
0D56  51CD  FFFC        2072*         dbra    D5,DmpPag3      ;loop
0D5A  6100  F812        2073*         bsr     Keypress        ;wait for any key
0D5E  57CE  FFF2        2074*         dbeq    D6,DmpPag2      ;except escape
0D62  670C              2075*         beq.s   DmpPagX
0D64  0853  0006        2076*         bchg    #SLMbit,(A3)    ;get next map
0D68  66DA              2077*         bon.s   DmpPag1         ;loop
0D6A  0853  0004        2078*         bchg    #SUMbit,(A3)    ;get next map
0D6E  67D4              2079*         boff.s  DmpPag1         ;loop
File: C1.MAIN.TEXT                                                Page  49


0D70  1687              2080* DmpPagX move.b  D7,(A3)         ;restore original value
0D72  4E75              2081*         RTS
                        2082* ;
File: C1.MAIN.TEXT                                                Page  50


                        2084* ;
0D74  4BFA  03F3+       2085* MapMenu lea     msgmapmenu,A5
0D78  6100  12FE        2086*         bsr     DSoutST
0D7C  6100  1318        2087* MapPrmt bsr     DSoutcr
0D80  103C  0023        2088*         move.b  #Prompt2,D0     ;prompt for map menu
0D84  6100  F504        2089*         bsr     MenuKey         ;get response from user
0D88  487A  FFF2+       2090*         pea     MAPPrmt         ;return to prompt
0D8C  41BC  0006        2091*         chk     #6,D0         ;*
0D90  E300              2092*         asl.b   #1,d0              ;double for table
0D92  303B  0006+       2093*         move.w  maptbl(D0.W),D0
0D96  4EFB  0002+       2094*         jmp     maptbl(D0.W)
                        2095* ;
0D9A  F556              2096* MapTbl  data.w  dragon-maptbl
0D9C  002C              2097*         data.w  segtest-MapTbl
0D9E  01A2              2098*         data.w  pagtest-MapTbl
0DA0  FD9C              2099*         data.w  maptran-MapTbl
0DA2  000E              2100*         data.w  mtstall-MapTbl
0DA4  FF26              2101*         data.w  DmpSeg-MapTbl
0DA6  FF94              2102*         data.w  DmpPag-MapTbl
                        2103* ;
0DA8  4BFA  0326+       2104* mtstall lea     msgmapram,A5
0DAC  6100  12CA        2105*         bsr     Dsoutst
0DB0  611C              2106*         bsr.s   SegTst          ;execute segment tests with no messages
0DB2  6610              2107*         bne.s   MTAexit         ;only ne return is option not to continue
0DB4  6100  018E        2108*         bsr     PagTst
0DB8  6100  FE88        2109*         bsr     MapPages
0DBC  4BFA  2224+       2110*         lea     msgpass,A5
0DC0  6100  12B6        2111*         bsr     DSoutst
0DC4  4E75              2112* MTAexit RTS
                        2113* ;
0DC6  4BFA  031A+       2114* SegTest lea     msgsegment,A5
0DCA  6100  12AC        2115*         bsr     DSoutSt         ;
0DCE  0839  0000  0080  2116* SegTst  btst    #RegBit,TstStat.l
0DD4  0DB6  
0DD6  6706              2117*         beq.s   SegTst1         ;passed registers, continue
0DD8  6100  F7B2        2118*         bsr     Warn            ;give user warning and oppurtinity to continue
0DDC  6620              2119*         bne.s   SegTxit         ;doesn't want to exit
0DDE  08B9  0005  0080  2120* SegTst1 bclr    #SegBit,TstStat.l;clear any previous error
0DE4  0DB6  
0DE6  4DFA  0018+       2121*         lea     SWtest,A6       ;load test address into a6
0DEA  6104              2122*         bsr.s   SegExec         ;execute segment test
0DEC  4DFA  0088+       2123*         lea     SMtest,A6       ;load march test address
0DF0  6100  F7CE        2124* SegExec bsr     ExecTst         ;execute test
0DF4  6600  FDFA        2125*         bne     SmapErr         ;report errors
0DF8  6100  F7B8        2126*         bsr     outdot          ;display period and rts
0DFC  B040              2127*         cmp     d0,d0           ;force an eq
0DFE  4E75              2128* SegTxit RTS
                        2129* ;
                        2130* ;Segment Map Walk test--data test for segment static rams
                        2131* ; Since only three 4bit wide rams are used the unused upper four bits are always
                        2132* ; zero which is why this loop is so complicated. Not to mention that the address
                        2133* ; ing of the rams involves writing to the context register.  This test is done
                        2134* ; in consecutive locations.
                        2135* ; Static Ram address (from high down  to low)
File: C1.MAIN.TEXT                                                Page  51


                        2136* ;               11    Select User Mode
                        2137* ;               10    Select low Map
                        2138* ;              9to6   Contextbits 3-0
                        2139* ;              5to0   XA21-16
                        2140* 
0E00  47F9  0084  0003  2141* SWtest  lea     CtxReg.l,A3     ;get context register pointer
0E06  7E00              2142*         moveq   #0,D7           ;zero reg
0E08  08B9  0005  0080  2143*         bclr    #tsegbit,Sysflag.l
0E0E  0D64  
0E10  1E3C  00A0        2144*         move.b  #SMsupHi,D7     ;point to low segment map rams
                        2145* ;walk a zero in ones
0E14  7A00              2146* Sgwalk0 moveq   #0,D5           ;clear context counter
0E16  0207  00F0        2147* SWCtxlp andi.b  #$F0,D7         ;clear lowr nibble
0E1A  8E05              2148*         or.b    D5,D7           ;point to proper context
0E1C  1687              2149*         move.b  D7,(A3)         ;write to ctx reg
0E1E  45F9  0040  0000  2150*         lea     MapBase.l,A2     ;Set A2
0E24  783F              2151*         moveq   #SgPerCx-1,D4   ;get loop counter for segment loop
0E26  70FE              2152* SgWalk  moveq   #-2,D0          ;initialize write data(walk a zero in ones)
0E28  760B              2153*         moveq   #11,D3          ;counter for walk loop
0E2A  3480              2154* SgWalk1 move.w  D0,(A2)        ;write to segment map
0E2C  3212              2155*         move.w  (a2),D1         ;read
0E2E  C07C  0FFF        2156*         and.w   #$0FFF,D0       ;clear upper nibbl
0E32  B240              2157*         cmp.w   D0,D1           ;compare
0E34  663E              2158*         bne.s   SWexit          ;exit
0E36  807C  8000        2159*         or.w    #$8000,D0       ;set top most bit for next instruction
0E3A  E358              2160*         rol.w   #1,D0           ;rotate
0E3C  51CB  FFEC        2161*         dbra    D3,SgWalk1      ;loop 12 times
                        2162* ;walk a one in zeroes
0E40  7001              2163*         moveq   #1,D0          ;initialize write data(walk a zero in ones)
0E42  760B              2164*         moveq   #11,D3          ;counter for walk loop
0E44  3480              2165* SgWalk2 move.w  D0,(A2)        ;write to segment map
0E46  3212              2166*         move.w  (a2),D1         ;read
0E48  B240              2167*         cmp.w   D0,D1           ;compare
0E4A  6628              2168*         bne.s   SWexit          ;exit
0E4C  E340              2169*         asl.w   #1,D0           ;rotate
0E4E  51CB  FFF4        2170*         dbra    D3,SgWalk2      ;loop 12 times
0E52  D5FC  0001  0000  2171*         adda.l  #SegOfst,A2     ;increment address
0E58  51CC  FFCC        2172*         dbra    D4,SgWalk       ;loop segments per context
0E5C  5205              2173*         addq.b  #1,D5           ;increment context counter
0E5E  BA3C  000F        2174*         cmp.b   #$F,D5          ;do 16 times
0E62  6FB2              2175*         ble.s   SWCtxLp         ;loop contexts per map
0E64  0847  0006        2176*         bchg    #SLMbit,D7      ;select user mode
0E68  67AA              2177*         beq.s   Sgwalk0      ;loop for number of modes
0E6A  0847  0004        2178*         bchg    #SUMbit,D7      ;test and changed select high map bit
0E6E  6700  FFA4        2179*         beq     Sgwalk0         ;
0E72  B040              2180*         cmp     D0,D0           ;force an eq
0E74  4E75              2181* SWexit  RTS
File: C1.MAIN.TEXT                                                Page  52


                        2183* ;
0E76  47F9  0084  0003  2184* SMtest  lea     CtxReg.l,A3     ;get context register pointer
0E7C  08B9  0005  0080  2185*         bclr    #tsegbit,Sysflag.l
0E82  0D64  
0E84  7E00              2186*         moveq   #0,D7           ;zero reg
0E86  1E3C  00A0        2187*         move.b  #SMsupHi,D7     ;start at bottom address of map rams
0E8A  7400              2188*         moveq   #0,D2           ;use d2 as write reg
0E8C  7A00              2189* SMclr1  moveq   #0,D5           ;clear context counter
0E8E  0207  00F0        2190* SMclr2  andi.b  #$F0,D7         ;clear lowr nibble
0E92  8E05              2191*         or.b    D5,D7           ;point to proper context
0E94  1687              2192*         move.b  D7,(A3)         ;write to ctx reg
0E96  45F9  0040  0000  2193*         lea     MapBase.l,A2     ;Set A2
0E9C  783F              2194*         moveq   #SgPerCx-1,D4   ;get loop counter for segment loop
0E9E  3482              2195* SMclr3  move.w  D2,(A2)            ;zero memory
0EA0  D5FC  0001  0000  2196*         adda.l  #SegOfst,A2     ;increment address
0EA6  51CC  FFF6        2197*         dbra    D4,SMclr3       ;loop segments per context
0EAA  5205              2198*         addq.b  #1,D5           ;increment context counter
0EAC  BA3C  000F        2199*         cmp.b   #$F,D5          ;do 16 times
0EB0  6FDC              2200*         ble.s   SMclr2          ;loop contexts per map
0EB2  0847  0006        2201*         bchg    #SLMbit,D7      ;select user mode
0EB6  67D4              2202*         beq.s   SMclr1          ;loop for number of modes
0EB8  0847  0004        2203*         bchg    #SUMbit,D7      ;test and changed select high map bit
0EBC  67CE              2204*         beq.s   SMclr1          ;
                        2205* ;March down to low memory
0EBE  3002              2206*         move.w  D2,D0           ;d0 is data expected is 0
0EC0  343C  0FFF        2207*         move.w  #$FFF,D2        ;d2=0fff is data to write
0EC4  1E3C  00F0        2208*         move.b  #SMusrLo,D7     ;start at highes address
0EC8  224A              2209*         movea.l A2,A1           ;save high address of segment map
0ECA  7A0F              2210* SegMar1 moveq   #CXperMP-1,D5   ;number of contexts
0ECC  0207  00F0        2211* SegMar2 andi.b  #$F0,D7         ;clear lowr nibble
0ED0  8E05              2212*         or.b    D5,D7           ;point to proper context
0ED2  1687              2213*         move.b  D7,(A3)         ;write to ctx reg
0ED4  2449              2214*         movea.l A1,A2           ;start from high segment map address for ctx
0ED6  783F              2215*         moveq   #SgperCx-1,D4   ;get number of segments per context
0ED8  95FC  0001  0000  2216* SegMar3 suba.l  #SegOfst,A2     ;decrement address
0EDE  3212              2217*         move.w  (a2),d1         ;read data
0EE0  B240              2218*         cmp.w   d0,d1           ;Is it a zero?
0EE2  6656              2219*         bne.s   SMexit          ;No, go  to error routine
0EE4  3482              2220*         move.w  d2,(a2)         ;Write $0FFF
0EE6  51CC  FFF0        2221*         dbra    D4,SegMar3      ;loop
0EEA  51CD  FFE0        2222*         dbra    D5,SegMar2      ;loop through contexts
0EEE  0847  0006        2223*         bchg    #SLMbit,D7      ;test and change
0EF2  66D6              2224*         bne.s   SegMar1         ;branch when changed from 1 to 0
0EF4  0847  0004        2225*         bchg    #SUMbit,D7      ;test and change
0EF8  66D0              2226*         bne.s   SegMar1         ;branch when changed form 1 to 0
File: C1.MAIN.TEXT                                                Page  53


                        2228* ;march back to high memory
0EFA  C142              2229*         exg     D0,D2           ;D0-data expected is now $fff ,D2 is 0
0EFC  1E3C  00A0        2230*         move.b  #SMsupHi,D7     ;point to hi  segment map rams
0F00  7A00              2231* SegMar4 moveq   #0,D5           ;clear context counter
0F02  0207  00F0        2232* SegMar5 andi.b  #$F0,D7         ;clear lowr nibble
0F06  8E05              2233*         or.b    D5,D7           ;point to proper context
0F08  1687              2234*         move.b  D7,(A3)         ;write to ctx reg
0F0A  45F9  0040  0000  2235*         lea     MapBase.l,A2     ;Set A2
0F10  783F              2236*         moveq   #SgPerCx-1,D4   ;get loop counter for segment loop
0F12  3212              2237* SegMar6 move.w  (a2),d1         ;read data
0F14  B240              2238*         cmp.w   d0,d1           ;Is it $fff?
0F16  6622              2239*         bne.s   SMexit          ;No, go  to error routine
0F18  3482              2240*         move.w  d2,(a2)         ;Write $0
0F1A  D5FC  0001  0000  2241*         adda.l  #SegOfst,A2     ;increment address
0F20  51CC  FFF0        2242*         dbra    D4,SegMar6      ;loop segments per context
0F24  5205              2243*         addq.b  #1,D5           ;increment context counter
0F26  BA3C  000F        2244*         cmp.b   #$F,D5          ;do 16 times
0F2A  6FD6              2245*         ble.s   SegMar5         ;loop contexts per map
0F2C  0847  0006        2246*         bchg    #SLMbit,D7      ;test and changed select high map bit
0F30  67CE              2247*         beq.s   SegMar4         ;
0F32  0847  0004        2248*         bchg    #SUMbit,D7      ;select user mode
0F36  67C8              2249*         beq.s   SegMar4         ;loop for number of modes
0F38  B000              2250*         cmp.b   D0,D0           ;force an eqe
0F3A  4E75              2251* SMexit  RTS
                        2252* ;
0F3C  4BFA  01AE+       2253* PagTest lea     msgpage,A5
0F40  6100  1136        2254*         bsr     DSoutSt         ;
0F44  0839  0005  0080  2255* PagTst  btst    #TsegBit,SysFlag.l;are segments mapped transparent?
0F4A  0D64  
0F4C  6604              2256*         bne.s   PagTst1         ;yes,continue
0F4E  6100  FC14        2257*         bsr     MapSegs         ;map them
0F52  08B9  0002  0080  2258* PagTst1 bclr    #PmapBit,TstStat.l;clear any previous error
0F58  0DB6  
0F5A  4DFA  0016+       2259*         lea     PWtest,A6       ;load test address into a6
0F5E  6104              2260*         bsr.s   PagExec         ;execute segment test
0F60  4DFA  0078+       2261*         lea     PMtest,A6       ;load march test address
0F64  6100  F65A        2262* PagExec bsr     ExecTst         ;execute test
0F68  6600  FCAE        2263*         bne     PmapErr         ;report errors
0F6C  6100  F644        2264*         bsr     outdot          ;display period and rts
0F70  4E75              2265* PagTxit RTS
                        2266* ;
                        2267* ;Page Map Walk test--data test for page static rams
                        2268* ; Since only three 4bit wide rams are used the unused upper four bits are always
                        2269* ; zero which is why this loop is so complicated. Not to mention that the address
                        2270* ; ing of the rams involves writing to the context register.  This test is done
                        2271* ; in consecutive locations.
                        2272* ; The segment map rams point to the pages (all contexts are the same) thusly:
                        2273* ;       Supervisor Low : 00-3F
                        2274* ;       Supervisor High: 40-7F
                        2275* ;       User Low       : 80-BF
                        2276* ;       User High      : C0-FF
File: C1.MAIN.TEXT                                                Page  54


                        2278* ;
0F72  47F9  0084  0003  2279* PWtest  lea     CtxReg.l,A3     ;get context register pointer
0F78  16BC  0080        2280*         move.b  #PMsupHi,(A3)   ;point low page map
0F7C  08B9  0004  0080  2281*         bclr    #Tranbit,SysFlag.l
0F82  0D64  
                        2282* ;walk a zero in ones
0F84  45F9  0040  0000  2283* Pgwalk0 lea     MapBase.l,A2     ;Set A2
0F8A  383C  03FF        2284*         move.w  #PgPerCx-1,D4   ;get loop counter for page loop
0F8E  70FE              2285* PgWalk  moveq    #-2,D0          ;initialize write data(walk a zero in ones)
0F90  3480              2286* PgWalk1 move.w  D0,(A2)        ;write to page map
0F92  3212              2287*         move.w  (a2),D1         ;read
0F94  B240              2288*         cmp.w   D0,D1           ;compare
0F96  662A              2289*         bne.s   PWexit         ;exit
0F98  E358              2290*         rol.w   #1,D0           ;rotate
0F9A  65F4              2291*         bcs.s   PgWalk1      ;loop
                        2292* ;walk a one in zeroes
0F9C  7001              2293*         moveq   #1,D0          ;initialize write data(walk a zero in ones)
0F9E  3480              2294* PgWalk2 move.w  D0,(A2)        ;write to page map
0FA0  3212              2295*         move.w  (a2),D1         ;read
0FA2  B240              2296*         cmp.w   D0,D1           ;compare
0FA4  661C              2297*         bne.s   PWexit         ;exit
0FA6  E340              2298*         asl.w   #1,D0           ;rotate
0FA8  64F4              2299*         bcc.s   PgWalk2      ;loop
0FAA  D5FC  0000  1000  2300*         adda.l  #PagOfst,A2     ;increment address
0FB0  51CC  FFDC        2301*         dbra    D4,PgWalk       ;loop pages per context
0FB4  0853  0006        2302*         bchg    #SLMbit,(A3)    ;toggle high and low map
0FB8  67CA              2303*         beq.s   Pgwalk0      ;loop for number of modes
0FBA  0853  0004        2304*         bchg    #SUMbit,(A3)    ;toggle user/supervisor
0FBE  67C4              2305*         beq.s   Pgwalk0         ;
0FC0  B000              2306*         cmp.b   D0,D0           ;set z bit
0FC2  4E75              2307* PWexit  RTS
File: C1.MAIN.TEXT                                                Page  55


                        2309* ;
                        2310* ;Page Map March test
                        2311* ; Returns an EQ if good and an NE if failed
                        2312* ; address is done in consecutive physical locations.
                        2313* ;
0FC4  4BFA  05E1+       2314* PagMar  lea     msgmarch,A5
0FC8  6100  10AE        2315*         bsr     DSoutst
0FCC  0839  0005  0080  2316*         btst    #TsegBit,SysFlag.l
0FD2  0D64  
0FD4  6604              2317*         bne.s   PgMar1
0FD6  6100  FB8C        2318*         bsr     MapSegs
0FDA                    2319* PgMar1
0FDA  47F9  0084  0003  2320* PMtest  lea     CtxReg.l,A3     ;get context register pointer
0FE0  16BC  0080        2321*         move.b  #PMsupHi,(A3)         ;point to low page map rams
0FE4  7400              2322*         moveq   #0,D2           ;initial write register
0FE6  08B9  0004  0080  2323*         bclr    #tranbit,Sysflag.l
0FEC  0D64  
0FEE  45F9  0040  0000  2324* PMclr1 lea     MapBase.l,A2     ;Set A2
0FF4  383C  03FF        2325*         move.w  #PgPerCx-1,D4   ;get loop counter for page loop
0FF8  3482              2326* PMclr3  move.w  D2,(A2)            ;zero memory
0FFA  D5FC  0000  1000  2327*         adda.l  #PagOfst,A2     ;increment address
1000  51CC  FFF6        2328*         dbra    D4,PMclr3       ;loop pages per context
1004  0853  0006        2329*         bchg    #SLMbit,(A3)    ;select user mode
1008  67E4              2330*         beq.s   PMclr1          ;loop for number of modes
100A  0853  0004        2331*         bchg    #SUMbit,(A3)    ;test and changed select high map bit
100E  67DE              2332*         beq.s   PMclr1          ;
                        2333* ;March down to low memory
1010  2002              2334*         move.l  D2,D0           ;d0 is data expected  - zero it
1012  74FF              2335*         moveq   #-1,D2        ;d2=ffff is data to write
1014  224A              2336*         movea.l A2,A1           ;save high address of page map
1016  16BC  00D0        2337*         move.b  #PMusrLo,(A3)   ;set upper nibble of ctx reg for upper map
101A  2449              2338* PagMar1 movea.l A1,A2           ;start from high page map address for ctx
101C  383C  03FF        2339*         move.w   #PgperCx-1,D4   ;get number of pages per context
1020  95FC  0000  1000  2340* PagMar3 suba.l  #PagOfst,A2     ;decrement address
1026  3212              2341*         move.w  (a2),d1         ;read data
1028  B240              2342*         cmp.w   d0,d1           ;Is it a zero?
102A  6646              2343*         bne.s   PMexit          ;No, go  to error routine
102C  3482              2344*         move.w  d2,(a2)         ;Write $FFFF
102E  51CC  FFF0        2345*         dbra    D4,PagMar3      ;loop
1032  0853  0006        2346*         bchg    #SLMbit,(A3)    ;test and change
1036  66E2              2347*         bne.s   PagMar1         ;branch when changed from 1 to 0
1038  0853  0004        2348*         bchg    #SUMbit,(A3)    ;test and change
103C  66DC              2349*         bne.s   PagMar1         ;branch when changed form 1 to 0
File: C1.MAIN.TEXT                                                Page  56


                        2351* ;march back to high memory
103E  C142              2352*         exg     D0,D2           ;D0-data expected is now $ffff,D2 is 0
1040  CA3C  000F        2353*         and.b   #$0F,D5         ;clear upper nibble
1044  16BC  0080        2354*         move.b  #PMsupHi,(A3)   ;point low page map
1048  45F9  0040  0000  2355* PagMar4 lea     MapBase.l,A2     ;Set A2
104E  383C  03FF        2356*         move.w  #PgPerCx-1,D4   ;get loop counter for Pagment loop
1052  3212              2357* PagMar6 move.w  (a2),d1         ;read data
1054  B240              2358*         cmp.w   d0,d1           ;Is it $ffff?
1056  661A              2359*         bne.s   PMexit            ;No, go  to error routine
1058  3482              2360*         move.w  d2,(a2)         ;Write $0
105A  D5FC  0000  1000  2361*         adda.l  #PagOfst,A2     ;increment address
1060  51CC  FFF0        2362*         dbra    D4,PagMar6      ;loop pages per context
1064  0853  0006        2363*         bchg    #SLMbit,(A3)    ;select user mode
1068  67DE              2364*         beq.s   PagMar4         ;loop for number of modes
106A  0853  0004        2365*         bchg    #SUMbit,(A3)    ;test and changed select high map bit
106E  67D8              2366*         beq.s   PagMar4         ;
1070  B000              2367*         cmp.b   D0,D0           ;force an eq
1072  4E75              2368* PMExit  RTS
                        2369* ;CXout--Output the value of the context register in English
                        2370* ;ie.. cr=B7 would be Segment user high map context 7
1074  48E7  8200        2371* CXout   movem.l D0/D6,-(SP)     ;save regiser
1078  1039  0084  0003  2372*         move.b  CtxReg.l,D0     ;get data
107E  4BFA  0062+       2373*         lea     msgSegment,A5
1082  0800  0005        2374*         btst    #segbit,D0      ;is bit set?
1086  6604              2375*         bon.s   CXout1          ;yes, branch
1088  4BFA  0062+       2376*         lea     msgPage,A5      ;get page mess
108C  6100  0FEA        2377* CXout1  bsr     DSoutst
1090  4BFA  0061+       2378*         lea     msgUser,A5
1094  0800  0004        2379*         btst    #SUMbit,D0      ;is bit set?
1098  6604              2380*         bon.s   CXout2          ;yes, branch
109A  4BFA  005D+       2381*         lea     msgSuper,A5     ;get proper message
109E  6100  0FD8        2382* CXout2  bsr     DSoutst         ;output it
10A2  4BFA  0061+       2383*         lea     msgLowmap,A5    ;default message
10A6  0800  0006        2384*         btst    #SLMbit,D0      ;is bit set?
10AA  6604              2385*         bon.s   CXout3          ;yes, branch
10AC  4BFA  0060+       2386*         lea     msgHimap,A5     ;get proper message
10B0  6100  0FC6        2387* CXout3  bsr     DSoutst         ;output it
10B4  4BFA  1E2B+       2388*         lea     msgcontext,A5   ;say context
10B8  6100  0FBE        2389*         bsr     DSoutst         ;*
10BC  0200  000F        2390*         andi.b  #$F,D0          ;clear upper nibble
10C0  7C00              2391*         moveq   #0,D6           ;clear register for nibble
10C2  6100  F3FC        2392*         bsr     outhex          ;output a nibble
10C6  6100  0FCE        2393*         bsr     DSoutCR         ;carriage return
10CA  4CDF  0041        2394*         movem.l (SP)+,D0/D6     ;restore registers
10CE  4E75              2395*         RTS
                        2396* ;messages
10D0  0D 54657374696E67 2397* msgmapram  data.b DSCcr,'Testing Map Rams',0
10D8  204D61702052616D
10E0  7300 
10E2  0D 5365676D656E74 2398* msgsegment data.b DSCcr,'Segment ',0
10EA  2000 
10EC  0D 506167652000   2399* msgpage    data.b DSCcr,'Page ',0
10F3  557365722000      2400* msguser    data.b 'User ',0
10F9  5375706572766973  2401* msgsuper   data.b 'Supervisor ',0
File: C1.MAIN.TEXT                                                Page  57


1101  6F722000 
1105  4C6F77204D617020  2402* msglowmap  data.b 'Low Map ',0
110D  00 
110E  48696768204D6170  2403* msghimap   data.b 'High Map ',0
1116  2000 
1118  0D 4D617070696E67 2404* MsgMapping data.b DSCcr,'Mapping Transparent',0
1120  205472616E737061
1128  72656E7400 
112D  0D 5365676D656E74 2405* Msgsmaperr data.b DSCcr,'Segment Map Error @ Segment#',0
1135  204D617020457272
113D  6F72204020536567
1145  6D656E742300 
114B  0D 50616765204D61 2406* Msgpmaperr data.b DSCcr,'Page Map Error @ Page#',0
1153  70204572726F7220
115B  4020506167652300 
1163  446F6E650D 00     2407* MsgDone    data.b 'Done',DscCr,0
                        2408* ;
1169  0D 4D41502052414D 2409* msgMapmenu data.b DSCcr,'MAP RAM TESTS'
1171  205445535453
1177  0D 302D4465627567 2410*            data.b DSCcr,'0-Debugger'
117F  676572
1182  0D 312D5465737420 2411*            data.b DSCcr,'1-Test Segment'
118A  5365676D656E74
1191  0D 322D5465737420 2412*            data.b DSCcr,'2-Test Page'
1199  50616765
119D  0D 332D4D61702054 2413*            data.b DSCcr,'3-Map Transparent'
11A5  72616E7370617265
11AD  6E74
11AF  0D 342D52756E2031 2414*            data.b DSCcr,'4-Run 1-3'
11B7  2D33
11B9  0D 352D446973706C 2415*            data.b DSCcr,'5-Display Segments'
11C1  6179205365676D65
11C9  6E7473
11CC  0D 362D446973706C 2416*            data.b DSCcr,'6-Display Pages'
11D4  6179205061676573
11DC  00                2417*            data.b 0
11DD                    2418* mmendlbl
                        2419* 
File: C1.MAIN.TEXT                                                Page  58


                        2421*         include 'SIV.DRAM'
                        2422* ;
11DE  4BFA  03F1+       2423* DRMenu  lea     msgdrmenu,A5    ;display menu
11E2  6100  0E94        2424*         bsr     DSoutST
11E6  0839  0004  0080  2425*         btst    #TranBit,SysFlag.l
11EC  0D64  
11EE  6604              2426*         bne.s   DRTPrmt
11F0  6100  F944        2427*         bsr     MapTran
11F4  6100  0EA0        2428* DRTPrmt bsr     DSoutCr         ;display a return
11F8  103C  002D        2429*         move.b  #Prompt3,D0         ;prompt for test menu
11FC  6100  F08C        2430*         bsr     MenuKey         ;get response from user
1200  487A  FFF2+       2431*         pea     DRTPrmt         ;return to prompt
1204  41BC  0008        2432*         chk     #8,D0         ;*
1208  E300              2433*         asl.b   #1,d0              ;double for table
120A  303B  0006+       2434*         move.w  DRTtbl(D0.W),D0
120E  4EFB  0002+       2435*         jmp     DRTtbl(D0.W)
                        2436* ;
1212                    2437* DRTtbl
1212  F0DE              2438*         data.w  dragon-DRTtbl
1214  0068              2439*         data.w  Walktst-DrtTbl
1216  00E4              2440*         data.w  Martst-DRTtbl
1218  0174              2441*         data.w  inctst-drttbl
121A  0218              2442*         data.w  rdmtest-drttbl
121C  0036              2443*         data.w  DRall1-DRTtbl
121E  0012              2444*         data.w  SelCtx-DRTtbl
1220  02A4              2445*         data.w  Fsttst-DRTtbl
1222  0258              2446*         data.w  Rdmloop-DRTtbl
                        2447* ;
                        2448* ;patchwork routine -- needs to bew fixed
1224  4BFA  1CBA+       2449* SelCtx  lea     msgctxreg,A5
1228  6100  0E4E        2450*         bsr     DSoutst
122C  6100  1458        2451*         bsr     kbgetUC
1230  907C  0030        2452*         sub     #'0',D0
1234  6B00  F110        2453*         bmi     unkcmd           ;context between 0 and 15
1238  B03C  0046        2454*         cmp.b   #'F',D0
123C  6E00  F108        2455*         bgt     unkcmd
1240  13C0  0084  0003  2456*         move.b  D0,CtxReg.l
1246  4E75              2457*         RTS
1248  6130              2458* DRall1  bsr.s   walktst
124A  661A              2459*         bne.s   DREXIT
124C  6100  00A8        2460*         bsr     martst
1250  6614              2461*         bne.s   DREXIT
1252  6100  0132        2462*         bsr     inctst
1256  660E              2463*         bne.s   DREXIT
1258  6100  01D0        2464*         bsr     rdmtest
125C  6608              2465*         bne.s   DRexit
125E  4BFA  1D82+       2466*         lea     msgpass,A5
1262  6100  0E14        2467*         bsr     DSoutst
1266  4E75              2468* DREXIT  rts
1268                    2469* UsrTst
1268  2A7C  0080  0C00  2470*         movea.l #ustack,a5     ;initial user stack pointer
126E  4E65              2471*         move.l  a5,usp          ;*
1270  46FC  0700        2472*         move.w  #$0700,Sr       ;enter user mode
1274  61D2              2473*         bsr.s   DRall1          ;run ram tests
File: C1.MAIN.TEXT                                                Page  59


1276  4E40              2474*         trap    #0              ;return to supervisor state
1278  4E75              2475*         RTS
File: C1.MAIN.TEXT                                                Page  60


                        2477* ;
127A  4BFA  0322+       2478* walktst lea     msgwalk,A5      ;output walking..
127E  6100  0DF8        2479*         bsr     DSoutst         ;*
1282  2E3C  0010  0000  2480*         move.l  #onemeg,D7      ;bank incrementer is one megabyte
1288  3A07              2481*         move.w  D7,D5           ;tricky way to clear d5
128A  1A39  0080  0D65  2482*         move.b  MemSz.l,D5      ;get size(1-4)or84 if 64k rams
1290  6A0A              2483*         bpl.s   wt1             ;if pos then 256k rams
1292  2E3C  0004  0000  2484*         move.l  #$40000,D7      ;bank incrementer is 40000 for 64k rams
1298  0885  0007        2485*         bclr    #7,D5           ;make pos
129C  41F8  0000        2486* WT1     lea     DRbase.w,A0     ;get first location
12A0  5305              2487*         subq.b  #1,D5           ;set counter
12A2  6100  F30E        2488* WTloop  bsr     outdot
12A6  4DFA  002C+       2489*         lea     walkbit,A6      ;do it
12AA  6100  F314        2490*         bsr     ExecTst
12AE  6610              2491*         bne.s   WTerror
12B0  D1C7              2492* WTloop1 adda.l  D7,A0
12B2  51CD  FFEE        2493*         dbra    D5,WTloop
12B6  0839  0003  0080  2494*         btst    #DRambit,TSTstat.l
12BC  0DB6  
12BE  4E75              2495*         RTS
                        2496* ;
12C0  08F9  0003  0080  2497* WTerror bset    #Drambit,TstStat.l
12C6  0DB6  
12C8  6100  F286        2498*         bsr     miscmpl
12CC  6100  F2C6        2499*         bsr     optcont
12D0  67DE              2500*         beq.s   WTloop1         ;exit error routine
12D2  4E75              2501*         RTS
                        2502* ;
                        2503* ;walkbit test--data verification for rams
                        2504* ;              Walks a zero in ones and one in zeroes for a long word
                        2505* ;               ENTER  : A0-start address
                        2506* ;               EXIT   : A2-Failing address
                        2507* ;                        D0-Data expected
                        2508* ;                        D1-Data Read
                        2509* ;                        EQ-Pass
                        2510* ;                        NE-Fail
                        2511* ;
12D4  2448              2512* walkbit move.l  a0,a2           ;get starting address to pointer
12D6  70FE              2513* WB1     moveq   #$-2,d0         ;walk a zero in field of ones
12D8  2480              2514* WB2     move.l  d0,(a2)         ;write data
12DA  2212              2515*         move.l  (a2),d1         ;read it back
12DC  B081              2516*         cmp.l   d1,d0           ;Is data Ok?
12DE  6614              2517*         bne.s   WBend           ;No, go to error routine
12E0  E398              2518*         rol.l   #1,d0           ;Yes, rotate data
12E2  65F4              2519*         bcs.s   WB2             ;
12E4  7001              2520*         moveq   #$1,d0          ;walk a one in a field of zeroes
12E6  2480              2521* WB3     move.l  d0,(a2)         ;write data
12E8  2212              2522*         move.l  (a2),d1         ;read it back
12EA  B081              2523*         cmp.l   d1,d0           ;Is data Ok?
12EC  6606              2524*         bne.s   WBend           ;No, go to error routine
12EE  E380              2525*         asl.l   #1,d0              ;Yes, rotate data
12F0  64F4              2526*         bcc.s   WB3             ;Continue if not done
12F2  B040              2527*         cmp     D0,D0           ;force an eq
12F4  4E75              2528* WBend   RTS
File: C1.MAIN.TEXT                                                Page  61


12F6  4BFA  02AF+       2530* MarTst  lea     msgmarch,A5     ;message marching
12FA  6100  0D7C        2531*         bsr     DSoutst         ;*
12FE  41F8  0000        2532*         lea     DRbase.w,A0     ;Get start address
1302  2039  0080  0D66  2533*         move.l  Curmem.l,D0     ;get number of bytes
1308  E288              2534*         lsr.l   #1,D0           ;divide by two for words
130A  6100  01FC        2535*         bsr     GetCntR         ;get counters in D5&D6
130E  4DFA  0020+       2536*         lea     march,A6
1312  6100  F2AC        2537*         bsr     ExecTst
1316  6602              2538*         bne.s   MTerror         ;fails output data
1318  4E75              2539* MTexit  RTS
131A  08F9  0003  0080  2540* MTerror Bset    #drambit,TstStat.l
1320  0DB6  
1322  6100  F236        2541*         bsr     miscmpw
1326  0839  0003  0080  2542*         btst    #drambit,TstStat.l
132C  0DB6  
132E  60E8              2543*         bra.s   MTexit
                        2544* ;March -- verify each address location is unique and can hold zeroes and ones
                        2545* ;       Enter A0:Start addr D5,D6 loop counters
                        2546* ;       Exit as walkbit
1330  2448              2547* March   move.l  a0,a2           ;
1332  7000              2548*         moveq   #0,d0              ;
1334  48A7  0600        2549*         movem.w D5-D6,-(SP)     ;save counters
1338  34C0              2550* MR1     move.w  d0,(a2)+        ;Fill memory with zeroes
133A  51CD  FFFC        2551*         dbra    D5,MR1          ;at end of ram?
133E  51CE  FFF8        2552*         dbra    D6,Mr1          ;no, branch
1342  3A17              2553*         move.w  (SP),D5         ;get register d5 back from stack
1344  2C17              2554*         move.l  (SP),D6         ;get d6 back from stack
1346  3400              2555*         move.w  d0,d2           ;d0=0
1348  4642              2556*         not.w   d2              ;d2=ff
134A  3222              2557* MR2     move.w  -(a2),d1         ;read data
134C  B240              2558*         cmp.w   d0,d1           ;Is it a zero?
134E  6630              2559*         bne.s   MRend           ;exit with ne
1350  3482              2560*         move.w  d2,(a2)         ;Write ones
1352  51CD  FFF6        2561*         dbra    D5,mr2
1356  6100  F25A        2562*         bsr     outdot          ;display a period
135A  51CE  FFEE        2563*         dbra    D6,MR2
135E  3A17              2564*         move.w  (SP),D5         ;get register d5 back from stack
1360  2C17              2565*         move.l  (SP),D6         ;get d6 back from stack
1362  3002              2566*         move.w  d2,d0           ;d0 is ones
1364  4642              2567*         not.w   d2              ;d2 is zeroes
1366  3212              2568* MR3     move.w  (a2),d1         ;Read data
1368  B240              2569*         cmp.w   d0,d1           ;Is it all ones?
136A  6614              2570*         bne.s   MRend           ;No exit with ne
136C  34C2              2571*         move.w  d2,(a2)+        ;write zeroes
136E  51CD  FFF6        2572*         dbra    D5,MR3
1372  13FC  005E  0083  2573*         move.b  #'^',DC0Data.l  ;marching up memory
1378  0317  
137A  51CE  FFEA        2574*         dbra    D6,MR3
137E  B000              2575*         cmp.b   D0,D0           ;force an eq
1380  4C9F  0060        2576* MRend   movem.w (SP)+,D5-D6     ;restore registers
1384  4E75              2577*         RTS
File: C1.MAIN.TEXT                                                Page  62


                        2579* ;
1386  4BFA  0229+       2580* IncTst  lea     msginc,A5
138A  6100  0CEC        2581*         bsr     DSoutst
138E  41F8  0000        2582*         lea     DRbase.w,A0
1392  2039  0080  0D66  2583*         move.l  Curmem.l,D0
1398  E288              2584*         lsr.l   #1,D0
139A  6100  016C        2585*         bsr     GetCntR
139E  4DFA  0020+       2586*         lea     Inc,A6
13A2  6100  F21C        2587*         bsr     ExecTst
13A6  6602              2588*         bne.s   ITerror
13A8  4E75              2589* ITexit  RTS
13AA  08F9  0003  0080  2590* ITerror Bset    #drambit,TstStat.l
13B0  0DB6  
13B2  6100  F1A6        2591*         bsr     miscmpw
13B6  0839  0003  0080  2592*         btst    #drambit,TstStat.l
13BC  0DB6  
13BE  60E8              2593*         bra.s   ITexit
                        2594* ;
                        2595* ; Incrementing refresh test
                        2596* ; Enter A0-start address
                        2597* ;       A1 last address
13C0                    2598* Inc
13C0  48A7  0600        2599*         movem.w D5/D6,-(SP)     ;save loop counter
13C4  2448              2600*         move.l  a0,a2           ;move it  to pointer
13C6  303C  0102        2601* IT00    move.w  #$102,d0        ;initial write data
13CA  34C0              2602* IT01    move.w  d0,(a2)+        ;write data and  increment address
13CC  E358              2603*         rol.w   #1,d0           ;shift data
13CE  51CD  FFFA        2604*         dbra    D5,IT01         ;loop
13D2  13FC  002E  0083  2605*         move.b  #'.',DC0Data.l  ;display a period every 64k on writes
13D8  0317  
13DA  51CE  FFEE        2606*         dbra    D6,IT01         ;until done
13DE  6132              2607*         bsr.s   delay
13E0  6130              2608*         bsr.s   delay
13E2  3A17              2609*         move.w  (SP),D5
13E4  2C17              2610*         move.l  (sp),D6         ;restore register
13E6  2448              2611*         move.l  a0,a2           ;yes, put pointer back to start address
13E8  303C  0102        2612*         move.w  #$102,d0        ;get initial write data
13EC  321A              2613* IT02    move.w  (a2)+,d1        ;read the data
13EE  B041              2614*         cmp.w   d1,d0           ;valid?
13F0  661A              2615*         bne.s   ITerr           ;no go to  error  routine
13F2  E358              2616*         rol.w   #1,d0           ;shift data
13F4  51CD  FFF6        2617*         dbra    D5,it02
13F8  13FC  002D  0083  2618*         move.b  #'-',DC0Data.l
13FE  0317  
1400  51CE  FFEA        2619*         dbra    D6,it02
1404  B000              2620*         cmp.b   D0,D0           ;force an eq
1406  4C9F  0060        2621* ITend   movem.w (SP)+,D5/D6
140A  4E75              2622*         RTS
140C  4A62              2623* iterr   tst.w   -(A2)           ;make a2 the right value
140E  7AFF              2624*         moveq   #-1,D5          ;force an Ne
1410  60F4              2625*         bra.s   ITend
                        2626* ;loop 10times64000 to cause a wait
1412  48E7  C000        2627* delay movem.l D0-D1,-(SP)     ;save register
1416  72FF              2628*         moveq   #-1,D1          ;move 65536 to d1
File: C1.MAIN.TEXT                                                Page  63


1418  303C  0010        2629*         move.w  #$10,d0
141C  51C9  FFFE        2630* dly   dbra    D1,dly
1420  51C8  FFFA        2631*         dbra    D0,dly
1424  4CDF  0003        2632*         movem.l (SP)+,D0-D1     ;restore
1428  4E75              2633*         RTS
File: C1.MAIN.TEXT                                                Page  64


                        2635* ;
      00123456          2636* seed    equ     $123456
142A  4BFA  0193+       2637* RdmTest lea     msgrdm,A5
142E  6100  0C48        2638*         bsr     DSoutst
1432  611E              2639*         bsr.s   RdmInit         ;initialize registers for RandomData test
1434  6100  F18A        2640*         bsr     ExecTst
1438  6602              2641*         bne.s   RTerror
143A  4E75              2642* RTexit  RTS
143C  08F9  0003  0080  2643* RTerror Bset    #drambit,TstStat.l
1442  0DB6  
1444  6100  F10A        2644*         bsr     miscmpl
1448  0839  0003  0080  2645*         btst    #drambit,TstStat.l
144E  0DB6  
1450  60E8              2646*         bra.s   RTexit
                        2647* ;
1452  41F8  0000        2648* RdmInit lea     DRbase.w,A0     ;start address
1456  2279  0080  0D66  2649*         move.l  Curmem.l,A1     ;end address
145C  263C  0012  3456  2650*         move.l  #seed,D3
1462  4284              2651*         clr.l   d4              ;zero complement register
1464  4DFA  001A+       2652*         lea     rdmtst,A6
1468  4E75              2653*         RTS
146A  61E6              2654* RDMloop bsr.s   RdmInit         ;get initial registers
146C  6000  00A8        2655*         bra     Execlp          ;execute loop mode tests
                        2656* ;Get Random number--enter D2--curent seed
                        2657* ;                   Exit  D0-random D2 next seed
1470  E38A              2658* GetRdm  lsl.l   #1,D2           ;multiply by 2
1472  0802  001E        2659*         btst    #30,D2          ;test this bit
1476  6704              2660*         boff.s  GetRdmX         ;zero--branch
1478  0A42  0053        2661*         eori.w  #$53,D2         ;exclusive or with 0101 0011 bit pattern
147C  2002              2662* GetRdmX move.l  D2,D0           ;use d0 as next write data d2 will be seed
147E  4E75              2663*         RTS
                        2664* ;
1480  2448              2665* RdmTst  movea.l A0,A2           ;get start address into pointer register
1482  2403              2666*         move.l  D3,D2           ;get the latest seed
1484  61EA              2667* RdmTst1 bsr.s   GetRdm          ;get random number into write register
1486  B980              2668*         eor.l   D4,D0           ;complement if required
1488  24C0              2669*         move.l  D0,(A2)+        ;write to memory and increment
148A  B5C9              2670*         cmpa.l  A1,A2           ;A2-A1 are we at end?
148C  6BF6              2671*         bmi.s   RdmTst1         ;if negative result then no
148E  2448              2672*         movea.l A0,A2           ;restore A2
1490  2403              2673*         move.l  D3,D2           ;restore d2
1492  61DC              2674* RdmTst2 bsr.s   GetRdm          ;get random number
1494  B980              2675*         eor.l   D4,D0           ;complement if required
1496  221A              2676*         move.l  (A2)+,D1        ;read data
1498  B280              2677*         cmp.l   D0,D1           ;compare
149A  6614              2678*         bne.s   RdmTstE         ;oh-no!
149C  B5C9              2679*         cmpa.l  A1,A2           ;loop until A2-a1 is non negative
149E  6BF2              2680*         bmi.s   RdmTst2         ;*
14A0  4684              2681*         not.l   D4              ;complement complement register
14A2  670A              2682*         beq.s   RdmTstX         ;finished
14A4  6100  F10C        2683*         bsr     outdot          ;print a period
14A8  60D6              2684*         bra.s   RdmTst          ;loop
14AA  2602              2685*         move.l  D2,D3           ;update seed
14AC  B000              2686*         cmp.b   D0,D0           ;force an eq
File: C1.MAIN.TEXT                                                Page  65


14AE  4E75              2687* RdmTstX RTS
14B0  4AA2              2688* RdmTstE Tst.l   -(A2)           ;adjust the address pointer
14B2  7AFF              2689*         moveq   #-1,D5          ;force an ne
14B4  60F8              2690*         bra.s   RDMtstX         ;exit
                        2691* ;FstTst
14B6  47FA  0018+       2692* FstTst  lea     Fast,A3
14BA  49FA  005A+       2693*         lea     endoftest,A4
14BE  4BF8  0000        2694*         lea     DRbase.w,A5
14C2  3ADB              2695* FSTlp   move    (A3)+,(A5)+
14C4  B7CC              2696*         cmpa.l  A4,A3
14C6  6FFA              2697*         ble.s   FSTlp
14C8  4DF8  0000        2698*         lea     DrBase.w,A6
14CC  6000  0048        2699*         bra     ExecLp
                        2700* ;
14D0  41F9  0001  0000  2701* Fast    lea     SegOFst.l,A0
                        2702* ;Next line figure out the counters so loop mode counts through memory properly
14D6  2039  0080  0D66  2703*         move.l  curmem.l,D0     ;get current boards memory size in bytes
14DC  9088              2704*         sub.l   A0,D0           ;adjust to skip first segment
14DE  E488              2705*         lsr.l   #2,D0           ;divide by 4 for number of long words
14E0  6126              2706* FastLp0 bsr.s   GetCntR         ;translate D0 into loop counters D5&D6
14E2  20C8              2707* FastLp1 move.l  A0,(A0)+        ;write
14E4  51CD  FFFC        2708*         dbra    D5,Fastlp1      ;loop-Loop mode is active
14E8  51CE  FFF8        2709*         dbra    d6,Fastlp1      ;loop
14EC  45F9  0001  0000  2710*         lea     SegOfst.l,A2    ;get start of test
14F2  6114              2711*         bsr.s   GetCntR         ;get values for D5&D6 from d0
14F4  2212              2712* Fastlp2 move.l  (A2),D1        ;check value
14F6  6702              2713*         beq.s   FastLp3         ;passes continue
14F8  200A              2714*         move.l  A2,D0           ;get expected data in D0
14FA  4A9A              2715* Fastlp3 Tst.l   (A2)+           ;increment address
14FC  51CD  FFF6        2716*         dbra    D5,Fastlp2      ;loop
1500  51CE  FFF2        2717*         dbra    D6,Fastlp2      ;loop
1504  B040              2718*         cmp     d0,d0           ;force an eq
1506  4E75              2719* FastErr RTS
1508  7C00              2720* GetCntR moveq   #0,D6           ;zero register
150A  2A00              2721*         move.l  D0,D5           ;save count in d5
150C  6706              2722*         beq.s   GetCntx         ;branch if zero
150E  5385              2723*         subq.l  #1,D5           ;decrement by 1
1510  2C05              2724*         move.l  D5,D6
1512  4846              2725*         swap    D6
1514  4E75              2726* Getcntx RTS
1516                    2727* endoftest
1516  4BF9  0080  0DA2  2728* ExecLp  lea     loopctr.l,A5    ;get loop counter pointer
151C  7A04              2729*         moveq   #4,D5           ;we're going to clear 5 variables
151E  429D              2730* Loopclr clr.l   (A5)+           ;clear variable
1520  51CD  FFFC        2731*         dbra    D5,Loopclr      ;loop 5 times
                        2732* ;We have now initialized the loop variables-next the loop itself
1524  52B9  0080  0DA2  2733* TstLoop addq.l  #1,loopctr.l    ;add to the loop counter
152A  6100  F094        2734*         bsr     ExecTst         ;execute the test pointed to by a6
152E  6716              2735*         beq.s   loop1           ;passed continue
1530  52B9  0080  0DA6  2736*         addq.l  #1,Errctr.l     ;increment error counter
1536  4BF9  0080  0DB6  2737*         lea     TstStat.l,A5    ;get ready to save errors
153C  48E5  C020        2738*         movem.l D0-D1/A2,-(A5)  ;save registers
1540  103C  002A        2739*         move.b  #'*',D0         ;get character for error
1544  6004              2740*         bra.s   loop2           ;branch
File: C1.MAIN.TEXT                                                Page  66


1546  103C  002E        2741* loop1   move.b  #'.',D0         ;character for pass
154A  6100  0B56        2742* loop2   bsr     DSoutch         ;display character
154E  0839  0000  0083  2743*         btst    #KBrdbit,DC0Stat.l;is there a keypress?
1554  0313  
1556  67CC              2744*         boff.s  TstLoop         ;no continue looping
1558  1E39  0083  0317  2745*         move.b  DC0Data.l,d7    ;clear uart
155E  7C04              2746*         moveq   #4,D6           ;display longwords
1560  4BFA  1A78+       2747*         lea     msgTotal,A5     ;say total
1564  6100  0B12        2748*         bsr     DSoutst
1568  49F9  0080  0DA2  2749*         lea     loopctr.l,A4      ;get loop counter pointer
156E  201C              2750*         move.l  (A4)+,D0         ;read counter and increment pointer to errctr
1570  6100  EF4E        2751*         bsr     outhex          ;display
1574  4BFA  1A6C+       2752*         lea     msgpass,A5      ;say pass
1578  6100  0AFE        2753*         bsr     DSoutst
157C  9094              2754*         sub.l   (A4),D0         ;get number pass from total-error
157E  6100  EF40        2755*         bsr     outhex          ;show it
1582  4BFA  1A65+       2756*         lea     msglfail,A5     ;say error
1586  6100  0AF0        2757*         bsr     DSoutst         ;*
158A  201C              2758*         move.l  (A4)+,D0         ;get errors and point to fail registers
158C  6100  EF32        2759*         bsr     outhex
1590  4A80              2760*         tst.l   D0              ;were there any errors
1592  6708              2761*         beq.s   loopxit        ;end if no errors
1594  4CDC  0403        2762*         movem.l (A4)+,D0-D1/A2  ;get error registers
1598  6100  EFB6        2763*         bsr     miscmpl         ;display failing registers
159C  4E75              2764* loopxit RTS
159E  0D 57616C6B696E67 2765* msgwalk data.b  DSCcr,'Walking',0
15A6  00 
15A7  0D 4D61726368696E 2766* msgmarch data.b DSCcr,'Marching',0
15AF  6700 
15B1  0D 496E6372656D65 2767* msginc  data.b  DSCcr,'Incrementing',0
15B9  6E74696E6700 
15BF  0D 52616E646F6D20 2768* msgrdm  data.b  DSCcr,'Random data test',0
15C7  6461746120746573
15CF  7400 
15D1                    2769* dramdramdram
                        2770* 
                        2771* ;
15D1  0D 44594E414D4943 2772* msgDRmenu  data.b DSCcr,'DYNAMIC RAM TESTS'
15D9  2052414D20544553
15E1  5453
15E3  0D 302D447261676F 2773*            data.b DSCcr,'0-Dragonfly'
15EB  6E666C79
15EF  0D 312D57616C6B   2774*            data.b DSCcr,'1-Walk'
15F6  0D 322D4D61726368 2775*            data.b DSCcr,'2-March'
15FE  0D 332D496E637265 2776*            data.b DSCcr,'3-Increment'
1606  6D656E74
160A  0D 342D52616E646F 2777*            data.b DSCcr,'4-Random  data'
1612  6D202064617461
1619  0D 352D52756E2031 2778*            data.b DSCcr,'5-Run 1-4'
1621  2D34
1623  0D 362D53656C6563 2779*            data.b DSCcr,'6-Select Context'
162B  7420436F6E746578
1633  74
1634  0D 372D52756E2046 2780*            data.b DSCcr,'7-Run Fast Mode'
File: C1.MAIN.TEXT                                                Page  67


163C  617374204D6F6465
1644  0D 382D6C6F6F7020 2781*            data.b DSCcr,'8-loop Random'
164C  52616E646F6D
1652  00                2782*            data.b 0
                        2783* 
File: C1.MAIN.TEXT                                                Page  68


                        2785*         include 'SIV.PROT'
                        2786* ;
                        2787* ;Error Test menu
                        2788* ;
1654  4BFA  037F+       2789* ERRmenu lea     msgerrmenu,A5    ;display menu
1658  6100  0A1E        2790*         bsr     DSoutST
165C  6100  0A38        2791* ERRprmt bsr     DSoutCr
1660  103C  0024        2792*         move.b  #Prompt4,D0         ;prompt for test menu
1664  6100  EC24        2793*         bsr     MenuKey         ;get response from user
1668  4A39  0084  0005  2794*         tst.b   ErrReg.l        ;is error register set
166E  6704              2795*         beq.s   Errtst2         ;no, continue
1670  6100  F3D0        2796*         bsr     SetER           ;yes,- display and ask to clear
1674  487A  FFE6+       2797* ErrTst2 pea     ERRPrmt         ;return to prompt
1678  23CF  0080  0D9E  2798*         move.l  A7,ETstack.l    ;save stack pointer
167E  41BC  0003        2799*         chk     #3,D0         ;*
1682  E300              2800*         asl.b   #1,d0              ;double for table
1684  303B  0006+       2801*         move.w  ERRtbl(D0.W),D0
1688  4EFB  0002+       2802*         jmp     ERRtbl(D0)
                        2803* ;
168C  EC64              2804* ERRtbl  data.w  dragon-Errtbl
168E  0066              2805*         data.w  SegErrtst-ERRTbl
1690  0164              2806*         data.w  PagErrtst-ERRTbl
1692  0008              2807*         data.w  AllErrtst-ERRTbl
                        2808* 
1694                    2809* AllErrTst
1694  23CF  0080  0D9E  2810*         move.l  A7,ETstack.l
169A  4BFA  028F+       2811*         lea     msgProtect,A5
169E  6100  09D8        2812*         bsr     DSoutst
16A2  47F9  0084  0003  2813*         lea     CtxReg.l,A3     ;point to context register
16A8  422B  0002        2814*         clr.b   2(A3)           ;clear error register
16AC  45F9  0040  0000  2815*         lea     MapBase.l,A2    ;use high map addressing
16B2  613E              2816*         bsr.s   SegErrTst
16B4  660E              2817*         bne.s   AETend
16B6  6100  0138        2818*         bsr     pagerrtst
16BA  6608              2819*         bne.s   AETend
16BC  4BFA  1924+       2820*         lea     msgpass,A5
16C0  6100  09B6        2821*         bsr     DSoutst
16C4  4E75              2822* AETend  RTS
                        2823* ;
                        2824* ; Return from expected bus error test
                        2825* ;       ENTER: D0 is the value of the bus error flag 1-pageop 2 segop
                        2826* ;              A3: context reg
16C6  4BF9  0080  0D9E  2827* ETBErtn lea     ETstack.l,A5    ;get stack pointer for error tests
16CC  2E55              2828*         movea.l (A5),A7         ;get contents of location
16CE  5340              2829*         subq    #1,D0           ;set d0 to 0 for page 1 for seg
16D0  1C2B  0002        2830*         move.b  2(A3),D6        ;read error register  (ctx reg +2)
16D4  6710              2831*         beq.s   BADerrReg       ;no error recorded
16D6  0106              2832*         btst    D0,D6           ;should be set
16D8  670C              2833*         beq.s   BADerrReg       ;
16DA  1740  0002        2834*         move.b  D0,2(A3)        ;any write is a clear
16DE  6700  0184        2835*         beq     PETret          ;if d0 was zero then page
16E2  6000  00AE        2836*         bra     SETret          ;else segment
                        2837* ;Report Error register not proper--stack must be set up right
16E6                    2838* BaderrReg
File: C1.MAIN.TEXT                                                Page  69


16E6  4BFA  0222+       2839*         lea     msgERzero,A5
16EA  6100  098C        2840*         bsr     DSoutst
16EE  6000  EBC0        2841*         bra     mainmenu
                        2842* ;Segment Error  Test - Set up for and test segment error circuitry
                        2843* ;       a3=ctx reg A2=$400000
16F2                    2844* SegErrTst
16F2  13FC  0002  0080  2845*         move.b  #SETop,BEflag.l ;set bus error flag for Segment Error Tests
16F8  0D94  
16FA  0839  0004  0080  2846*         btst    #tranbit,SysFlag.l     ;make sure transparent
1700  0D64  
1702  6604              2847*         bon.s   SET1                   ;yes,branch
1704  6100  F430        2848*         bsr     MapTran         ;map transparent
                        2849* ; Include in here a routine that moves executable code to page
                        2850* ; zero for the execute violation check.
1708                    2851* SET1    ;
1708  47F9  0084  0003  2852*         lea     CtxReg.l,A3     ;point to context register
170E  45F9  0040  0000  2853*         lea     MapBase.l,A2    ;use high map addressing
1714  49FA  00A8+       2854*         lea     Xtest,A4
1718  4BFA  00AE+       2855*         lea     XTend,A5
171C  4DF9  0040  0004  2856*         lea     $400004.l,A6
1722  3CDC              2857* LoadX   move.w  (A4)+,(A6)+
1724  BBCC              2858*         cmpa.l  A4,A5
1726  66FA              2859*         bne.s   loadx
                        2860* ; Get the count for the number of segments on the current board
1728  2A39  0080  0D66  2861*         move.l  curmem.l,D5     ;get current board size
172E  4845              2862*         swap    D5              ;same as divide by 64k
1730  5345              2863*         subq    #1,D5           ;adjust for dbra
                        2864* ;D4 is used for multiple purposes. It selects and deselcts
                        2865* ;allow write,read and execute(bit 2,1,0) is used by dbra
                        2866* ;for the number of tests per segment, and as the index into
                        2867* ;the test table
1732  7802              2868* SETnext moveq   #2,D4           ;initailize
1734  0013  00A0        2869*         ori.b   #SMsupHi,(A3)   ;select segment map high
1738  3E12              2870*         move.w  (A2),D7         ;save current segment data
173A  0252  0F00        2871*         andi.w  #$F00,(A2)      ;point to page 0 for execute test
173E  0992              2872* SETsel  bclr    D4,(A2)         ;deselect current test access
1740  0213  000F        2873*         andi.b  #$F,(A3)        ;select ram access in current context
1744  7000              2874*         moveq   #0,D0           ;zero reg
1746  103B  4006+       2875*         move.b  SETtbl(D4.w),D0 ;get offset
174A  4EFB  0002+       2876*         jmp     SETtbl(D0)      ;execute test
                        2877* ;
174E  0C                2878* SETtbl  data.b  SegXtst-SetTbl  ;offset to segment write test
174F  08                2879*         data.b  SegRtst-SetTbl  ;offset to segment read test
1750  04                2880*         data.b  SegWtst-SetTbl  ;offset to segment execute test
1751  00                2881*         data.b  0
1752  2484              2882* SegWtst move.l  D4,(A2)         ;write-put error in register then BE
1754  600A              2883*         bra.s   SETerr          ;should not get here
1756  4A92              2884* SegRtst tst.l   (A2)            ;read-put error in register then BE
1758  6006              2885*         bra.s   SETerr          ;error if we get here
175A  2C4A              2886* SegXtst movea.l A2,A6        ;address of start of execute only test
175C  4EEE  0004        2887*         jmp     4(A6)            ;go to it
                        2888* ;
                        2889* ;Routine to handle segment error tests which don't force bus errors
                        2890* ;
File: C1.MAIN.TEXT                                                Page  70


1760  7000              2891* SetErr  moveq   #0,D0
1762  4BFA  01F6+       2892*         lea     SETmoff,A5   ;get address of error message
1766  1035  4000        2893*         move.b  0(A5,d4),D0       ;get offset
176A  4BFA  01DB+       2894*         lea     SetMsg0,A5
176E  DBC0              2895*         adda.l  D0,A5
1770  6100  0906        2896*         bsr     DSoutSt
1774  4BFA  01E7+       2897* SETErr1 lea     msgErrSeg,A5    ;'Error Segment: '
1778  6100  08FE        2898*         bsr     DSoutSt
177C  200A              2899*         move.l  A2,D0           ;get address
177E  4840              2900*         swap    D0              ;get upper word
1780  C03C  003F        2901*         and.b   #$3F,D0         ;clear high map bit
1784  7C01              2902*         moveq   #1,D6           ;output 1 byte
1786  6100  ED38        2903*         bsr     outhex          ;*
178A  6100  EE08        2904*         bsr     OptCont         ;
178E  6702              2905* SetErrX beq.s   SetRet           ;yes, continue
1790  4E75              2906*         RTS
                        2907* ;
                        2908* ;Return here if bus error occurred properly
                        2909* ;Restores data to segment and
1792                    2910* SETret
1792  1740  0002        2911*         move.b  D0,2(A3)        ;any write clears register
1796  0013  00A0        2912*         ori.b   #SMsupHi,(A3)   ;select segment map high
179A  09D2              2913*         bset    D4,(A2)         ;reset bit previously cleared
179C  51CC  FFA0        2914*         dbra    D4,SetSel       ;loop through tests ineach segment
17A0  3487              2915*         move.w  D7,(A2)         ;restore original value to segment
17A2  D5FC  0001  0000  2916*         adda.l  #SegOfst,A2      ;point to next segment
17A8  6100  EE08        2917*         bsr     outdot          ;*
17AC  51CD  FF84        2918*         dbra    D5,SETnext      ;loop through all segments
17B0  4213              2919*         clr.b   (a3)            ;ensure error reg is zero
17B2  13FC  0000  0080  2920* ETexit move.b  #NormOP,BEflag.l;set bus error flag for normal op.
17B8  0D94  
17BA  7000              2921*         moveq   #0,d0           ;make eq
17BC  4E75              2922*         RTS
17BE  4E71              2923* Xtest   nop
17C0  4DF9  0081  002C  2924*         lea     SEVec.l,A6       ;get address of error routine
17C6  4ED6              2925*         jmp     (A6)            ;do it
17C8  4E71              2926* XTend   nop
                        2927* ;Debugger routine--show a2
17CA  48E7  8204        2928* ShowA2b movem.l a5/d0/d6,-(SP)  ;
17CE  4BFA  0200+       2929*         lea     msgA2,A5        ;data.b DSCcr,'A2:',0
17D2  6100  08A4        2930*         bsr     DSoutst         ;
17D6  7C03              2931*         moveq   #3,D6
17D8  200A              2932*         move.l  A2,D0
17DA  6100  ECE4        2933*         bsr     outhex
17DE  6100  08AA        2934*         bsr     DSoutsp
17E2  7C01              2935*         moveq   #1,D6
17E4  1012              2936*         move.b  (A2),D0
17E6  6100  ECD8        2937*         bsr     outhex
17EA  4CDF  2041        2938*         movem.l (SP)+,a5/d0/d6
17EE  4E75              2939*         RTS
                        2940* ;Enter A3-ctx reg
                        2941* ;       A2-Map Ram / high dram pointer
                        2942* ;Check page protection circuits for each page.  First remap pages
                        2943* ;to ensure all page control bits are zero.  Then, starting at page
File: C1.MAIN.TEXT                                                Page  71


                        2944* ;zero and incrementing through the pages test the four protection controls
                        2945* ; in this order--1.page used 2. page dirty 3. page invalid 4. page read only
                        2946* ;
17F0                    2947* PagErrTst
17F0  13FC  0001  0080  2948*         move.b  #petop,BEflag.l ;set for page protection bus errors
17F6  0D94  
17F8  0839  0004  0080  2949*         btst    #tranbit,SysFlag.l     ;make sure transparent
17FE  0D64  
1800  6604              2950*         bon.s   PET1                   ;yes,branch
1802  6100  F360        2951*         bsr     MapSegs         ;map transparent
1806  6100  F43A        2952* PET1    bsr     MapPages        ;map the pages-trashes a2
180A  47F9  0084  0003  2953*         lea     CtxReg.l,A3     ;point to context register
1810  45F9  0040  0000  2954*         lea     MapBase.l,A2    ;use high map addressing
1816  263C  0000  1000  2955*         move.l  #PagOfst,D3     ;get page offset $1000
181C  2A39  0080  0D66  2956*         move.l  curmem.l,D5     ;get current board size
1822  8AC3              2957*         divu    D3,D5           ;D5/D3 = # of pages on current board in D5
1824  5345              2958*         subq    #1,D5           ;adjust for dbra
                        2959* ;Read high map dynamic ram in current page and check that only the used bit is
                        2960* ;set.
1826  4213              2961* UsePage clr.b   (A3)            ;we are for sure talking to dram-like, totally!
                        2962*        ;bsr     ShowCr
1828  4A92              2963*         tst.l   (A2)            ;read high map
                        2964*        ;bsr     ShowA2b
182A  0013  0080        2965*         ori.b   #PMsupHi,(A3)   ;select page map supervisor high at cx reg
                        2966*        ;bsr     ShowCr
                        2967*        ;bsr     ShowA2b
182E  1212              2968*         move.b  (A2),D1         ;save data
1830  0212  003C        2969*         andi.b  #$3C,(A2)       ;mask out all non control bits
1834  0C12  0020        2970*         cmpi.b  #$20,(A2)       ;ensure only bit set
                        2971*        ;bsr     ShowA2b
1838  6660              2972*         bne.s   PPerr0          ;branch to page protection error 1 if not used
                        2973* ;Restore page data and clear control bits before checking proper operation of
                        2974* ;the page dirty control bit by writing to high mapped dram and making sure used
                        2975* ;and dirty bits are set.
183A  1481              2976* DirtyPg move.b  D1,(A2)         ;restore data
183C  0212  0003        2977*         andi.b  #$03,(A2)       ;clear out control bits
                        2978*        ;bsr     showcr
                        2979*        ;bsr     Showa2b
1840  4213              2980*         clr.b   (A3)            ;clear context register -- point to dram
1842  2480              2981*         move.l  D0,(A2)         ;dirty memory
1844  0013  0080        2982*         ori.b   #PMsupHi,(A3)   ;select page map supervisor high at context reg.
1848  1212              2983*         move.b  (A2),D1         ;save data
184A  0212  003C        2984*         andi.b  #$3C,(A2)       ;mask out all non control bits
184E  0C12  0030        2985*         cmpi.b  #$30,(A2)       ;ensure used and dirty
1852  665E              2986*         bne.s   PPerr1          ;branch to page protect err 2 if not used & dirty
                        2987* ;Restoring page data and clearing the control bits we then set the invalid page
                        2988* ;bit and do a longword read of highmap dram to force a bus error. If none happens
                        2989* ;then the error is reported.
1854  1481              2990* Invalpg move.b  D1,(A2)         ;restore data
1856  0212  0003        2991*         andi.b  #$03,(A2)       ;clear out control bits
185A  0012  0008        2992*         ori.b   #$08,(A2)       ;set page invalid bit
185E  4213              2993*         clr.b   (A3)            ;select dram acces
1860  4A92              2994*         tst.l   (A2)            ;force a buss error
1862  6060              2995*         bra.s   PPerr2          ;should not get here
File: C1.MAIN.TEXT                                                Page  72


1864  0013  0080        2996* PETret  ori.b   #PMsupHI,(A3)   ;select high supervisor page mmap
1868  0812  0003        2997*         btst    #3,(A2)         ;is page invalid bit set?
186C  670E              2998*         boff.s  PETnext         ;no continue
                        2999* ;The final test for each page is the read only control.  Setting this bit only
                        3000* ; and performing a longword read should cause a bus error which returns to PETret
                        3001* ;which checks for which bus error occured-i.e. invalid or read only.
186E  0212  0003        3002*         andi.b  #$3,(A2)        ;clear control bits
1872  0012  0004        3003*         ori.b   #$04,(A2)       ;set read only
1876  4213              3004*         clr.b   (A3)            ;access dram
1878  2480              3005*         move.l  D0,(A2)         ;write--should cause a buss error
187A  605A              3006*         bra.s   PPerr3          ;should not get here
187C  0013  0080        3007* PetNext ori.b   #PMsupHi,(A3)   ;set superisor page map high
1880  0212  0003        3008*         andi.b  #$3,(A2)        ;clear control bits
1884  D5C3              3009*         adda.l  D3,A2           ;increment address
1886  51CD  FF9E        3010*         dbra    D5,UsePage      ;loop throughout current memory
                        3011*        ;lea     msgdone,A5
                        3012*        ;bsr     DSoutst
                        3013*        ;bsr     mappages
188A  6100  ED26        3014*         bsr     outdot          ;*
188E  13FC  0000  0080  3015*         move.b  #Normop,BEflag.l
1894  0D94  
1896  4213              3016*         clr.b   (A3)         ;force an eq  and clear context reg
1898  4E75              3017*         RTS
189A  614C              3018* PPerr0  bsr.s   PPerr
189C  4BFA  00DD+       3019*         lea     PETmsg0,A5
18A0  6100  07D6        3020*         bsr     DSoutst
18A4  6100  ECEE        3021*         bsr     OptCont
18A8  6790              3022*         beq.s   DirtyPg
18AA                    3023* PETexit
18AA  6100  F396        3024*         bsr     mappages
18AE  7CFF              3025*         moveq   #-1,D6
18B0  4E75              3026*         RTS
18B2  6134              3027* PPerr1  bsr.s   PPerr
18B4  4BFA  00D7+       3028*         lea     PETmsg1,A5
18B8  6100  07BE        3029*         bsr     DSoutst
18BC  6100  ECD6        3030*         bsr     OptCont
18C0  6792              3031*         beq.s   InvalPg
18C2  60E6              3032*         bra.s   PETexit
18C4  6122              3033* PPerr2  bsr.s   PPerr
18C6  4BFA  00D9+       3034*         lea     PETmsg2,A5
18CA  6100  07AC        3035*         bsr     DSoutst
18CE  6100  ECC4        3036*         bsr     OptCont
18D2  6790              3037*         beq.s   PETret
18D4  60D4              3038*         bra.s   PETexit
18D6  6110              3039* PPerr3  bsr.s   PPerr
18D8  4BFA  00DE+       3040*         lea     PETmsg3,A5
18DC  6100  079A        3041*         bsr     DSoutst
18E0  6100  ECB2        3042*         bsr     OptCont
18E4  6796              3043*         beq.s   PETnext
18E6  60C2              3044*         bra.s   PETexit
18E8  4BFA  0083+       3045* PPerr   lea     MsgErrPag,A5
18EC  6100  078A        3046*         bsr     DSoutst
                        3047* ;output page number in hex
                        3048* ;ENTER  A2-Address to convert to page number
File: C1.MAIN.TEXT                                                Page  73


18F0  48E7  8300        3049* DspPgNo movem.l  D0/D6-D7,-(SP)        ;save data expected
18F4  7C02              3050*         moveq   #2,D6
18F6  200A              3051*         move.l  A2,D0           ;get failing address
18F8  7E0C              3052*         moveq   #12,D7
18FA  EEA0              3053*         asr.l   d7,D0              ;get upper half
18FC  C07C  03FF        3054*         and     #$3FF,D0         ;clear A22 and up
1900  6100  EBBE        3055*         bsr     outhex          ;display segment/page number
1904  4CDF  00C1        3056*         movem.l  (sp)+,D0/D6-D7  ;return data expected
1908  4E75              3057*         RTS
190A  0D 4572726F722052 3058* msgERzero data.b DSCcr,'Error Register not set properly',0
1912  6567697374657220
191A  6E6F742073657420
1922  70726F7065726C79
192A  00 
192B  0D 50726F63746563 3059* msgprotect data.b DSCcr,'Proctection circuit tests ',0
1933  74696F6E20636972
193B  6375697420746573
1943  74732000 
1947  577269746500      3060* SETmsg0 data.b  'Write',0
194D  5265616400        3061* SETmsg1 data.b  'Read',0
1952  4578656375746500  3062* SETmsg2 data.b  'Execute',0
195A  00                3063* SETmoff data.b  Setmsg0-setmsg0
195B  06                3064*         data.b  Setmsg1-setmsg0
195C  0B                3065*         data.b  Setmsg2-setmsg0
195D  204572726F722053  3066* msgErrSeg data.b ' Error Segment:',0
1965  65676D656E743A00 
196D  204572726F722050  3067* msgErrPag data.b ' Error Page: ',0
1975  6167653A2000 
197B  5573656420626974  3068* PETmsg0 data.b  'Used bit not set',DSCcr,0
1983  206E6F7420736574
198B  0D 00 
198D  4469727479206269  3069* PETmsg1 data.b  'Dirty bits not set',DSCcr,0
1995  7473206E6F742073
199D  65740D 00 
19A1  496E76616C696420  3070* PETmsg2 data.b  'Invalid allows access',DSCcr,0
19A9  616C6C6F77732061
19B1  63636573730D 00 
19B8  52656164204F6E6C  3071* PETmsg3 data.b  'Read Only allows write',DSCcr,0
19C0  7920616C6C6F7773
19C8  2077726974650D 00 
                        3072* ;
19D0  0D 41323A00       3073* msgA2   data.b DSCcr,'A2:',0
                        3074* ;
19D5  0D 50524F54454354 3075* msgErrmenu data.b DSCcr,'PROTECTION TESTS'
19DD  494F4E2054455354
19E5  53
19E6  0D 302D447261676F 3076*            data.b DSCcr,'0-Dragonfly'
19EE  6E666C79
19F2  0D 312D5365676D65 3077*            data.b DSCcr,'1-Segment Map'
19FA  6E74204D6170
1A00  0D 322D5061676520 3078*            data.b DSCcr,'2-Page Map'
1A08  4D6170
1A0B  0D 332D5465737420 3079*            data.b DSCcr,'3-Test all'
1A13  616C6C
File: C1.MAIN.TEXT                                                Page  74


1A16  00                3080*            data.b 0
                        3081* 
File: C1.MAIN.TEXT                                                Page  75


                        3083* 
                        3084*         include 'c.OMNI'
                        3085* ; File: DP.OMtest
                        3086* ; Date: 05-Mar-84
                        3087* ;
                        3088* ; Transporter Return Codes
                        3089* ;
      000000FF          3090* Waiting EQU     $FF     ;
      000000FE          3091* CmdAcpt EQU     $FE     ;
      000000C0          3092* Echoed  EQU     $C0     ;echo command was successful
                        3093*                         ;
      00000080          3094* GaveUp  EQU     $80     ;aborted a send command after MaxRetries tries
      00000081          3095* TooLong EQU     $81     ;last message sent was too long for the receiver
      00000082          3096* UnkSock EQU     $82     ;sent to uninitialized socket
      00000083          3097* CtlMism EQU     $83     ;Control length MisMatch
      00000084          3098* InvSock EQU     $84     ;invalid socket # on setup receive command
      00000085          3099* UseSock EQU     $85     ;socket already set up
      00000086          3100* BadDest EQU     $86     ;sent to an illegal host number
                        3101* 
      00000090          3102* NoTrans EQU     $90     ;could not strobe cmd addr to Transporter
      00000091          3103* TimeOut EQU     $91     ;timed out waiting for an Omninet event
                        3104* ;
                        3105* ; Transporter Opcodes
                        3106* ;
      00000020          3107* InitOp  EQU     $20     ;INIT opcode
      00000002          3108* EchoOp  EQU     $02     ;ECHOCMD opcode
      00000001          3109* WhoOp   EQU     $01     ;WHOAMI opcode
      00000040          3110* SendOp  EQU     $40             ;SEND COMMAND
      000000F0          3111* SetRxOP EQU     $F0             ;SET UP RECIEVE COMMAND OP CODE
      00000010          3112* EndRxOP EQU     $10             ;End Receive command op code
      0002FFFF          3113* TOintvl EQU     $2FFFF  ;timeout interval
File: C1.MAIN.TEXT                                                Page  76


1A18  4BFA  02B0+       3115* OMtest lea     msgomnmenu,A5    ;display menu
1A1C  6100  065A        3116*         bsr     DSoutST
1A20  6100  0674        3117* OMNPrmt bsr     DSoutCr         ;display a return
1A24  103C  0021        3118*         move.b  #Prompt5,D0         ;prompt for test menu
1A28  6100  E860        3119*         bsr     Menukey         ;*
1A2C  487A  FFF2+       3120*         pea     OMNPrmt         ;return to prompt
1A30  41BC  0005        3121*         chk     #5,D0         ;*
1A34  E300              3122*         asl.b   #1,d0              ;double for table
1A36  303B  0006+       3123*         move.w  OMNtbl(D0.W),D0
1A3A  4EFB  0002+       3124*         jmp     OMNtbl(D0.W)
                        3125* ;
1A3E                    3126* OMNtbl
1A3E  E8B2              3127*         data.w  DRAGON-OMNtbl
1A40  0094              3128*         data.w  Initcmd-OMNTbl
1A42  00B2              3129*         data.w  Whocmd-OMNtbl
1A44  0078              3130*         data.w  Echocmd-OMNtbl
1A46  000C              3131*         data.w  ActNet-OMNtbl
1A48  00EE              3132*         data.w  LoopBack-OMNtbl
                        3133* ;
1A4A  7002              3134* ActNet  moveq   #EchoOP,D0      ;get echo command
1A4C  4BFA  033E+       3135*         lea     msgSF,A5        ;message-stations found
1A50  6100  0626        3136*         bsr     DSoutst
1A54  4201              3137*         clr.b   D1              ;echo first to 0
1A56  4282              3138*         clr.l   D2              ;set for no net
1A58  6100  01D0        3139* ActNet1 bsr     OMcmd           ;send echo cmd
1A5C  BE3C  00C0        3140*         cmp.b   #Echoed,D7      ;Successful?
1A60  6622              3141*         bne.s   ActNet3         ;no, try next number
1A62  48A7  A000        3142*         movem.w D0/D2,-(SP)     ;save registers
1A66  C43C  000B        3143*         and.b   #$0B,D2         ;see if lower nibble is B
1A6A  B43C  000B        3144*         cmp.b   #$0B,D2         ;*
1A6E  6604              3145*         bne.s   ACTNET2         ;no,branch
1A70  6100  0624        3146*         bsr     DSoutcr         ;yes,return
1A74  1001              3147* Actnet2 move.b  D1,D0           ;get number
1A76  6100  EA48        3148*         bsr     outhex          ;display byte
1A7A  6100  060E        3149*         bsr     DSoutsp         ;print a space
1A7E  4C9F  0005        3150*         movem.w (SP)+,D0/D2     ;
1A82  5202              3151*         addq.b  #1,D2           ;increment echoed counter
1A84  5201              3152* ActNet3 addq.b  #1,D1           ;increment echo destination
1A86  B23C  003F        3153*         cmp.b   #63,D1          ;63 is highest num possible
1A8A  63CC              3154*         bls.s   ActNet1         ;not done,branch
1A8C  4A02              3155*         tst.b   D2              ;any found?
1A8E  6600  0092        3156*         bne     OMend           ;yes, successful-end
1A92  4BFA  02DE+       3157*         lea     msgNone,A5      ;print none
1A96  6000  05E0        3158*         bra     DSoutst         ;
                        3159* ;
1A9A  4BFA  02B5+       3160* GetDest lea     msgwhathost,A5  ;
1A9E  6100  05D8        3161*         bsr     DSoutst         ;
1AA2  6100  E956        3162*         bsr     input
1AA6  6100  E998        3163*         bsr     getpara
1AAA  4A00              3164*         tst.b   D0
1AAC  6BEC              3165*         bmi.s   GetDest
1AAE  B03C  0040        3166*         cmp.b   #64,D0
1AB2  6CE6              3167*         bge.s   GetDest
1AB4  4E75              3168*         RTS
File: C1.MAIN.TEXT                                                Page  77


                        3169* ;
1AB6  61E2              3170* EchoCmd bsr.s   GetDest         ;Get destination in D0
1AB8  1200              3171*         move.b  D0,D1           ;Move to d1
1ABA  7002              3172*         moveq   #EchoOP,D0
1ABC  6100  016C        3173*         bsr     omcmd
1AC0  4BFA  029C+       3174*         lea     msgsucc,A5      ;assume successful
1AC4  BE3C  00C0        3175*         cmp.b   #Echoed,D7      ;pass?
1AC8  6704              3176*         beq.s   Echoout         ;yes output
1ACA  4BFA  029F+       3177*         lea     msgfail,A5      ;*
1ACE  6000  05A8        3178* Echoout bra     DSoutst
                        3179* ;
1AD2  7020              3180* Initcmd moveq   #initOp,D0      ;get initialize command
1AD4  6100  0154        3181*         bsr     OMcmd           ;send it
1AD8  4A07              3182*         tst.b   D7              ;check return
1ADA  6B32              3183*         bmi.s   OMerr           ;error branch
1ADC  4BFA  029B+       3184*         lea     msgHNum,A5      ;message-this station is
1AE0  6100  0596        3185*         bsr     DSoutst         ;
1AE4  7C01              3186*         moveq   #1,D6           ;outbyte
1AE6  1007              3187*         move.b  D7,D0
1AE8  6100  E9D6        3188*         bsr     outhex
1AEC  6000  05A8        3189*         bra     DSoutCr
                        3190* ;
1AF0  7001              3191* Whocmd  moveq   #WhoOp,D0      ;get who am i command
1AF2  6100  0136        3192*         bsr     OMcmd           ;send it
1AF6  4A07              3193*         tst.b   D7              ;check return
1AF8  6B14              3194*         bmi.s   OMerr           ;error branch
1AFA  4BFA  027D+       3195*         lea     msgHNum,A5      ;message-this station is
1AFE  6100  0578        3196*         bsr     DSoutst         ;
1B02  7C01              3197*         moveq   #1,D6           ;outbyte
1B04  1007              3198*         move.b  D7,D0
1B06  6100  E9B8        3199*         bsr     outhex
1B0A  6000  058A        3200*         bra     DSoutCr
                        3201*        ;RTS
                        3202* ; OMerr   -- Error report for omninet
                        3203* ;
1B0E                    3204* OMerr
1B0E  4BFA  020F+       3205*         lea     msgTE,A5        ;colon on message is dev
1B12  6100  0564        3206*         bsr     DSoutst
1B16  7C01              3207*         moveq   #1,D6
1B18  1007              3208*         move.b  D7,D0           ;dev
1B1A  6100  E9A4        3209*         bsr     outhex          ;dev
1B1E  6000  0576        3210*         bra     DSoutcr
1B22                    3211* OMend
1B22  4E75              3212*         RTS
File: C1.MAIN.TEXT                                                Page  78


                        3214* ;
                        3215* ; Command Control Block = $1000
                        3216* ; Result Record Address = $1010
                        3217* ; Data Block Address    = $1100
                        3218* ; Send Data length      = $100
                        3219* ; Echo Request Cmd len  = $8
                        3220* ; Echo Request Data len = $F8 ($100-$8)
                        3221* ;
      00001000          3222* SendCCB equ     $1000           ;send message command control block
      00000010          3223* RRAofst equ     $10             ;offset to result record address
      00001100          3224* SendBlk equ     $1100           ;Send data block address
      00000100          3225* SendLen equ     $100            ;length of send command data
      00000080          3226* DesSock equ     $80             ;destination socket #
      00000000          3227* ContLen equ     $0              ;control length
                        3228* ;
                        3229* ; Send command control block offsets
                        3230* ;
      00000000          3231* CmdOfst equ     0
      00000004          3232* Dofst   equ     4               ;offset to Destination socket
      00000008          3233* DlnOfst equ     8               ;Data length offset
      0000000A          3234* ClnOfst equ     10              ;control length offset
      0000000B          3235* DhostOf equ     11              ;offset for destination host #
                        3236* ;
                        3237* ; Echo request is an omninet protocol which has the following data
                        3238* ;
      000001C0          3239* ERID    equ     $1C0            ;echo request protocol ID
      00000000          3240* ERmsgty equ     $0              ;echo protocol message type
      00000080          3241* ERDSock equ     DesSock         ;destination socket #
      0000003F          3242* ERShost equ     $3F             ;default host # (changeable)
      00000008          3243* ERcmLen equ     $8              ;length of Echo Request command (not including Data
      000000F8          3244* ERdalen equ     SendLen-ERcmLen ;data length
                        3245* ;
                        3246* ; The following Data Structure must be moved to Dynamic RAM
                        3247* ;
1B24  01C0              3248* EchoReq data.w  ERID
1B26  0000              3249*         data.w  ERmsgty
1B28  80                3250*         data.b  ERDsock
1B29  3F                3251*         data.b  ERShost
1B2A  00F8              3252*         data.w  ERdalen
                        3253* ;
1B2C                    3254* LoopBack ;movem.l A2-A3/D0,-(SP)  ;save registers
1B2C  4BFA  0207+       3255*         lea     msgLoopBack,A5  ;say loopback
1B30  6100  0546        3256*         bsr     DSoutST         ;*
                        3257* ;
                        3258* ; Move Wait loop to Dynamic Ram
                        3259* ;
      00000500          3260* waitlp  equ     $500
                        3261* 
1B34  4BF9  0081  1C5C+ 3262*         lea     OmniWt.l,A5     ;
1B3A  4DF9  0081  1C7A+ 3263*         lea     OWexit.l,A6
1B40  41F8  0500        3264*         lea     Waitlp.w,A0
1B44  30DD              3265* mwltdr  move.W  (A5)+,(A0)+
1B46  BDCD              3266*         cmpa.l  A5,A6
1B48  6CFA              3267*         bge.s   mwltdr
File: C1.MAIN.TEXT                                                Page  79


                        3268* ;
                        3269* ; Set up Send Packet in Dynamic Ram
                        3270* ;
1B4A  45F8  1000        3271*         lea     SendCCB.w,A2    ;get pointer to command control block
1B4E  47EA  0010        3272*         lea     RRAofst(A2), A3;Result record address
1B52  248B              3273*         move.l  A3,(A2)         ;(A3) = result record pointer
1B54  14BC  0040        3274*         move.b  #SendOp,(A2)    ;set Transporter command
1B58  49F8  1100        3275*         lea     SendBlk.w, A4   ;Set Data block Address
1B5C  254C  0004        3276*         move.l  A4,Dofst(A2)    ;set dest host number
1B60  157C  0080  0004  3277*         move.b  #DesSock,Dofst(A2) ;default destination socket number
1B66  357C  0100  0008  3278*         move.w  #SendLen,Dlnofst(A2);Get Data block length
1B6C  422A  000A        3279*         clr.b   Clnofst(A2)     ;no contol length
1B70  6100  FF28        3280*         bsr     GetDest         ;get host number
1B74  1540  000B        3281*         move.b  D0,Dhostof(A2)  ;put in block
                        3282* ;
                        3283* ; Set Up Echo Request Command in first 8 bytes of send command data block (A4)
                        3284* ;
1B78  4BFA  FFAA+       3285*         lea     EchoReq,A5      ;point to Echo Request protocol data packet
1B7C  28DD              3286*         move.l  (A5)+,(A4)+     ;move four bytes
1B7E  289D              3287*         move.l  (A5)+,(A4)      ;move last four bytes of command
                        3288* ;
                        3289* ; Now do who command to get current host number-short commands use different ram
                        3290* ;
1B80  7020              3291*         moveq   #InitOp,D0       ;get opcode
1B82  6100  00A6        3292*         bsr     OMcmd           ;do it
1B86  4A07              3293*         tst.b   D7              ;check return code
1B88  6B00  FF84        3294*         bmi     OMerr           ;failure
1B8C  1947  0001        3295*         move.b  D7,1(A4)        ;put in ram
                        3296* ;
                        3297* ; Initialize Data - use a 01-F8 data pattern - We'll use same pattern always
                        3298* ;
1B90  49F8  1108        3299*         lea     (SendBlk+ERcmlen).W,A4 ; Get address of start of data Patter
1B94  7001              3300*         moveq   #1,D0           ;initial data
1B96  3A3C  00F7        3301*         move.w  #(ERdalen-1),D5 ;number of bytes to write
1B9A  18C0              3302* InDatLP move.b  D0,(A4)+        ;write and increment address
1B9C  5200              3303*         addq.b  #1,D0           ;increment data
1B9E  51CD  FFFA        3304*         dbra    D5,InDatLp      ;loop
1BA2  4DF9  0081  1BAC+ 3305*         lea     LBloop.l,A6     ;start of loop
1BA8  6000  F96C        3306*         bra     execlp
                        3307* ;
                        3308* ; SetUp Receive command - Loop back to here for now
                        3309* ; RcvCCB  - $2000
                        3310* ; RcvRRA  - $10 (offset from Above)
                        3311* ; RcvDBlk - $2100
                        3312* ; RcvSock - $80
                        3313* ; RcvDlen - $100
                        3314* ; RcvClen - 0
                        3315* ;
      00002000          3316* RcvCCB  equ     $2000           ;Receive Command control block
      00002010          3317* RcvRRA  equ     $2010           ;Receive Result Record Address
      00002100          3318* RcvDBlk equ     $2100           ;Receive Data Block
      00000080          3319* RcvSock equ     $80             ;Receive Socket Number
      00000100          3320* RcvDlen equ     $100            ;Receive Data length
      00000000          3321* RcvClen equ     0               ;Receive Control length
File: C1.MAIN.TEXT                                                Page  80


      00000004          3322* Sofst   equ     4               ;offset to receive socket number
                        3323* ;
1BAC                    3324* LBloop
                        3325* ;
                        3326* ;Set up Receive command
                        3327* ;
1BAC  45F8  2000        3328*         lea     RcvCCB.w,A2    ;get pointer to command control block
1BB0  47EA  0010        3329*         lea     RRAofst(A2), A3;Result record address
1BB4  248B              3330*         move.l  A3,(A2)         ;(A3) = result record pointer
1BB6  14BC  00F0        3331*         move.b  #SetRxOp,(A2)    ;set Transporter command
1BBA  49F8  2100        3332*         lea     RcvDBlk.w, A4   ;Set Data block Address
1BBE  254C  0004        3333*         move.l  A4,Sofst(A2)    ;set dest host number
1BC2  157C  0080  0004  3334*         move.b  #RcvSock,Sofst(A2) ;default destination socket number
1BC8  357C  0100  0008  3335*         move.w  #SendLen,Dlnofst(A2);Get Data block length
1BCE  422A  000A        3336*         clr.b   Clnofst(A2)     ;no contol length
                        3337* ;
                        3338* ; Zero Receive Data Block
                        3339* ;
1BD2  3A3C  00FF        3340*         move.w  #RcvDlen-1,D5      ;get receive length in bytes
1BD6  E24D              3341*         lsr.w   #1,D5           ;divide by two (length in words)
1BD8  425C              3342* clearit clr.w   (A4)+
1BDA  51CD  FFFC        3343*         dbra    D5,clearit
                        3344* ;
                        3345* ; Since A2 is Already pointing to the set receive command control block
                        3346* ; Then strobe the setup receive cmd ctl block
                        3347* ;
1BDE  6100  0066        3348*         bsr     OmniGo          ;result returned in D7
                        3349* ;
                        3350* ; and check for $fe - successful setup
                        3351* ;
1BE2  BE3C  00FE        3352*         cmp.b   #cmdAcpt,D7     ;is return $fe?
1BE6  6600  FF26        3353*         bne     OMerr           ;no, error!
1BEA  16BC  00FF        3354*         move.b  #Waiting,(A3)
                        3355* ;
                        3356* ; now strobe the send command control block
                        3357* ;
1BEE  45F8  1000        3358*         lea     SendCCB.w,A2      ;point to send command control block
1BF2  6100  0052        3359*         bsr     OmniGo          ;do it
                        3360* ;
                        3361* ; and verify successful send
                        3362* ;
1BF6  4A07              3363*         tst.b   D7             ;valid return code?
1BF8  6B00  FF14        3364*         bmi     OMerr           ;no, error!
                        3365* ;
                        3366* ; After good send then wait for receive result record address to change again
                        3367* ;
1BFC  47F8  2010        3368*         lea     RcvRRA.w,A3       ;point to receive result record address
1C00  49F8  0500        3369*         lea     Waitlp.w,A4     ;wait for response to change from -1
1C04  4E94              3370*         jsr     (A4)            ;wait in dram
1C06  4A07              3371*         tst.b   D7
1C08  6B00  FF04        3372*         bmi     OMerr
                        3373* ;
                        3374* ; if successful then compare data received to data sent
                        3375* ; for now we will not check if receive packet is correct!
File: C1.MAIN.TEXT                                                Page  81


                        3376* ; put failing data in d1 good data in d0
                        3377* ;
1C0C                    3378* LBdatck
1C0C  49F8  1108        3379*         lea     (SendBlk+ERcmlen).W,A4 ; Get address of start of sent pattern
1C10  45F8  2108        3380*         lea     (RcvDBlk+ERcmlen).W,A2 ; Get address of start of rx patern
1C14  3A3C  00F7        3381*         move.w  #ERdaLen-1,D5    ;get number of bytes to check
1C18  E44D              3382*         lsr.w   #2,D5           ;divide by 4 for number of long words
1C1A  B58C              3383* LBDClp  cmpm.l  (A4)+,(A2)+     ;check
1C1C  56CD  FFFC        3384*         dbne    D5,LBDClp       ;repeat until done or ne
1C20  6706              3385*         beq.s   LBexit          ;branch if good
1C22  2024              3386*         move.l  -(A4),D0        ;data expected
1C24  2222              3387*         move.l  -(A2),D1        ;data error
1C26  7EFF              3388*         moveq   #-1,D7          ;force an ne
1C28  4E75              3389* LBexit  rts
File: C1.MAIN.TEXT                                                Page  82


                        3391* ;
                        3392* ; OMcmd -- send simple command to Transporter
                        3393* ;
                        3394* ;       Enter:  D0.B - Transporter command
                        3395* ;               D1.B - Destination host number (if ECHO)
                        3396* ;
                        3397* ;       Exit:   D7.B - IORESULT (OMNINET status)
                        3398* ;
1C2A  48E7  0030        3399* OMcmd movem.l A2-A3,-(SP)  ;save registers
1C2E  45F8  0000        3400*         lea     DRbase.w,A2     ;get pointer to Data Area
1C32  47EA  0010        3401*         lea     $10(A2), A3     ;Result record address
1C36  248B              3402*         move.l  A3,(A2)         ;(A3) = result record pointer
1C38  1480              3403*         move.b  D0,(A2)         ;set Transporter command
1C3A  1541  0004        3404*         move.b  D1,4(A2)        ;set dest host number
1C3E  6106              3405*         bsr.s   OmniGo
1C40  4CDF  0C00        3406*         movem.l (SP)+,A2-A3          ;restore registers
1C44  4E75              3407*         rts                             ;return
                        3408* ;
                        3409* ; OmniGo-- send a command to Transporter
                        3410* ;
                        3411* ;       Enter:  A2.L - Command control block Address
                        3412* ;               A2 + $10 - Result record address
                        3413* ;       Exit:   D7.B - IORESULT (OMNINET status)
                        3414* ;
1C46  48E7  0010        3415* OmniGo  movem.l A3,-(SP)
1C4A  47EA  0010        3416*         lea     RRAofst(A2),A3      ;RRA is offset by 16
1C4E  16BC  00FF        3417*         move.b  #Waiting,(A3)           ;set Transporter waiting flag
1C52  6128              3418*         bsr.s   StrobIt                 ;strobe command address to Transporter
1C54  6602              3419*         bne.s   OmniGo2                  ;Transporter not responding
1C56  6104              3420*         bsr.s   OmniWt
1C58  4CDF  0800        3421* OmniGo2 movem.l (SP)+,A3        ;restore registers
                        3422* 
1C5C  48E7  8000        3423* OmniWt  movem.l D0,-(SP)
1C60  203C  0002  FFFF  3424*         move.l  #TOintvl,D0             ;get timeout interval
1C66  1E13              3425* OmniWt1 move.b  (A3),D7                 ;get Transporter return code
1C68  0C07  00FF        3426*         cmpi.b  #Waiting, D7            ;has Transporter responded?
1C6C  6608              3427*         bne.s   OmniWt2                 ;yes, ready to return
1C6E  5380              3428*         subq.l  #1, D0                  ;see if waited long enough
1C70  6AF4              3429*         bpl.s   OmniWt1                 ;no, look again
1C72  1E3C  0091        3430*         move.b  #TimeOut, D7            ;yes, set timeout error & return
1C76  4CDF  0001        3431* OmniWt2 movem.l (SP)+,D0
1C7A  4E75              3432* OWexit  rts                             ;return
                        3433* ;
                        3434* ; StrobIt -- Strobe command address to Transporter
                        3435* ;
                        3436* ;       Enter:  A2 = command address
                        3437* ;
                        3438* ;       Exit:   D7 = Transporter strobe status
                        3439* ;
                        3440* ;               EQ = successful
                        3441* ;               NE = Transporter not responding
                        3442* ;
                        3443* ;       All other registers are preserved
                        3444* ;
File: C1.MAIN.TEXT                                                Page  83


1C7C  48E7  C080        3445* StrobIt movem.l D0-D1/A0,-(SP)  ;save registers
1C80  41F9  0083  0200  3446*         lea     RdyAdr.L,A0     ;get address of ready flag
1C86  4287              3447*         clr.l   D7              ;assume no Transporter error
1C88  200A              3448*         move.l  A2,D0           ;get command address
1C8A  E198              3449*         rol.l   #8,D0           ;move command address to msb
                        3450*                                 ;
1C8C  611A              3451*         bsr.s   SBstrob         ;strobe address HI
1C8E  670C              3452*         beq.s   SBerr           ;
1C90  6116              3453*         bsr.s   SBstrob         ;strobe address MED
1C92  6708              3454*         beq.s   SBerr           ;
1C94  6112              3455*         bsr.s   SBstrob         ;strobe address LO
1C96  6704              3456*         beq.s   SBerr           ;
1C98  6114              3457*         bsr.s   SBwait          ;wait for Transporter ready
1C9A  6604              3458*         bne.s   SBexit          ;
                        3459*                                 ;
1C9C  1E3C  0090        3460* SBerr   move.b  #NoTrans,D7     ;no transporter ...
                        3461*                                 ;
1CA0  4CDF  0103        3462* SBexit  movem.l (SP)+,D0-D1/A0  ;restore registers
1CA4  4A47              3463*         tst.w   D7              ;set return condition code
1CA6  4E75              3464*         rts                     ;return
                        3465*                                 ;
1CA8  E198              3466* SBstrob rol.l   #8,D0           ;shift address byte to lsb
1CAA  1140  0401        3467*         move.b  D0,StrAdr-RdyAdr(A0) ;strobe address
1CAE  223C  0002  FFFF  3468* SBwait move.l  #TOintvl,D1     ;get timeout interval
                        3469*        ;moveq   #-1,D1          ;use shorter timeout--no rcvs being done
1CB4  0810  0007        3470* SBW1    btst    #7, (A0)        ;is transporter ready?
                        3471*        ;dbeq    D1,SBW1            ;Repeat until transporter ready or count done
                        3472*        ;boff.s  SBWexit         ;not read return
1CB8  6606              3473*        bon.s   SBWchk          ;yes, return
1CBA  5381              3474*        subq.l  #1, D1          ;see if waited long enough
1CBC  66F6              3475*        bne.s   SBW1            ;no, look again
1CBE  6008              3476*        bra.s   SBWexit         ;timed out
1CC0  4E71              3477* SBWchk  nop                     ;check for glitch in ready
1CC2  0810  0007        3478*         btst    #7, (A0)        ;is transporter ready?
1CC6  67EC              3479*         boff.s  SBW1            ;no, then continue to wait
1CC8  4E75              3480* SBWexit rts                     ;return
                        3481* ;
1CCA  0D 4F4D4E494E4554 3482* msgomnmenu data.b DSCcr,'OMNINET TESTS'
1CD2  205445535453
1CD8  0D 302D447261676F 3483*            data.b DSCcr,'0-Dragonfly'
1CE0  6E666C79
1CE4  0D 312D496E697469 3484*            data.b DSCcr,'1-Initialize'
1CEC  616C697A65
1CF1  0D 322D57686F416D 3485*            data.b DSCcr,'2-WhoAmI'
1CF9  49
1CFA  0D 332D4563686F   3486*            data.b DSCcr,'3-Echo'
1D01  0D 342D4163746976 3487*            data.b DSCcr,'4-Active Net'
1D09  65204E6574
1D0E  0D 352D4563686F20 3488*            data.b DSCcr,'5-Echo Loopback'
1D16  4C6F6F706261636B
1D1E  00                3489*            data.b 0
1D1F  0D 5472616E73706F 3490* msgTE data.b  DSCcr,'Transporter Error : ',0
1D27  7274657220457272
1D2F  6F72203A2000 
File: C1.MAIN.TEXT                                                Page  84


1D35  0D 4F6D6E696E6574 3491* msgloopback data.b  DSCcr,'Omninet Echo Loopback Test',0
1D3D  204563686F204C6F
1D45  6F706261636B2054
1D4D  65737400 
1D51  0D 5768617420486F 3492* msgwhathost data.b  DSCcr,'What Host? ',0
1D59  73743F2000 
1D5E  2053756363657373  3493* msgSucc data.b  ' Successful',DSCcr,0
1D66  66756C0D 00 
1D6B  204661696C0D 00   3494* msgFail data.b  ' Fail',DSCcr,0
1D72  204E6F6E650D 00   3495* msgNone data.b  ' None',DSCcr,0
1D79  0D 54686973206973 3496* msgHNum data.b  DSCcr,'This is Station #',0
1D81  2053746174696F6E
1D89  202300 
1D8C  53746174696F6E73  3497* msgSF   data.b  'Stations Found: ',0
1D94  20466F756E643A20
1D9C  00 
1D9D                    3498* omxxxxx
                        3499* 
                        3500* ;       page
                        3501* ;       include 'SIV.IOTST'
File: C1.MAIN.TEXT                                                Page  85


                        3503*         include 'SIV.LOOP'
1D9E  4BFA  01B0+       3504* loops   lea     msgloop,A5
1DA2  6100  02D4        3505*         bsr     DSoutSt
1DA6  7AFF              3506*         moveq   #-1,D5
1DA8  103C  002B        3507*         move.b  #Prompt6,D0
1DAC  6100  02F4        3508*         bsr     DSoutch
1DB0  6100  08D4        3509*         bsr     KBgetUC
1DB4  B03C  004D        3510*         cmp.b   #'M',D0
1DB8  6700  E4F6        3511*         beq     MainMenu
1DBC  B03C  0030        3512*         cmp.b   #'0',D0
1DC0  6700  E52E        3513*         beq     Dragon
1DC4  B03C  0031        3514*         cmp.b   #'1',D0
1DC8  6748              3515*         beq.s   Rdb
1DCA  B03C  0032        3516*         cmp.b   #'2',D0
1DCE  6750              3517*         beq.s   Wrb
1DD0  B03C  0033        3518*         cmp.b   #'3',D0
1DD4  675C              3519*         beq.s   RWb
1DD6  B03C  0034        3520*         cmp.b   #'4',D0
1DDA  6700  0066        3521*         beq     RDW
1DDE  B03C  0035        3522*         cmp.b   #'5',D0
1DE2  6700  006C        3523*         beq     WRW
1DE6  B03C  0036        3524*         cmp.b   #'6',D0
1DEA  6700  0076        3525*         beq     RWW
1DEE  B03C  0037        3526*         cmp.b   #'7',D0
1DF2  6700  007E        3527*         beq     IWR
1DF6  B03C  0038        3528*         cmp.b   #'8',D0
1DFA  6700  0086        3529*         beq     IRD
1DFE  B03C  0039        3530*         cmp.b   #'9',D0
1E02  6700  00A4        3531*         beq     Inclp1
1E06  B03C  0041        3532*         cmp.b   #'A',D0
1E0A  6700  0102        3533*         beq     Inclp2
1E0E  6000  FF8E        3534*         bra     loops
                        3535* 
                        3536* ;*********************************************************
                        3537* ; Scope loops -- address is always A2 - Write data is D0
                        3538* ; Read data is D1 no address checking is done so be careful!
                        3539* ;*********************************************************
                        3540* ;input address and read one byte forever
1E12  6100  007E        3541* RDB     bsr     Loopadd
1E16  2440              3542*         movea.l D0,A2
1E18  1212              3543* RDB1    move.b  (A2),D1
1E1A  51CD  FFFC        3544*         dbra    D5,RDB1
1E1E  60F8              3545*         bra.s   RDB1
                        3546* ;input address and data and write one byte forever
1E20  6100  0070        3547* WRB     bsr     Loopadd
1E24  2440              3548*         movea.l D0,A2
1E26  6100  0070        3549*         bsr     LoopDat
1E2A  1480              3550* WRB1    move.b  d0,(a2)
1E2C  51CD  FFFC        3551*         dbra    D5,wrb1
1E30  60F8              3552*         bra.s   WRB1
                        3553* ;input address and data, write and read one byte forever
1E32  6100  005E        3554* RWB     bsr     Loopadd
1E36  2440              3555*         movea.l D0,A2
1E38  6100  005E        3556*         bsr     LoopDat
File: C1.MAIN.TEXT                                                Page  86


1E3C  1480              3557* RWB1    move.b  d0,(a2)
1E3E  1212              3558*         move.b  (A2),D1
1E40  60FA              3559*         bra.s   RWB1
                        3560* ;input address and read one word forever
1E42  6100  004E        3561* RDW     bsr     Loopadd
1E46  2440              3562*         movea.l D0,A2
1E48  3212              3563* RDW1    move.w  (A2),D1
1E4A  51CD  FFFC        3564*         dbra    D5,RDW1
1E4E  60F8              3565*         bra.s   RDW1
                        3566* ;input address and data and write one word forever
1E50  6100  0040        3567* WRW     bsr     Loopadd
1E54  2440              3568*         movea.l D0,A2
1E56  6100  0040        3569*         bsr     LoopDat
1E5A  3480              3570* WRW1    move.w  d0,(a2)
1E5C  51CD  FFFC        3571*         dbra    D5,WRW1
1E60  60F8              3572*         bra.s   WRW1
                        3573* ;input address and data, write and read one word forever
1E62  6100  002E        3574* RWW     bsr     Loopadd
1E66  2440              3575*         movea.l D0,A2
1E68  6100  002E        3576*         bsr     LoopDat
1E6C  3480              3577* RWW1    move.w  d0,(a2)
1E6E  3212              3578*         move.w  (A2),D1
1E70  60FA              3579*         bra.s   RWW1
                        3580* ;Incrementing Write loop by longword (data decrements address increments)
                        3581* ;Entered address must be $40000 less then the end of ram.
1E72  611E              3582* IWR     bsr.s   Loopadd
1E74  2240              3583*         movea.l D0,A1
1E76  2449              3584* Iwr0    movea.l A1,A2
1E78  70FF              3585*         moveq   #-1,d0
1E7A  24C0              3586* Iwr1    move.l  d0,(a2)+
1E7C  51C8  FFFC        3587*         dbra    d0,Iwr1
1E80  60F4              3588*         bra.s   Iwr0
                        3589* ;Incrementing Read loop by longword (address increments)
                        3590* ;Entered address must be $40000 less then the end of ram.
1E82  610E              3591* IRD     bsr.s   Loopadd
1E84  2240              3592*         movea.l D0,A1
1E86  2449              3593* IRD0    movea.l A1,A2
1E88  70FF              3594*         moveq   #-1,d0
1E8A  221A              3595* IRD1    move.l  (a2)+,D1
1E8C  51C8  FFFC        3596*         dbra    d0,IRD1
1E90  60F4              3597*         bra.s   IRD0
                        3598* ;loopadd-gets starting address for scopeloops
                        3599* ;
1E92  4BFA  01AE+       3600* loopadd lea     msgladd,A5
1E96  6004              3601*         bra.s   looppar
                        3602* 
                        3603* ;loopdat-gets data for scopeloops
                        3604* ;
1E98  4BFA  01B4+       3605* loopdat lea     msgldat,A5
1E9C  6100  01DA        3606* looppar bsr     DSoutst
1EA0  6100  E558        3607*         bsr     input
1EA4  6000  E59A        3608*         bra     GetPara
                        3609* ;
                        3610* ; IncLp1-write and read an incrementing pattern, exitting on errors
File: C1.MAIN.TEXT                                                Page  87


                        3611* ; and executing a compare loop if write/read passes
                        3612* ; and then looping back again.
                        3613* ;
                        3614* ; Registers     D0 - write data                      A0 - Start address
                        3615* ;               D1 - read data                       A1 - End Address
                        3616* ;               D2 - Current page #                  A2 - Memory Pointer
                        3617* ;               D4 - Words per page ($800)
                        3618* ;               D5 - Number of pages
1EA8  4239  0084  0003  3619* Inclp1  clr.b   CtxReg.l        ;ensure ram access
1EAE  41F8  0000        3620*         lea     DRbase.w,A0     ;start of ram
1EB2  2039  0080  0D66  3621* Inclp11 move.l  curmem.l,D0     ;end of ram
1EB8  E288              3622*         lsr.l   #1,D0
1EBA  6100  F64C        3623*         bsr     GetCntR         ;get memory counters in D5&D6
1EBE  2448              3624*         movea.l A0,A2           ;set pointer address
1EC0  7000              3625*         moveq   #0,D0           ;number of words per page
1EC2  3480              3626* IncLp1a move.w  D0,(A2)         ;write mem
1EC4  321A              3627*         move.w  (A2)+,D1        ;read
1EC6  B240              3628*         cmp     D0,D1           ;compare
1EC8  663A              3629*         bne.s   IncMis2         ;branch on miscompare
1ECA  5280              3630*         addq.l  #1,D0         ;increment write data
1ECC  51CD  FFF4        3631*         dbra    D5,IncLp1a      ;loop until done
1ED0  6100  E6E0        3632*         bsr     outdot
1ED4  51CE  FFEC        3633*         dbra    D6,IncLp1a      ;loop until done
1ED8  103C  0043        3634*         move.b  #'C',D0         ;output a 'C' for comparing
1EDC  6100  01C4        3635*         bsr     DSoutch         ;display
1EE0  2039  0080  0D66  3636*         move.l  curmem.l,D0      ;get memory size
1EE6  E288              3637*         lsr.l   #1,D0
1EE8  6100  F61E        3638*         bsr     GetCntR         ;get counters for D5&D6
1EEC  2448              3639*         movea.l A0,A2           ;set pointer address to start of memory
1EEE  B05A              3640* IncCmp1 cmp.w   (A2)+,D0        ;compare memory
1EF0  660E              3641*         bne.s   IncMis1         ;branch on miscompare
1EF2  5280              3642*         addq.l  #1,D0           ;increment counter
1EF4  51CD  FFF8        3643*         dbra    D5,IncCmp1      ;loop until done
1EF8  51CE  FFF4        3644*         dbra    D6,IncCmp1      ;loop until done
1EFC  6000  FFB4        3645*         bra     Inclp11         ;loop forever
1F00  3222              3646* IncMis1 move.w  -(A2),D1        ;get bad data
1F02  6002              3647*         bra.s   IncMis3
1F04  4A62              3648* IncMis2 tst.w   -(A2)           ;adjust a2
1F06  6100  E652        3649* IncMis3 bsr     miscmpw         ;output errors
1F0A  6000  FE92        3650*         bra     loops
                        3651* ;
                        3652* ; IncLp2-write and read an incrementing pattern, looping forever
                        3653* ;
                        3654* ; Registers     D0 - write data                      A0 - Start address
                        3655* ;               D1 - read data                       A1 - End Address
                        3656* ;               D2 - Current page #                  A2 - Memory Pointer
                        3657* ;               D4 - Words per page ($800)
                        3658* ;               D5 - Number of pages
1F0E  4239  0084  0003  3659* Inclp2  clr.b   CtxReg.l        ;ensure ram access
1F14  41F8  0000        3660*         lea     DRbase.w,A0     ;start of ram
1F18  2039  0080  0D66  3661* IncLp2a move.l  Curmem.l,D0     ;get memory size
1F1E  E288              3662*         lsr.l   #1,D0
1F20  6100  F5E6        3663*         bsr     GetCntR         ;get counters in D5&D6
1F24  2448              3664*         movea.l A0,A2           ;set pointer address
File: C1.MAIN.TEXT                                                Page  88


1F26  7000              3665*         moveq   #0,D0           ;set write data to current page number
1F28                    3666* IncLp2b
1F28  5280              3667*         addq.l  #1,D0         ;increment write data
1F2A  3480              3668*         move.w  D0,(A2)         ;write mem
1F2C  321A              3669*         move.w  (A2)+,D1        ;read
1F2E  B240              3670*         cmp.w   D0,D1
1F30  56CD  FFF6        3671*         dbne    D5,IncLp2b      ;loop until done
1F34  56CE  FFE2        3672*         dbne    D6,IncLp2a      ;loop until done
1F38  6606              3673*         bne.s   IncLp2C         ;show error
1F3A  6100  E676        3674*         bsr     outdot          ;show dot
1F3E  60CE              3675*         bra.s   IncLp2
1F40  4A62              3676* IncLp2c tst.w   -(A2)
1F42  6100  E616        3677*         bsr     miscmpw
1F46  6100  E64C        3678*         bsr     optcont
1F4A  67DC              3679*         beq.s   Inclp2b
1F4C  6000  FE50        3680*         bra     loops
1F50  0D 204C6F6F70204D 3681* msgloop data.b  DSCcr,' Loop Menu'
1F58  656E75
1F5B  0D 302D447261676F 3682*         data.b  DSCcr,'0-Dragonfly'
1F63  6E666C79
1F67  0D 312D5265616420 3683*         data.b  DSCcr,'1-Read byte'
1F6F  62797465
1F73  0D 322D5772697465 3684*         data.b  DSCcr,'2-Write byte'
1F7B  2062797465
1F80  0D 332D526561642F 3685*         data.b  DSCcr,'3-Read/write byte'
1F88  7772697465206279
1F90  7465
1F92  0D 342D5265616420 3686*         data.b  DSCcr,'4-Read word'
1F9A  776F7264
1F9E  0D 352D5772697465 3687*         data.b  DSCcr,'5-Write word'
1FA6  20776F7264
1FAB  0D 362D526561642F 3688*         data.b  DSCcr,'6-Read/write word'
1FB3  777269746520776F
1FBB  7264
1FBD  0D 372D696E637265 3689*         data.b  DSCcr,'7-incrementing address/data write'
1FC5  6D656E74696E6720
1FCD  616464726573732F
1FD5  6461746120777269
1FDD  7465
1FDF  0D 382D696E637265 3690*         data.b  DSCcr,'8-incrementing address/data read'
1FE7  6D656E74696E6720
1FEF  616464726573732F
1FF7  6461746120726561
1FFF  64
2000  0D 392D5465737420 3691*         data.b  DSCcr,'9-Test loop exit on error and compare loop'
2008  6C6F6F7020657869
2010  74206F6E20657272
2018  6F7220616E642063
2020  6F6D70617265206C
2028  6F6F70
202B  0D 412D5465737420 3692*         data.b  DSCcr,'A-Test loop infinite',DSCcr
2033  6C6F6F7020696E66
203B  696E6974650D 
2041  00                3693*         data.b  0
File: C1.MAIN.TEXT                                                Page  89


2042  0D 41646472657373 3694* msgladd data.b  DSCcr,'Address : ',0
204A  203A2000 
204E  0D 44617461203A20 3695* msgldat data.b  DSCcr,'Data : ',0
2056  00 
2057  0D 436F6D70617269 3696* msgcmpring data.b  DSCcr,'Comparing...',0
205F  6E672E2E2E00 
2065                    3697* endofloopslabel
File: C1.MAIN.TEXT                                                Page  90


                        3699*         include 'C1.DSX'
                        3700*        list on   ;in dsx
                        3701* ; File: DF.DS
                        3702* ; Date: 21-May-84
                        3703* ;
                        3704* ; DISPLAY DRIVER FOR PROM (mary boetcher) 05/18/82
                        3705* ; This is only the terminal version through data comm********************
                        3706* ; BOTH horizontal and vertical display driver
                        3707* ; contains default window records, copies them into memory
                        3708* ; contains default character sets
                        3709* ; no CRTST code: no window functions
      00000004          3710* DSCeot   equ    $04    ;end of transmission (use for end of line on input)
      0000000A          3711* DSClf    equ    $0A    ;line feed character
      0000000D          3712* DSCcr    equ    $0D    ;carriage return character
      0000001B          3713* DSCesc   equ    $1B    ;escape character
      0000007F          3714* DSCdel   equ    $7F    ;delete character
      00000020          3715* DSCblnk  equ    $20    ;blank character
      00000008          3716* DSCbs    equ    $08    ;back space
      00000061          3717* DSClca   equ    $61    ;lower case "a"
      0000007A          3718* DSClcz   equ    $7A    ;lower case "z"
      00000020          3719* DSCdiff  equ    $20    ;difference between upper and lower case
                        3720* ;
                        3721* ;
                        3722* ; DScvtUC - Convert character to upper case
                        3723* ;
                        3724* ;       Enter:  D0.B = ASCII character
                        3725* ;
                        3726* ;       Exit:   D0.B = upper case ASCII character
                        3727* ;
2066  B03C  0061        3728* DScvtUC CMP.B  #DSClca,D0              ;is character lower case?
206A  6B0A              3729*         Bmi.S   DScvtU1                 ;no, return
206C  0C00  007A        3730*         CMPI.B  #DSClcz,D0              ;*
2070  6E04              3731*         Bgt.S   DScvtU1                 ;no, return
2072  0400  0020        3732*         SUBI.B  #DSCdiff,D0             ;convert character to upper case
2076  4E75              3733* DScvtU1 RTS                             ;return
                        3734* 
                        3735* ;
                        3736* ; DSoutst - Output a string
                        3737* ;
                        3738* ;       Enter:  A5.L - Character string pointer
                        3739* ;                      (terminated by 0)
                        3740* ;
                        3741* 
2078  48E7  8004        3742* DSoutst movem.l D0/A5,-(SP)             ;save registers
                        3743*                                         ;
207C  101D              3744* DSout1  move.b  (A5)+,d0                ;get next character
207E  6704              3745*         beq.s   DSout9                  ;finished, return
2080  6120              3746*         bsr.s   DSoutch                 ;output character
2082  60F8              3747*         bra.s   DSout1                  ;get next character
                        3748*                                         ;
2084  4CDF  2001        3749* DSout9  movem.l (SP)+,D0/A5             ;restore registers
2088  4E75              3750*         rts                             ;return
                        3751* 
File: C1.MAIN.TEXT                                                Page  91


                        3753* ;
208A  2F00              3754* DSoutSP move.l  D0,-(SP)
208C  103C  0020        3755*         move.b  #DSCblnk,D0
2090  6110              3756*         bsr.s   DSoutCH
2092  201F              3757*         move.l  (SP)+,D0
2094  4E75              3758*         RTS
                        3759* ;DSoutCR - output a carriage return
2096  2F00              3760* DSoutCr move.l  D0,-(SP)
2098  103C  000D        3761*         move.b  #DSCcr,D0       ;let fall through
209C  6104              3762*         bsr.s   DSoutCH
                        3763* ;       bsr     DSshwch
209E  201F              3764*         move.l  (SP)+,D0
20A0  4E75              3765*         RTS
                        3766* ;
                        3767* ; DSoutch - Output a character
                        3768* ;
                        3769* ;       Enter:  D0.B - Character to output
                        3770* ;
20A2                    3771* DSoutch
20A2                    3772* DSxCrt
20A2  0839  0002  0083  3773*         btst    #bootsw4,IObootsw.l     ;using external CRT?            0.8
20A8  0701  
20AA  6600  003A        3774*         bon     DSputch                 ;yes, use data comm 0           0.8
20AE  48E7  4040        3775*         movem.l a1/d1,-(SP)             ;
20B2  227C  0083  0300  3776*         move.l  #dc0,a1                 ;get UART pointer
20B8  72FF              3777*         moveq   #-1,d1
20BA  0829  0002  0013  3778* DSxCrt1 btst    #DSwrBit,DSuST(a1)      ;is UART output busy?
20C0  56C9  FFF8        3779*         dbne    d1,DSxCrt1              ;yes, try again
20C4  6700  0AB0        3780*         beq     beep            ;beep
20C8  1340  0017        3781*         move.b  d0,dc0d(a1)               ;output the character
20CC  0C00  000D        3782*         cmpi.b  #DSCcr,d0               ;was it a <CR>?
20D0  660E              3783*         bne.s   DSXIT                  ;no, go on
20D2  0839  0001  0080  3784*         btst    #Alfbit,sysflag.l           ;auto line feed?
20D8  0D64  
20DA  6604              3785*         bon.s   DSxit                  ;yes, bypass <LF> insertion
20DC  700A              3786*         moveq   #DSClf,d0               ;add a <LF>
20DE  60DA              3787*         BRA.S   DSxCrt1                 ;output LF
20E0  4CDF  0202        3788* DSxit   movem.l (SP)+,a1/d1
20E4  4E75              3789*         RTS
                        3790* ; DSputch - Display a character
                        3791* ;
                        3792* ;       Enter:  D0.B - Character to output
                        3793* ;
20E6  48E7  FFFE        3794* DSputch MOVEM.L D0-D7/A0-A6,-(SP)       ;save registers
20EA  0240  007F        3795*         andi.w  #$7F,d0                 ;make character 7 bits
20EE  41F9  0080  0D6E  3796*         LEA     wndrcd.l,A0           ;get RAM window record pointer  0.8
20F4  2468  0000        3797*         MOVE.L  WRcharpt(A0),A2         ;get character set record pointer
20F8  4283              3798*         CLR.L   D3                      ;
20FA  1628  0022        3799*         MOVE.B  WRstate(A0),D3          ;
20FE  E34B              3800*         LSL.W   #1,D3                   ;convert to state table index
2100  43F9  0081  2494+ 3801*         LEA     DSsTbl.l,A1               ;
2106  3631  3000        3802*         MOVE.W  0(A1,D3.W),D3           ;D3 = dist from DSsTbl
210A  4EF1  3000        3803*         JMP     0(A1,D3.W)              ;go to current state processing
                        3804*                                         ;
File: C1.MAIN.TEXT                                                Page  92


210E  5228  0022        3805* DSnxtSt ADDQ.B  #1,WRstate(A0)          ;increment for next state
2112  6004              3806*         BRA.S   DSexit                  ;return
                        3807*                                         ;
2114  4228  0022        3808* DSreset CLR.B   WRstate(A0)             ;reset current state
                        3809*                                         ;
2118  4CDF  7FFF        3810* DSexit  MOVEM.L (SP)+,D0-D7/A0-A6       ;restore registers
211C  4E75              3811*         RTS                             ;return
File: C1.MAIN.TEXT                                                Page  93


                        3813* ;
                        3814* ; DSinit - Initialize display driver
                        3815* ;
211E  48E7  08E0        3816* DSinit  MOVEM.L D4/A0-A2,-(SP)          ;save registers
2122  33FC  0068  0080  3817*         MOVE.W  #DSdefOf,scnofs.l     ;set bytes per scan line
2128  0D92  
212A  41F9  0081  2498+ 3818*         LEA     DSwndH.l,A0               ;assume horizontal orientation
2130  45F9  0081  24BC+ 3819*         LEA     DScsetH.l,A2              ;*
2136  0839  0006  0083  3820*         BTST    #vertical,mfpbase+1.l      ;is display horizontal?
213C  0201  
213E  670C              3821*         BOFF.S  DSinit1                 ;yes, go on
2140  41F9  0081  24CE+ 3822*         LEA     DSwndV.l,A0               ;set vertical orientation
2146  45F9  0081  24F2+ 3823*         LEA     DScsetV.l,A2              ;*
214C  43F9  0080  0D6E  3824* DSinit1 LEA     wndrcd.l,A1   ;was cp   ;get pointer to RAM window record 0.8
2152  7823              3825*         MOVEQ   #WRlength-1,D4          ;get window record length       0.6
2154  12D8              3826* DSinit2 MOVE.B  (A0)+,(A1)+             ;copy window record to RAM      0.6
2156  51CC  FFFC        3827*         DBRA    D4,DSinit2              ;*
215A  41F9  0080  0D6E  3828*         LEA     wndrcd.l,A0           ;get RAM window record pointer    0.8
2160  214A  0000        3829*         MOVE.L  A2,WRcharpt(A0)         ;set character set record pointer
2164  6100  0198        3830*         BSR     DScurs                  ;display cursor on screen
2168  4CDF  0710        3831*         MOVEM.L (SP)+,D4/A0-A2          ;restore registers
216C  4E75              3832*         RTS                             ;return
                        3833* 
                        3834* 
                        3835* 
                        3836* 
File: C1.MAIN.TEXT                                                Page  94


216E  B03C  001B        3838* DSst0   CMP.B   #DSCesc,D0              ;is char ESC?
2172  679A              3839*         BEQ.S   DSnxtSt                 ;yes, go to next state
2174  B06A  0008        3840*         CMP.W   CSfrstch(A2),D0         ;ascinum < first char?
2178  650A              3841*         BLO.S   DSctl                   ;yes, it's a control char
217A  6100  004A        3842*         BSR     DSshwCh                 ;display character
217E  6100  0102        3843*         BSR     DSincx                  ;inccurx
2182  6094              3844*         BRA.S   DSexit                  ;return
                        3845* 
2184  5140              3846* DSctl   SUBQ.W  #8,D0                   ;commence decoding ctrl char
2186  6B90              3847*         BMI.S   DSexit                  ;
2188  0C40  0005        3848*         CMPI.W  #5,D0                   ;ascinum in [8..13]?
218C  628A              3849*         BHI.S   DSexit                  ;yes, do cursor ctrl
218E  47F9  0081  2476+ 3850*         LEA     DScTbl.l,A3               ;A3==>jump table for ctrl chars
2194  E348              3851*         LSL.W   #1,D0                   ;make it word count
2196  487A  FF80+       3852*         PEA     DSexit                  ;ensure RTS to exit
219A  6022              3853*         BRA.S   DSgortn                 ;goto proper routine       0.8
                        3854* 
219C  4241              3855* DSesc   CLR.W   D1                      ;initialize index reg
219E  47F9  0081  2482+ 3856*         LEA     DSeTbl.l,A3               ;A3==> beginning of table
                        3857*                                         ;
21A4  B073  1000        3858* DSesc1  CMP.W   0(A3,D1),D0             ;does table entry match char?
21A8  670C              3859*         BEQ.S   DSesc2                  ;yes, go on
21AA  5841              3860*         ADDQ.W  #4,D1                   ;go to next entry
21AC  4A73  1000        3861*         TST.W   0(A3,D1)                ;end of table?
21B0  6AF2              3862*         BPL.S   DSesc1                  ;no, loop
21B2  6000  FF60        3863*         BRA     DSreset                 ;return
                        3864*                                         ;
21B6  3001              3865* DSesc2  MOVE.W  D1,D0                   ;set D0 to table offset
21B8  5440              3866*         ADDQ.W  #2,D0                   ;
21BA  487A  FF58+       3867*         PEA     DSreset                 ;ensure RTS to reset state
21BE  3033  0000        3868* DSgortn MOVE.W  0(A3,D0),D0             ;D0 is offset from DSeTbl
21C2  4EF3  0000        3869*         JMP     0(A3,D0)                ;jump to proper routine
                        3870* 
File: C1.MAIN.TEXT                                                Page  95


                        3872* ;
                        3873* ; DSshwCh - Display character
                        3874* ;
                        3875* ;       Enter:  A0.L = window record pointer
                        3876* ;               A2.L = character set record pointer
                        3877* ;               D0.W = ASCII character
                        3878* ;
                        3879* ;       Note:   Character set must be in bytes, not words
                        3880* ;
21C6  6100  FE9E        3881* DSshwCh BSR     DScvtUC                 ;convert character to upper case
21CA  B06A  0008        3882*         CMP.W   CSfrstch(A2),D0         ;is character in character set?
21CE  6D06              3883*         BLT.S   DSshow1                 ;no, output space
21D0  B06A  000A        3884*         CMP.W   CSlastch(A2),D0         ;*
21D4  6F04              3885*         BLE.S   DSshow2                 ;yes, output character
21D6  303C  0020        3886* DSshow1 MOVE.W  #DSCblnk,D0             ;no, output space
                        3887*                                         ;
21DA  906A  0008        3888* DSshow2 SUB.W   CSfrstch(A2),D0         ;get relative character position
21DE  47F9  0081  2504+ 3889*         LEA     DScsetV+CSdata.l,a3       ;get pointer to character data
21E4  C0FC  0006        3890*         MULU    #DScellW,D0             ;*
21E8  D7C0              3891*         ADDA.L  D0,A3                   ;*
21EA  2868  0008        3892*         MOVE.L  WRcuradr(A0),A4         ;get current character address
21EE  322A  0004        3893*         MOVE.W  CSlpch(A2),D1           ;get number of scan lines for character
21F2  5341              3894*         SUBQ.W  #1,D1                   ;get count for DBRA
21F4  3639  0080  0D92  3895*         MOVE.W  scnofs.l,D3           ;get scan line length
21FA  3A28  001A        3896*         MOVE.W  WRbitofs(A0),D5         ;get bit offset of character in cell
21FE  2C2A  000C        3897*         MOVE.L  CSmask(A2),D6           ;get character mask
2202  0828  0000  0021  3898*         BTST    #vert,WRattr2(A0)       ;is this vertical orientation?
2208  6718              3899*         BOFF.S  DSshow6                 ;no, output horizontal character
                        3900*         ;
                        3901*         ; output vertical orientation character
                        3902*         ;
220A  2006              3903*         MOVE.L  D6,D0                   ;
220C  4680              3904*         NOT.L   D0                      ;D0 = inverted mask
                        3905* ;       ROR.L   D5,D6                   ;D6 = positioned mask
220E  EBBE              3906*         ROL.L   D5,D6                   ;D6 = positioned mask******&*
2210  141B              3907* DSshow3 MOVE.B  (A3)+,D2                ;D2 = char data
                        3908* ;       LSL.W   #8,D2                   ;
                        3909* ;       SWAP    D2                      ;get char in high word
2212  C480              3910*         AND.L   D0,D2                   ;clear rest of source char
2214  EAAA              3911*         LSR.L   D5,D2                   ;position source char
2216  CD94              3912*         AND.L   D6,(A4)                 ;clear dest char area
2218  8594              3913*         OR.L    D2,(A4)                 ;move in character
                        3914* ;       SUBA.W  D3,A4                   ;
221A  D8C3              3915*         ADDA.W  D3,A4                   ;****************************
221C  51C9  FFF2        3916*         DBRA    D1,DSshow3              ;repeat for D1:=CSlpch-1 to 0
2220  605A              3917*         BRA.S   DSshow9                 ;return
                        3918* 
File: C1.MAIN.TEXT                                                Page  96


                        3920*         ;
                        3921*         ; output horizontal orientation character
                        3922*         ;
2222  4A64              3923* DSshow6 TST.W   -(A4)                   ;A4==>long word with cell
                        3924* ;       ROL.L   D5,D6                   ;D6 = positioned mask
2224  EABE              3925*         ROR.L   D5,D6                   ;D6 = positioned mask*************
2226  2806              3926*         MOVE.L  D6,D4                   ;
2228  4684              3927*         NOT.L   D4                      ;D4 = inverted mask
222A  7007              3928*         moveq   #7,d0                   ;use 8 bits of character data
                        3929*                                         ;
222C  4282              3930* DSshow7 clr.l   d2                      ;clear current scan line of character
222E  4A40              3931*         tst.w   d0                      ;have we used 8 bits of character data?
2230  6D3C              3932*         blt.s   DSshw76                 ;yes, pad with space
2232  012B  0000        3933*         btst    d0,0(a3)                ;construct next horizontal character
2236  6704              3934*         boff.s  DSshw71                 ;*  from vertical character data
2238  08C2  0000        3935*         bset    #0,d2                   ;*
                        3936* ;       bset    #5,d2                   ;*     ************
223C  012B  0001        3937* DSshw71 btst    d0,1(a3)                ;*
2240  6704              3938*         boff.s  DSshw72                 ;*
2242  08C2  0001        3939*         bset    #1,d2                   ;*
                        3940* ;       bset    #4,d2                   ;*     ************
2246  012B  0002        3941* DSshw72 btst    d0,2(a3)                ;*
224A  6704              3942*         boff.s  DSshw73                 ;*
224C  08C2  0002        3943*         bset    #2,d2                   ;*
                        3944* ;       bset    #3,d2                   ;*     ************
2250  012B  0003        3945* DSshw73 btst    d0,3(a3)                ;*
2254  6704              3946*         boff.s  DSshw74                 ;*
2256  08C2  0003        3947*         bset    #3,d2                   ;*
                        3948* ;       bset    #2,d2                   ;*     *************
225A  012B  0004        3949* DSshw74 btst    d0,4(a3)                ;*
225E  6704              3950*         boff.s  DSshw75                 ;*
2260  08C2  0004        3951*         bset    #4,d2                   ;*
                        3952* ;       bset    #1,d2                   ;*     *************
2264  012B  0005        3953* DSshw75 btst    d0,5(a3)                ;*
2268  6704              3954*         boff.s  DSshw76                 ;*
226A  08C2  0005        3955*         bset    #5,d2                   ;*
                        3956* ;       bset    #0,d2                   ;*     *************
226E  5340              3957* DSshw76 subq    #1,d0                   ;indicate another bit used
2270  EBAA              3958*         LSL.L   D5,D2                   ;shift char into position
                        3959* ;       LSR.L   D5,D2    ;shift char into position ************
2272  CD94              3960*         AND.L   D6,(A4)                 ;
2274  8594              3961*         OR.L    D2,(A4)                 ;
                        3962* ;;;;;   SUBA.W  D3,A4                   ;      only one not flipped back*****
2276  D8C3              3963*         ADDA.W  D3,A4                   ;      *************
2278  51C9  FFB2        3964*         DBRA    D1,DSshow7              ;
227C  4E75              3965* DSshow9 RTS                             ;return
                        3966* 
File: C1.MAIN.TEXT                                                Page  97


                        3968* ;
                        3969* ; DScrsR -- cursor right
                        3970* ;
227E  6100  0080        3971* DScrsR  BSR     DScurs0                 ;remove cursor
2282  3228  0016        3972* DSincx  MOVE.W  WRcursx(A0),D1          ;get current cursor X position
2286  5C41              3973*         ADDQ.W  #DScellW,D1             ;increment 1 character space    0.6
2288  3141  0016        3974*         MOVE.W  D1,WRcursx(A0)          ;save new cursor X position     0.6
228C  B268  0012        3975*         CMP.W   WRlngthx(A0),D1         ;at end of line?                0.6
2290  6C08              3976*         BGE.S   DSrtrn1                 ;yes, do carriage return        0.6
2292  606A              3977*         BRA.S   DScurs                  ;show cursor                    0.6
                        3978* 
                        3979* ;
                        3980* ; DScrsU -- cursor up
                        3981* ;
2294  616A              3982* DScrsU  BSR.S   DScurs0                 ;remove cursor
2296  604A              3983*         BRA.S   DSdecy                  ;decrement cursor Y position
                        3984* 
                        3985* ;
                        3986* ; DSrtrn -- return
                        3987* ;
2298  6166              3988* DSrtrn  BSR.S   DScurs0                 ;remove cursor
229A  4268  0016        3989* DSrtrn1 CLR.W   WRcursx(A0)             ;zero current cursor X position
229E  0839  0001  0080  3990*         btst    #Alfbit,sysflag.l           ;auto line feed?
22A4  0D64  
22A6  6604              3991*         bon.s   DSincy                 ;yes, bypass <LF> insertion
                        3992* ;       BTST    #1,CPdspflg.w           ;auto line feed?
                        3993* ;       BOFF.S  DSincy                  ;no, increment cursor Y position
22A8  6054              3994*         BRA.S   DScurs                  ;show cursor
                        3995* 
                        3996* ;
                        3997* ; DScrsD -- cursor down
                        3998* ;
22AA  6154              3999* DScrsD  BSR.S   DScurs0                 ;remove cursor
22AC  3228  0018        4000* DSincy  MOVE.W  WRcursy(A0),D1          ;get current cursor Y position
22B0  0641  000A        4001*         ADDI.W  #DScellY,D1             ;increment 1 character space    0.6
22B4  3141  0018        4002*         MOVE.W  D1,WRcursy(A0)          ;save new cursor Y position     0.6
22B8  B268  0014        4003*         CMP.W   WRlngthy(A0),D1         ;at bottom of screen?           0.6
22BC  6F40              4004*         BLE.S   DScurs                  ;on bottom line?                0.6
22BE  6000  0086        4005*         BRA     DSclAL                  ;yes, wrap to home position     0.6
                        4006* 
                        4007* ;
                        4008* ; DScrsL -- cursor left
                        4009* ;
22C2  613C              4010* DScrsL  BSR.S   DScurs0                 ;remove cursor
22C4  4A68  0016        4011* DSdecx  TST.W   WRcursx(A0)             ;at beginning of line?
22C8  6712              4012*         BEQ.S   DSwrapx                 ;yes, wrap to previous line
22CA  5D68  0016        4013*         SUBQ.W  #DScellW,WRcursx(A0)    ;decrement 1 character space
22CE  602E              4014*         BRA.S   DScurs                  ;show cursor
                        4015* 
File: C1.MAIN.TEXT                                                Page  98


                        4017* ;
                        4018* ; DScrsH -- cursor home
                        4019* ;
22D0  612E              4020* DScrsH  BSR.S   DScurs0                 ;remove cursor
22D2  4268  0016        4021* DScrsH1 CLR.W   WRcursx(A0)             ;zero current cursor X position
22D6  4268  0018        4022*         CLR.W   WRcursy(A0)             ;zero current cursor Y position
22DA  6022              4023*         BRA.S   DScurs                  ;show cursor
                        4024* 
22DC  6112              4025* DSwrapx BSR.S   DSwrap                  ;
22DE  3140  0016        4026*         MOVE.W  D0,WRcursx(A0)          ;
22E2  4A68  0018        4027* DSdecy  TST.W   WRcursy(A0)             ;at top line?
22E6  6716              4028*         BEQ.S   DScurs                  ;yes, show cursor
22E8  0468  000A  0018  4029*         SUBI.W  #DScellY,WRcursy(A0)    ;decrement 1 character space
22EE  600E              4030*         BRA.S   DScurs                  ;show cursor
                        4031* 
22F0  4280              4032* DSwrap  CLR.L   D0                      ;get current cursor X position
22F2  3028  0012        4033*         MOVE.W  WRlngthx(A0),D0         ;*
22F6  7406              4034*         MOVEQ   #DScellW,D2             ;get character width
22F8  80C2              4035*         DIVU    D2,D0                   ;
22FA  C0C2              4036*         MULU    D2,D0                   ;
22FC  4E75              4037*         RTS                             ;return
                        4038* 
22FE  6132              4039* DScurs  BSR.S   DScrsAd                 ;compute cursor address
2300  322A  0004        4040* DScurs0 MOVE.W  CSlpch(A2),D1           ;get scan lines per character
2304  5341              4041*         SUBQ.W  #1,D1                   ;set loop counter
2306  2868  0008        4042*         MOVE.L  WRcuradr(A0),A4         ;get current cursor address
230A  3A28  001A        4043*         MOVE.W  WRbitofs(A0),D5         ;get current cursor bit offset
230E  2E2A  000C        4044*         MOVE.L  CSmask(A2),D7           ;get character mask
2312  0828  0000  0021  4045*         BTST    #vert,WRattr2(A0)       ;vertical orientation?
2318  6704              4046*         BOFF.S  DScurs1                 ;no
                        4047* ;       ROR.L   D5,D7                   ;
231A  EBBF              4048*         ROL.L   D5,D7                   ;   ***************
231C  6004              4049*         BRA.S   DScurs2                 ;
231E  4A64              4050* DScurs1 TST.W   -(A4)                   ;
                        4051* ;       ROL.L   D5,D7                   ;
2320  EABF              4052*         ROR.L   D5,D7                   ;   **************
2322  4687              4053* DScurs2 NOT.L   D7                      ;D7 = positioned inverted mask
2324  BF94              4054* DScurs3 EOR.L   D7,(A4)                 ;invert character
2326  D8F9  0080  0D92  4055*         addA.W  scnofs.l,A4           ;*
                        4056* ;       SUBA.W  scnofs.l,A4           ;*
232C  51C9  FFF6        4057*         DBRA    D1,DScurs3              ;*
2330  4E75              4058*         RTS                             ;return
                        4059* 
2332  4CA8  0060  0016  4060* DScrsAd MOVEM.W WRcursx(A0),D5-D6       ;get current cursor position
2338  6100  00FC        4061*         BSR     DSaddr                  ;compute cursor address
233C  3147  001A        4062*         MOVE.W  D7,WRbitofs(A0)         ;save cursor bit offset
2340  214C  0008        4063*         MOVE.L  A4,WRcuradr(A0)         ;save cursor address
2344  4E75              4064*         RTS                             ;return
                        4065* 
File: C1.MAIN.TEXT                                                Page  99


                        4067* ;
                        4068* ; DSclAL -- clear screen
                        4069* ;
2346  6100  FF8A        4070* DSclAL  BSR     DScrsH1                 ;home cursor
                        4071* 
                        4072* ;
                        4073* ; DSclES -- clear to end of screen
                        4074* ;
234A  6138              4075* DSclES  BSR.S   DSclEL                  ;first clear this line
234C  0828  0000  0021  4076*         BTST    #vert,WRattr2(A0)       ;vertical orientation?
2352  6618              4077*         BON.S   DSclES2                 ;yes, clear vertical screen
                        4078*                                         ; --- clear to end of horizontal screen
2354  3C28  0018        4079*         MOVE.W  WRcursy(A0),D6          ;get current cursor Y position
2358  0646  000A        4080* DSclES1 ADDI.W  #DScellY,D6             ;increment to next line
235C  3028  0014        4081*         MOVE.W  WRlngthy(A0),D0         ;get bottom of screen limit
2360  BC40              4082*         CMP.W   D0,D6                   ;at bottom of screen?
2362  6C1E              4083*         BGE.S   DSclES9                 ;yes, return
2364  9046              4084*         SUB.W   D6,D0                   ;compute number of scan lines to clear
2366  4243              4085*         CLR.W   D3                      ;set starting X position to 0
2368  615A              4086*         BSR.S   DSclrH                  ;clear to bottom of screen
236A  6016              4087*         BRA.S   DSclES9                 ;return
                        4088*                                         ; --- clear to end of vertical screen
236C  3028  0018        4089* DSclES2 MOVE.W  WRcursy(A0),D0          ;get current cursor Y position
2370  0640  000A        4090* DSclES3 ADDI.W  #DScellY,D0             ;increment to next line
2374  B068  0014        4091*         CMP.W   WRlngthy(A0),D0         ;at bottom of screen?
2378  6C08              4092*         BGE.S   DSclES9                 ;yes, return
237A  3C00              4093*         MOVE.W  D0,D6                   ;
237C  4245              4094*         CLR.W   D5                      ;
237E  6124              4095*         BSR.S   DSclrV                  ;clear one vertical line
2380  60EE              4096*         BRA.S   DSclES3                 ;repeat until all lines cleared
                        4097*                                         ;
2382  4E75              4098* DSclES9 RTS                             ;return
                        4099* 
                        4100* ;
                        4101* ; DSclEL -- clear to end of line
                        4102* ;
2384  6100  FF7A        4103* DSclEL  BSR     DScurs0                 ;remove cursor
2388  4CA8  0060  0016  4104*         MOVEM.W WRcursx(A0),D5-D6       ;get current cursor X and Y
238E  0828  0000  0021  4105*         BTST    #vert,WRattr2(A0)       ;vertical orientation
2394  6704              4106*         BOFF.S  DSclEL1                 ;no, clear horizontal line
2396  610C              4107*         BSR.S   DSclrV                  ;clear one vertical line
2398  6006              4108*         BRA.S   DSclEL2                 ;show cursor
                        4109*                                         ;
239A  7009              4110* DSclEL1 MOVEQ   #DScellY-1,D0           ;D0 = #scanlines to clear
239C  3605              4111*         MOVE.W  D5,D3                   ;
239E  6124              4112*         BSR.S   DSclrH                  ;clear one horizontal line
23A0  6000  FF5E        4113* DSclEL2 BRA     DScurs0                 ;show cursor
                        4114* 
File: C1.MAIN.TEXT                                                Page 100


23A4  3828  0012        4116* DSclrV  MOVE.W  WRlngthx(A0),D4         ;get length of line
23A8  9845              4117*         SUB.W   D5,D4                   ;compute number of scan lines clear
23AA  6100  008A        4118*         BSR     DSaddr                  ;compute cursor address
23AE  3239  0080  0D92  4119*         MOVE.W  scnofs.l,D1           ;get bytes per scan line
23B4  2C2A  000C        4120*         MOVE.L  CSmask(A2),D6           ;get character mask
23B8  EEBE              4121*         ROR.L   D7,D6                   ;align character mask
23BA  CD94              4122* DSclrV1 AND.L   D6,(A4)                 ;clear one scan line
                        4123* ;       SUBA.W  D1,A4                   ;compute address of next scan line
23BC  D8C1              4124*         ADDA.W  D1,A4     ;compute address of next scan line  ************
23BE  51CC  FFFA        4125*         DBRA    D4,DSclrV1              ;repeat to end of line
23C2  4E75              4126*         RTS                             ;return
                        4127* 
23C4  3828  0012        4128* DSclrH  MOVE.W  WRlngthx(A0),D4         ;D5 = x, D6 = y
23C8  5244              4129*         ADDQ.W  #1,D4                   ;
23CA  3A04              4130*         MOVE.W  D4,D5                   ;
23CC  9843              4131*         SUB.W   D3,D4                   ;
23CE  6100  0066        4132*         BSR     DSaddr                  ;A4 = addr(x,y), D7 = bitnum
23D2  9847              4133*         SUB.W   D7,D4                   ;
23D4  4A47              4134*         TST.W   D7                      ;
23D6  6602              4135*         BNE.S   DSclrH1                 ;
23D8  4A5C              4136*         TST.W   (A4)+                   ;
23DA  3604              4137* DSclrH1 MOVE.W  D4,D3                   ;
23DC  0243  000F        4138*         ANDI.W  #$F,D3                  ;
23E0  E844              4139*         ASR.W   #4,D4                   ;
23E2  5344              4140*         SUBQ.W  #1,D4                   ;
23E4  72FF              4141*         MOVEQ   #-1,D1                  ;
23E6  3401              4142*         MOVE.W  D1,D2                   ;
23E8  EF69              4143*         LSL.W   D7,D1                   ;
23EA  E66A              4144*         LSR.W   D3,D2                   ;
23EC  2A4C              4145* DSclrH2 MOVE.L  A4,A5                   ;
23EE  4A47              4146*         TST.W   D7                      ;
23F0  6702              4147*         BEQ.S   DSclrH3                 ;
23F2  C35D              4148*         AND.W   D1,(A5)+                ;
23F4  3C04              4149* DSclrH3 MOVE.W  D4,D6                   ;
23F6  6B06              4150*         BMI.S   DSclrH5                 ;
23F8  425D              4151* DSclrH4 CLR.W   (A5)+                   ;
23FA  51CE  FFFC        4152*         DBRA    D6,DSclrH4              ;
23FE  4A43              4153* DSclrH5 TST.W   D3                      ;
2400  6702              4154*         BEQ.S   DSclrH6                 ;
2402  C555              4155*         AND.W   D2,(A5)                 ;
2404  98F9  0080  0D92  4156* DSclrH6 SUBA.W  scnofs.l,A4           ;
240A  51C8  FFE0        4157*         DBRA    D0,DSclrH2              ;
240E  4E75              4158*         RTS                             ;return
                        4159* 
File: C1.MAIN.TEXT                                                Page 101


2410  3028  0016        4161* DStab   MOVE.W  WRcursx(A0),D0          ;get current cursor X position
2414  C0BC  0000  FFFF  4162*         AND.L   #$FFFF,D0               ;clear hi word
241A  7430              4163*         MOVEQ   #DScellW*8,D2           ;
241C  80C2              4164*         DIVU    D2,D0                   ;find next tab to right
241E  5240              4165*         ADDQ.W  #1,D0                   ;
2420  C0C2              4166*         MULU    D2,D0                   ;
2422  B068  0012        4167*         CMP.W   WRlngthx(A0),D0         ;new x > right?
2426  6302              4168*         BLS.S   DStab1                  ;no, change x
2428  4E75              4169*         RTS                             ;return
                        4170* 
242A  6100  FED4        4171* DStab1  BSR     DScurs0                 ;remove cursor
242E  3140  0016        4172*         MOVE.W  D0,WRcursx(A0)          ;save new cursor X position
2432  6000  FECA        4173*         BRA     DScurs                  ;show cursor
                        4174* 
                        4175* ;
                        4176* ; DSaddr -- compute cursor address
                        4177* ;
                        4178* ;       Enter:  D5 = x
                        4179* ;               D6 = y
                        4180* ;
                        4181* ;       Exit:   DSaddr (x,y) in A4, bit offset in D7
                        4182* ;
2436  2868  0004        4183* DSaddr  MOVEA.L WRhomept(A0),A4         ;get home pointer for orientation
243A  0828  0000  0021  4184*         BTST    #vert,WRattr2(A0)       ;vertical orientation?
2440  661A              4185*         BON.S   DSaddrV                 ;yes, compute address for vertical
                        4186*                                         ;
2442  DA68  000C        4187* DSaddrH ADD.W   WRhomeof(A0),D5         ;
2446  3E05              4188*         MOVE.W  D5,D7                   ;
2448  0247  000F        4189*         ANDI.W  #$F,D7                  ;
244C  E845              4190*         ASR.W   #4,D5                   ;
244E  E345              4191*         ASL.W   #1,D5                   ;
2450  98C5              4192*         SUBA.W  D5,A4                   ;
2452  CCF9  0080  0D92  4193*         MULU    scnofs.l,D6           ;
                        4194* ;       SUBA.L  D6,A4                   ;
2458  D9C6              4195*         addA.L  D6,A4                   ;
245A  4E75              4196*         RTS                             ;return
                        4197*                                         ;
245C  DC68  000C        4198* DSaddrV ADD.W   WRhomeof(A0),D6         ;
2460  3E06              4199*         MOVE.W  D6,D7                   ;
2462  0247  000F        4200*         ANDI.W  #$F,D7                  ;
2466  E846              4201*         ASR.W   #4,D6                   ;
2468  E346              4202*         ASL.W   #1,D6                   ;
246A  D8C6              4203*         ADDA.W  D6,A4                   ;
246C  CAF9  0080  0D92  4204*         MULU    scnofs.l,D5           ;
                        4205* ;       SUBA.L  D5,A4                   ;
2472  D9C5              4206*         adda.L  D5,A4                   ;
2474  4E75              4207*         RTS                             ;return
                        4208* 
File: C1.MAIN.TEXT                                                Page 102


                        4210* ;
                        4211* ; jump tables
                        4212* ;
2476  FE4C              4213* DScTbl  DATA.W  DScrsL-DScTbl           ;ctl-H: back space
2478  FF9A              4214*         DATA.W  DStab-DScTbl            ;ctl-I: tab
247A  FE34              4215*         DATA.W  DScrsD-DScTbl           ;ctl-J: line feed
247C  FE1E              4216*         DATA.W  DScrsU-DScTbl           ;ctl-K: cursor up
247E  FE08              4217*         DATA.W  DScrsR-DScTbl           ;ctl-L: cursor right
2480  FE22              4218*         DATA.W  DSrtrn-DScTbl           ;ctl-M: carriage return
                        4219* 
2482  0048  FE4E        4220* DSeTbl  DATA.W  $48,DScrsH-DSeTbl       ;esc-H: home cursor
2486  004A  FEC4        4221*         DATA.W  $4A,DSclAL-DSeTbl       ;esc-J: clear screen
248A  004B  FF02        4222*         DATA.W  $4B,DSclEL-DSeTbl       ;esc-K: clear to end of line
248E  0059  FEC8        4223*         DATA.W  $59,DSclES-DSeTbl       ;esc-Y: clear to end of screen
2492  FFFF              4224*         DATA.W  -1                      ;end of table
                        4225* 
2494  FCDA              4226* DSsTbl  DATA.W  DSst0-DSsTbl            ;state 0
2496  FD08              4227*         DATA.W  DSesc-DSsTbl            ;state 1
                        4228* 
2498  008124BC+         4229* DSwndH  DATA.L  DScsetH                 ;WRcharpt
249C  00880000          4230*         DATA.L  DShomeH                 ;home
24A0  00880000          4231*         DATA.L  DShomeH                 ;address
24A4  0000  0000  0000  4232*         DATA.W  0,0,0                   ;WRhomeof,WRbasex,WRbasey
24AA  0317  026B        4233*         DATA.W  DSmaxXH,DSmaxYH         ;right,bottom
24AE  0000  0000  0000  4234*         DATA.W  0,0,0                   ;x,y,WRbitofs
24B4  0000  026B        4235*         DATA.W  0,DSmaxYH               ;WRgrorgx,WRgrorgy
24B8  00 1C             4236*         DATA.B  0,$1C                   ;attr1,attr2
24BA  00 24             4237*         DATA.B  0,WRlength              ;state, WRrcdlen
                        4238* 
24BC  00812504+         4239* DScsetH DATA.L  DScsetV+CSdata          ;character set record pointer
24C0  000A  0006        4240*         DATA.W  DScellY,DScellW         ;CSlpch, CSbpch
24C4  0020  005A        4241*         DATA.W  32,90                   ;CSfrstch, CSlastch
24C8  FFFF  FFC0  0000  4242*         DATA.W  $FFFF,$FFC0,0           ;mask, dummy, attribs
                        4243*         ;
                        4244*         ; use vertical character set data
                        4245*         ;
                        4246* 
File: C1.MAIN.TEXT                                                Page 103


24CE  008124F2+         4248* DSwndV  DATA.L  DScsetV                 ;WRcharpt
24D2  00880064          4249*         DATA.L  DShomeV                 ;home
24D6  00880064          4250*         DATA.L  DShomeV                 ;address
24DA  0000  0000  0000  4251*         DATA.W  0,0,0                   ;WRhomeof,WRbasex,WRbasey
24E0  0269  031F        4252*         DATA.W  DSmaxXV,DSmaxYV         ;right,bottom
24E4  0000  0000  0000  4253*         DATA.W  0,0,0                   ;x,y,WRbitofs
24EA  0000  031F        4254*         DATA.W  0,DSmaxYV               ;WRgrorgx,WRgrorgy
24EE  00 1D             4255*         DATA.B  0,$1D                   ;attr1,attr2
24F0  00 24             4256*         DATA.B  0,WRlength              ;state, WRrcdlen
                        4257* 
24F2  00812504+         4258* DScsetV DATA.L  DScsetV+CSdata          ;character set record pointer
24F6  0006  000A        4259*         DATA.W  DScellW,DScellY         ;CSlpch, CSbpch
24FA  0020  005A        4260*         DATA.W  32,90                   ;CSfrstch, CSlastch
24FE  003F  FFFF  0100  4261*         DATA.W  $003F,$FFFF,256         ;mask, dummy, attribs
                        4262*         ;
                        4263*         ; vertical character set data
                        4264*         ;
2504  00 00 00 00 00 00 4265*         DATA.B  0,0,0,0,0,0             ; blank
250A  00 00 BF 00 00 00 4266*         DATA.B  0,0,$BF,0,0,0           ; !
2510  00 00 07 00 07 00 4267*         DATA.B  0,0,7,0,7,0         ; "
2516  00 14 7F 14 7F 14 4268*         DATA.B  0,$14,$7F,$14,$7F,$14   ; #
251C  00 21 2A 7F 2A 42 4269*         DATA.B  0,$21,$2A,$7F,$2A,$42   ; $
2522  00 62 64 08 13 23 4270*         DATA.B  0,$62,$64,$08,$13,$23   ; %
2528  00 50 20 53 49 36 4271*         DATA.B  0,$50,$20,$53,$49,$36   ; &
252E  00 00 03 04 00 00 4272*         DATA.B  0,0,$03,$04,0,0         ; '
2534  00 00 41 22 1C 00 4273*         DATA.B  0,0,$41,$22,$1C,0       ; (
253A  00 1C 22 41 00 00 4274*         DATA.B  0,$1C,$22,$41,0,0       ; )
2540  00 10 54 38 54 10 4275*         DATA.B  0,$10,$54,$38,$54,$10   ; *
2546  00 10 10 7C 10 10 4276*         DATA.B  0,$10,$10,$7C,$10,$10   ; +
254C  00 00 00 E0 80 00 4277*         DATA.B  0,0,0,$E0,$80,0         ; ,
2552  00 08 08 08 08 08 4278*         DATA.B  0,$08,$08,$08,$08,$08   ; -
2558  00 00 00 40 00 00 4279*         DATA.B  0,0,0,$40,0,0           ; .
255E  00 02 04 08 10 20 4280*         DATA.B  0,$02,$04,$08,$10,$20   ; /
2564  00 3E 45 49 51 3E 4281*         DATA.B  0,$3E,$45,$49,$51,$3E   ; 0
256A  00 00 40 7F 42 00 4282*         DATA.B  0,0,$40,$7F,$42,0       ; 1
2570  00 46 51 49 51 62 4283*         DATA.B  0,$46,$51,$49,$51,$62   ; 2
2576  00 33 4D 49 41 21 4284*         DATA.B  0,$33,$4D,$49,$41,$21   ; 3
257C  00 10 7F 12 14 18 4285*         DATA.B  0,$10,$7F,$12,$14,$18   ; 4
2582  00 39 45 45 45 27 4286*         DATA.B  0,$39,$45,$45,$45,$27   ; 5
2588  00 38 49 49 4A 3C 4287*         DATA.B  0,$38,$49,$49,$4A,$3C   ; 6
258E  00 03 05 09 71 01 4288*         DATA.B  0,$03,$05,$09,$71,$01   ; 7
2594  00 36 49 49 49 36 4289*         DATA.B  0,$36,$49,$49,$49,$36   ; 8
259A  00 1E 29 49 49 43 4290*         DATA.B  0,$1E,$29,$49,$49,$43   ; 9
25A0  00 00 00 42 00 00 4291*         DATA.B  0,0,0,$42,0,0           ; :
25A6  00 00 00 64 80 00 4292*         DATA.B  0,0,0,$64,$80,0         ; ;
25AC  00 41 22 14 08 00 4293*         DATA.B  0,$41,$22,$14,$08,0     ; <
25B2  00 14 14 14 14 00 4294*         DATA.B  0,$14,$14,$14,$14,0     ; =
25B8  00 08 14 22 41 00 4295*         DATA.B  0,$08,$14,$22,$41,0     ; >
25BE  00 02 05 59 01 02 4296*         DATA.B  0,$02,$05,$59,$01,$02   ; ?
25C4  00 5E 59 59 41 3E 4297*         DATA.B  0,$5E,$59,$59,$41,$3E   ; @
25CA  00 7C 12 11 12 7C 4298*         DATA.B  0,$7C,$12,$11,$12,$7C   ; A
25D0  00 36 49 49 49 7F 4299*         DATA.B  0,$36,$49,$49,$49,$7F   ; B
25D6  00 22 41 41 41 3E 4300*         DATA.B  0,$22,$41,$41,$41,$3E   ; C
25DC  00 3E 41 41 41 7F 4301*         DATA.B  0,$3E,$41,$41,$41,$7F   ; D
File: C1.MAIN.TEXT                                                Page 104


25E2  00 41 41 49 49 7F 4302*         DATA.B  0,$41,$41,$49,$49,$7F   ; E
25E8  00 01 01 09 09 7F 4303*         DATA.B  0,$01,$01,$09,$09,$7F   ; F
25EE  00 32 51 51 41 3E 4304*         DATA.B  0,$32,$51,$51,$41,$3E   ; G
25F4  00 7F 08 08 08 7F 4305*         DATA.B  0,$7F,$08,$08,$08,$7F   ; H
25FA  00 00 41 7F 41 00 4306*         DATA.B  0,0,$41,$7f,$41,0       ; I
2600  00 01 3F 41 41 20 4307*         DATA.B  0,$01,$3f,$41,$41,$20   ; J
2606  00 41 22 14 08 7F 4308*         DATA.B  0,$41,$22,$14,$08,$7f   ; K
260C  00 40 40 40 40 7F 4309*         DATA.B  0,$40,$40,$40,$40,$7f   ; L
2612  00 7F 02 02 02 7F 4310*         DATA.B  0,$7f,$02,$02,$02,$7f   ; M
2618  00 7F 10 08 04 7F 4311*         DATA.B  0,$7f,$10,$08,$04,$7f   ; N
261E  00 3E 41 41 41 3E 4312*         DATA.B  0,$3e,$41,$41,$41,$3e   ; O
2624  00 06 09 09 09 7F 4313*         DATA.B  0,$06,$09,$09,$09,$7f   ; P
262A  00 5E 21 51 41 3E 4314*         DATA.B  0,$5e,$21,$51,$41,$3e   ; Q
2630  00 46 29 19 09 7F 4315*         DATA.B  0,$46,$29,$19,$09,$7f   ; R
2636  00 32 19 19 19 26 4316*         DATA.B  0,$32,$19,$19,$19,$26   ; S
263C  00 01 01 7F 01 01 4317*         DATA.B  0,$01,$01,$7f,$01,$01   ; T
2642  00 3F 40 40 40 3F 4318*         DATA.B  0,$3f,$40,$40,$40,$3f   ; U
2648  00 1F 20 40 20 1F 4319*         DATA.B  0,$1f,$20,$40,$20,$1f   ; V
264E  00 3F 40 38 40 3F 4320*         DATA.B  0,$3f,$40,$38,$40,$3f   ; W
2654  00 63 14 08 14 63 4321*         DATA.B  0,$63,$14,$08,$14,$63   ; X
265A  00 03 04 78 04 03 4322*         DATA.B  0,$03,$04,$78,$04,$03   ; Y
2660  00 43 45 49 51 61 4323*         DATA.B  0,$43,$45,$49,$51,$61   ; Z
2666  00 00 48 48 48 7F 4324*         DATA.B  0,$00,$48,$48,$48,$7f   ; [
266C  00 20 10 08 04 02 4325*         DATA.B  0,$20,$10,$08,$04,$02   ; \
2672  00 7F 48 48 48 00 4326*         DATA.B  0,$7f,$48,$48,$48,$00   ; ]
2678  00 00 03 04 03 00 4327*         DATA.B  0,$00,$03,$04,$03,$00   ; ^
267E  80 80 80 80 80 80 4328*         DATA.B  $80,$80,$80,$80,$80,$80 ; _
2684  0000              4329*         DATA.W  0
                        4330* ; BOTH horizontal and vertical display driver
                        4331* ; contains default window records, copies them into memory
                        4332* ; contains default character sets
                        4333* ; no CRTST code: no window functions
                        4334* ;
File: C1.MAIN.TEXT                                                Page 105


                        4336* ;                      port 0
                        4337* ;KBgetUc - get an upper case character  from port 0
2686  6104              4338* KBgetUC bsr.s   KBgetCH         ;get character
2688  6000  F9DC        4339*         bra     DScvtUC         ;convert to upper case and return
268C  48E7  00FE        4340* KBgetch MOVEM.L A0-A6,-(SP)             ;save all address registers
2690  227C  0083  0300  4341* KBgchra move.l  #Dc0,a1 ;68681 BASE     ;get UART pointer
2696  0839  0004  0083  4342*         btst    #bootsw2,IObootsw.l     ;using external terminal?       0.8
269C  0701  
269E  672A              4343*         boff.s  MSgchra                 ;no, go to mouse
26A0  0829  0000  0013  4344* KBgchr0 btst    #KBrdBit,KBuSt(a1)      ;is char in UART?
                        4345*  ;      boff.s  KBgchr0                 ;no, wait some more
26A6  6722              4346*         boff.s  MSgchra                 ;no, wait some more
26A8  1029  0017        4347*         move.b  KBuDa(a1),d0            ;get character
26AC  0839  0002  0080  4348*         btst    #Echobit,SysFlag.l      ;echo mode?
26B2  0D64  
26B4  6604              4349*         bon.s   KBgchrE                  ;if bit set then do not echo
26B6  6100  F9EA        4350*         bsr     DSoutch                 ;echo character
26BA  4CDF  7F00        4351* KBgchrE MOVEM.L (SP)+,A0-A6             ;restore callers address regs   0.7
                        4352* ;       bsr.s   MSgetUC                 ;*************************
                        4353* ;       bsr.s   kbrgetUC                ;*************************
26BE  4E75              4354*         RTS                             ;return
                        4355* 
                        4356* ;                       mouse
                        4357* ;MSgetUc - get an upper case character  from mouse
26C0  6104              4358* MSgetUC bsr.s   MSgetCH         ;get character
26C2  6000  F9A2        4359*         bra     DScvtUC         ;convert to upper case and return
26C6  48E7  00FE        4360* MSgetch MOVEM.L A0-A6,-(SP)             ;save all address registers
26CA  227C  0083  0300  4361* MSgchra move.l  #Dc0,a1  ;68681 BASE    ;get UART pointer
26D0  0839  0003  0083  4362*         btst    #bootsw3,IObootsw.l     ;using mouse?
26D6  0701  
26D8  6724              4363*         boff.s  KBrgchra                ;no, go to keyboard
26DA  0829  0000  0003  4364* MSgchr0 btst    #MSrdBit,MSuSt(a1)      ;is char in UART?
                        4365* ;       boff.s  MSgchr0                 ;no, wait some more
26E0  671C              4366*         boff.s  KBrgchra                 ;no, wait some more
26E2  1029  0007        4367*         move.b  MSuDa(a1),d0            ;get character
26E6  0839  0002  0080  4368*         btst    #Echobit,SysFlag.l      ;echo mode?
26EC  0D64  
26EE  6604              4369*         bon.s   MSgchrE                  ;if bit set then do not echo
26F0  6100  F9B0        4370*         bsr     DSoutch                 ;echo character
26F4  4CDF  7F00        4371* MSgchrE MOVEM.L (SP)+,A0-A6             ;restore callers address regs   0.7
26F8  4E75              4372*         RTS                             ;return
                        4373* 
                        4374* ;                       keyboard
                        4375* ;kbrgetUc - get an upper case character  from own keyboard
26FA                    4376* kbrgetUC ;bsr.s   kbrgetCH         ;get character
26FA  48E7  00FE        4377* kbrgetch MOVEM.L A0-A6,-(SP)             ;save all address registers
26FE  227C  0083  0200  4378* kbrgchra move.l  #kbrdbase,a1  ;68901 BASE    ;get kbrd pointer
2704  0839  0005  0083  4379*          btst    #bootsw1,IObootsw.l     ;using external keyboard        0.8
270A  0701  
270C  6782              4380*          boff.s  kbgchra                  ;no, go to external terminal
270E  0829  0007  002B  4381* kbrgchr0 btst    #kbrRdBit,kbStat(a1)      ;is char in UART?
                        4382* ;        boff.s  kbrgchr0                 ;no, wait some more
2714  6700  FF7A        4383*          boff    kbgchra                  ;no, wait some more
2718  1029  002F        4384*          move.b  kbData(a1),d0            ;get character
File: C1.MAIN.TEXT                                                Page 106


271C  C03C  007F        4385*          and.b   #$7f,d0                   ;kill up-down bit(parity)
2720  43F9  0081  273E+ 4386*          lea.l   kbrdTabl.l,a1              ;start of keyboard table
2726  1031  0000        4387*          move.b  0(a1,d0),d0               ;replace key number with
                        4388*                                          ;key, then continue
272A  0839  0002  0080  4389*          btst    #Echobit,SysFlag.l      ;echo mode?
2730  0D64  
2732  6604              4390*          bon.s   kbrgchrE                  ;if bit set then do not echo
2734  6100  F96C        4391*          bsr     DSoutch                 ;echo character
2738  4CDF  7F00        4392* kbrgchrE MOVEM.L (SP)+,A0-A6             ;restore callers address regs   0.7
273C  4E75              4393*          RTS                             ;return
                        4394* 
273E  20333920362C2D0D  4395* kbrdTabl  data.b  ' ', '3', '9', ' ', '6', ',', '-', DSCcr   ;00-07
2746  2031372034383532  4396*           data.b  ' ', '1', '7', ' ', '4', '8', '5', '2'     ;08-0f
274E  3D205B08 0D 5D5C  4397*           data.b  '=', ' ', '[', dscbs, dsccr, ']', '\', ' ' ;10-07
2755  20
2756  302F502D3B602720  4398*           data.b  '0', '/', 'P', '-', ';', '`', '''', ' '    ;18-0f
275E  3132333435202020  4399*           data.b  '1', '2', '3', '4', '5', ' ', ' ', ' '     ;20-07
2766  2425525446475642  4400*           data.b  '$', '%', 'R', 'T', 'F', 'G', 'V', 'B'     ;28-0f
276E  4023574553445843  4401*           data.b  '@', '#', 'W', 'E', 'S', 'D', 'X', 'C'     ;30-07
2776  2021205120412041  4402*           data.b  ' ', '!', ' ', 'Q', ' ', 'A', ' ', 'A'     ;38-0f
277E  5E265955484A4E4D  4403*           data.b  '^', '&', 'Y', 'U', 'H', 'J', 'N', 'M'     ;40-07
2786  202020202030202E  4404*           data.b  ' ', ' ', ' ', ' ', ' ', '0', ' ', '.'     ;48-0f
278E  2A28494F4B4C3C3E  4405*           data.b  '*', '(', 'I', 'O', 'K', 'L', '<', '>'     ;50-07
2796  3637383930202020  4406*           data.b  '6', '7', '8', '9', '0', ' ', ' ', ' '     ;58-0f
                        4407*       ;   list off      ;in dsx
File: C1.MAIN.TEXT                                                Page 107


                        4409*         include 'SIV.EXC'
                        4410* ; include file merc.exc - interrupts, buserror vectors.
                        4411* ;**********************************************************************
                        4412* ;*                                                                    *
                        4413* ;*   Set up exception vectors--must be done for both altmaps          *
                        4414* ;*                                                                    *
                        4415* ;**********************************************************************
                        4416* 
279E                    4417* sEXvec
279E  45F9  0080  0008  4418*         lea     (BEVec+SysBase).l,A2
27A4  43FA  0140+       4419*         lea     BusErr,A1
27A8  24C9              4420*         move.l  A1,(A2)+
                        4421* ;set up vector for address erorr
27AA  43FA  0130+       4422*         lea     AddrErr,A1
27AE  24C9              4423*         move.l  A1,(A2)+
                        4424* ;set up vector for illegal instruction
27B0  43FA  00F8+       4425*         lea     IllInst,A1
27B4  24C9              4426*         move.l  A1,(A2)+
                        4427* ;set up vector for zero divide
27B6  43FA  0054+       4428*         lea     badentry,A1
27BA  24C9              4429*         move.l  A1,(A2)+
                        4430* ;set up vector for check instruction
27BC  43FA  004E+       4431*         lea     badentry,A1
27C0  24C9              4432*         move.l  A1,(A2)+
                        4433* ;set up vector for trap on overflow instruction
27C2  43FA  0048+       4434*         lea     badentry,A1
27C6  24C9              4435*         move.l  A1,(A2)+
                        4436* ;set up vector for privilege violation
27C8  43FA  00E6+       4437*         lea     Privilege,A1
27CC  24C9              4438*         move.l  A1,(A2)+
                        4439* ;set up vector for spurious interrupt
27CE  45F9  0080  0060  4440*         lea     (SpIVec+SysBase).l,A2
27D4  43FA  00E0+       4441*         lea     Spurious,A1
27D8  24C9              4442*         move.l  A1,(A2)+
                        4443* ;set up Interrupt vector level 1
27DA  43FA  0086+       4444*         lea     IntSlot,A1
27DE  24C9              4445*         move.l  A1,(A2)+
                        4446* ;set up Interrupt vector level 2
27E0  43FA  006E+       4447*         lea     IntDC1,A1
27E4  24C9              4448*         move.l  A1,(A2)+
                        4449* ;set up Interrupt vector level 3
27E6  43FA  0060+       4450*         lea     IntOmni,A1
27EA  24C9              4451*         move.l  A1,(A2)+
                        4452* ;set up Interrupt vector level 4
27EC  43FA  0048+       4453*         lea     IntDC0,A1
27F0  24C9              4454*         move.l  A1,(A2)+
                        4455* ;set up Interrupt vector level 5
27F2  43FA  0038+       4456*         lea     IntTimr,A1
27F6  24C9              4457*         move.l  A1,(A2)+
                        4458* ;set up Interrupt vector level 6
27F8  43FA  0020+       4459*         lea     IntKybd,A1
27FC  24C9              4460*         move.l  A1,(A2)+
                        4461* ;set up Interrupt vector level 7
27FE  43FA  007A+       4462*         lea     Intlvl7,A1
File: C1.MAIN.TEXT                                                Page 108


2802  24C9              4463*         move.l  A1,(A2)+        ;1
                        4464* ;set up trap 0 vector for exitting user mode
2804  43FA  009E+       4465*         lea     Trap0,A1
2808  24C9              4466*         move.l  A1,(A2)+
                        4467* 
280A  4E75              4468*         RTS
                        4469* ;
280C                    4470* badentry
280C  6100  DB38        4471*         bsr     unkcmd
2810  46DF              4472*         move.w  (SP)+,SR        ;restore status register
2812  DFFC  0000  0006  4473*         adda.l  #6,SP           ;adjust stack
2818  4E75              4474*         RTS
                        4475* ;
                        4476* ; INTkybd -- process KEYBOARD interrupt (ignore interrupt)
                        4477* ;
281A  0039  0002  0003  4478* INTkybd ori.b   #$02,$30F05.L   ;lvl 6 (KYBD) - turn off recv interrupt
2820  0F05  
2822  0239  00F3  0003  4479*         andi.b  #$F3,$30F05.L   ;lvl 6 (KYBD) - turn off xmit interrupt
2828  0F05  
282A  4E73              4480*         rte                     ;return from interrupt
                        4481* 
                        4482* ;
                        4483* ; INTtimr -- process TIMER interrupt (ignore interrupt)
                        4484* ;
282C  13FC  007F  0003  4485* INTtimr move.b  #$7F,$30F7D.L   ;lvl 5 (TIMER) - turn off VIA interrupt
2832  0F7D  
2834  4E73              4486*         rte                     ;return from interrupt
                        4487* 
                        4488* ;
                        4489* ; INTdc0  -- process DATACOMM0 interrupt (ignore interrupt)
                        4490* ;
2836  0039  0002  0003  4491* INTdc0  ori.b   #$02,$30F25.L   ;lvl 4 (DC0) - turn off recv interrupt
283C  0F25  
283E  0239  00F3  0003  4492*         andi.b  #$F3,$30F25.L   ;lvl 4 (DC0) - turn off xmit interrupt
2844  0F25  
2846  4E73              4493*         rte                     ;return from interrupt
                        4494* 
                        4495* ;
                        4496* ; INTomni -- process OMNINET interrupt (ignore interrupt)
                        4497* ;
2848  4A39  0003  0FC1  4498* INTomni tst.b   $30FC1.L        ;lvl 3 (OMNINET) - reset interrupt
284E  4E73              4499*         rte                     ;return from interrupt
                        4500* 
                        4501* ;
                        4502* ; INTdc1  -- process DATACOMM1 interrupt (ignore interrupt)
                        4503* ;
2850  0039  0002  0003  4504* INTdc1  ori.b   #$02,$30F45.L   ;lvl 2 (DC1) - turn off recv interrupt
2856  0F45  
2858  0239  00F3  0003  4505*         andi.b  #$F3,$30F45.L   ;lvl 2 (DC1) - turn off xmit interrupt
285E  0F45  
2860  4E73              4506*         rte                     ;return from interrupt
                        4507* 
                        4508*             ;INT..., SlotAdr
                        4509* ;
File: C1.MAIN.TEXT                                                Page 109


                        4510* ; INTslot -- process SLOT interrupt (ignore interrupt)
                        4511* ;
2862  48E7  8080        4512* INTslot movem.l D0/A0,-(SP)     ;save registers
2866  41F9  0003  0F7F  4513*         lea     $30F7F.L,A0     ;get pointer to port A ORA
286C  1010              4514*         move.b  (A0),D0         ;read port A w/o handshake
286E  0840  0007        4515*         bchg    #7,D0           ;toggle IOX
2872  1080              4516*         move.b  D0,(A0)         ;write new IOX
2874  4CDF  0101        4517*         movem.l (SP)+,D0/A0     ;restore registers
2878  4E73              4518*         rte                     ;return from interrupt
                        4519* ;
                        4520* ; INTlvl7  -- process level 7 interrupt
                        4521* ;
287A  46FC  2700        4522* INTlvl7 move.w  #$2700,SR       ;reset status register
287E  2E7C  0080  0FFC  4523*         movea.l #istack,A7      ;stack pointer
2884  4BFA  011D+       4524*         lea     msgnmi,A5
2888  6100  F7EE        4525*         bsr     DSoutst       ;
288C  47F9  0084  0003  4526*         lea     CTXreg.l,A3     ;read context register
2892  1E13              4527*         move.b  (A3),D7         ;save current value
2894  4213              4528*         clr.b   (A3)            ;zero context register
2896  1038  0000        4529*         move.b  0.w,D0          ;read ram
289A  1687              4530*         move.b  D7,(A3)         ;reset context register
289C  6100  E1A4        4531*         bsr     SetER           ;show and or set error register
28A0  6000  DA4E        4532*         bra     Dragon
                        4533* ;
                        4534* ;   Trap 0 exception vector - top of stack is status register
                        4535* ;   Set 68000 to supervisor mode from user mode
28A4  3EBC  2700        4536* Trap0   move.w  #$2700,(A7)
28A8  4E73              4537*         RTE
                        4538* 
                        4539* ;   Illegal Instruction vector
28AA  4BFA  00A5+       4540* IllInst lea     msgIllInst,A5
28AE  600C              4541*         bra.s   EndVec
                        4542* 
                        4543* ;   Privilege exception vector
28B0                    4544* Privilege
28B0  4BFA  00B4+       4545*         lea     msgPrivViol,A5
28B4  6006              4546*         bra.s   EndVec
                        4547* 
                        4548* ;   Spurious Interrupt  vector
28B6                    4549* Spurious
28B6  2F0D              4550*         move.l A5,-(SP)
28B8  4BFA  00C1+       4551*         lea     msgSpurious,A5
                        4552* 
                        4553* ;**********************************************************************
                        4554* ;*                                                                    *
                        4555* ;*   End exception vector handling routines--returns to mbug or uxmon *
                        4556* ;*   a7 -- top of stack must be sr then pc                            *
                        4557* ;**********************************************************************
28BC  6100  F7BA        4558* EndVec  bsr     DSoutst
28C0  7C02              4559*         moveq   #2,D6
28C2  301F              4560*         move.w  (SP)+,D0        ;get status register
28C4  6100  DBFA        4561*         bsr     outhex          ;display it
28C8  6100  F7C0        4562*         bsr     dsoutsp         ;a space
28CC  7C03              4563*         moveq   #3,D6           ;display 3 bytes
File: C1.MAIN.TEXT                                                Page 110


28CE  201F              4564*         move.l  (A7)+,D0        ;get program counter
28D0  6100  DBEE        4565*         bsr     outhex          ;show it
28D4  DFFC  0000  0004  4566*         adda.l  #4,SP           ;adjust stack pointer
28DA  601E              4567*         bra.s   endexc0
                        4568* 
                        4569* ;   Address Error exception vector
28DC                    4570* AddrErr
28DC  4BFA  0064+       4571*         lea     msgAddrErr,A5
28E0  2C4F              4572*         movea.l A7,A6
28E2  6120              4573*         bsr.s   DSPstack
28E4  6014              4574*         bra.s   EndEXC0
28E6                    4575* BUSERR
28E6  7000              4576*         moveq   #0,D0           ;zero register
28E8  1039  0080  0D94  4577*         move.b  BEflag.l,D0     ;get offset from memory
28EE  6600  EDD6        4578*         bne     ETBErtn         ;go to bus error return for error tests
28F2  4BFA  0042+       4579* BEnorm  lea     msgbuserr,A5    ;mesg - "bus error"
28F6  2C4F              4580*         movea.l A7,A6           ;save stack pointer for display stack
28F8  610A              4581*         bsr.s   DSPstack
28FA  2E7C  0080  0FFC  4582* EndEXC0 move.l  #istack,A7      ;initialize stack
2900  6000  D9EE        4583*         bra     Dragon
                        4584* ;
                        4585* ; Routine to display stack from Group 0 exceptions
                        4586* ; Enter A5-message to print with original a5 saved on stack
                        4587* ; will dump all registers then go to debug mode
                        4588* ; ****modified for 68010****
2904                    4589* DSPStack
2904  6100  F772        4590*         bsr     DSoutst
                        4591* 
2908  4BFA  0085+       4592*         lea     msgSTACK,A5      ;information byte
290C  6100  F76A        4593*         bsr     DSoutst         ;output it
2910  7C02              4594*         moveq   #2,D6           ;
2912  7A06              4595*         moveq   #6,D5          ;dump 7 rows
2914  7803              4596* BO2     moveq   #3,D4           ;of 4 words each
2916  301E              4597* BO3     move.w  (A6)+,D0        ;get  word
2918  6100  DBA6        4598*         bsr     outhex          ;display hex
291C  6100  F76C        4599*         bsr     DSoutSP         ;Display a space
2920  51CC  FFF4        4600*         dbra    D4,BO3          ;loop
2924  6100  F770        4601*         bsr     DSoutCR         ;a CR
2928  51CD  FFEA        4602*         dbra    D5,BO2          ;loop
292C  3016              4603*         move.w  (A6),D0         ;1 more to do
292E  6100  DB90        4604*         bsr     outhex          ;*
2932  6000  F762        4605*         bra     DSoutcr         ;*
                        4606* ;
                        4607* ;vector messages
                        4608* ;
2936  0D 42757320457272 4609* msgbuserr   data.b  DSCcr,'Bus Error',DSCcr,0
293E  6F720D 00 
2942  4164647265737320  4610* msgAddrErr  data.b  'Address Error',DSCcr,0
294A  4572726F720D 00 
2951  496C6C6567616C20  4611* msgIllInst  data.b  'Illegal Instruction',DSCcr,0
2959  496E737472756374
2961  696F6E0D 00 
2966  50726976696C6567  4612* msgPrivviol data.b  'Privilege Violation',DSCcr,0
296E  652056696F6C6174
File: C1.MAIN.TEXT                                                Page 111


2976  696F6E0D 00 
297B  53707572696F7573  4613* msgSpurious data.b  'Spurious Interrupt',DSCcr,0
2983  20496E7465727275
298B  70740D 00 
298F  47726F7570203020  4614* msgSTACK    data.b  'Group 0 Stack dump',DSCcr,0
2997  537461636B206475
299F  6D700D 00 
29A3  0D 4E4D492000     4615* msgNMI      data.b  DSCcr,'NMI ',0
29A9                    4616* vecendlabel
                        4617* 
                        4618*         include 'DMA'
                        4619* ;Memory to memory
                        4620* ;chain cannot be used; it is only available for single address dma
                        4621* ;DCR Device Control Register
                        4622* ;    Burst                      00......        (ignored)
                        4623* ;    68000 dual address         ..00....
                        4624* ;    Port Size 16               ....1...
                        4625* ;    Peripheral Control         .....000        = status
      00000008          4626* DCRdata3        equ     $08
                        4627* 
                        4628* ;OCR   Operation Control Register
                        4629* ;    Direction Memory -> Device 0.......
                        4630* ;    Size = 16 (could be long)  .001....
                        4631* ;    No Chain                   ....00..
                        4632* ;    Auto Request Max Rate      ......01
      00000011          4633* OCRdata3        equ     $11
      00000811          4634* DCROCRdata3     equ     $0811   ;load DCR and OCR together
                        4635* 
                        4636* ;SCR    Sequence Control Register
                        4637* ;first four bits                0000....
                        4638* ;    Memory Address Register    ....01..      increment
                        4639* ;    Device Address Register    ......01      increment
      00000005          4640* SCRdata3        equ     $05
                        4641* 
                        4642* ;CCR   Channel Control Register
                        4643* ;starts opertation with $80
      00000080          4644* CCRdata3        equ     $80
                        4645* 
                        4646* ;CPR   Channel Priority register  0 for now  noone else is working
      00000000          4647* CPRdata3        equ     $00
                        4648* ;CSR   Channel Status Register
                        4649* ;CER   Channel Error Register
                        4650* ;GCR   General Control Register  to control bandwidth used on channel
      00000000          4651* GCRdata3        equ     $00
      00880000          4652* Homebyte       equ     $880000   ;top of screen, left corner, part of frame
      00880068          4653* Firstline      equ     homebyte+104
      008800D0          4654* Secondline     equ     firstline+104
      0088FB78          4655* lastline       equ     firstline+618*104
                        4656* 
                        4657* ;MFC DFC BFC function codes for memory, device, base
      00000005          4658* MFCdata3        equ     $05     ;supervisor
      00000005          4659* DFCdata3        equ     $05     ;supervisor
      00000005          4660* BFCdata3        equ     $05     ;supervisor
                        4661* 
File: C1.MAIN.TEXT                                                Page 112


      00000076          4662* NIVdata3        equ     $76
      00000077          4663* EIVdata3        equ     $77
                        4664* ;Purpose: to barrel smooth scroll one screen
                        4665* ;move first line into buffer
                        4666* ;DMA move second through last line to first through last but one line
                        4667* ;move buffer to last line
                        4668* ;repeat 618 times
      00830800          4669* Dma0base       equ     $830800
      00830840          4670* Dma1base       equ     $830840
      00830880          4671* Dma2base       equ     $830880
                        4672* 
                        4673* ;Use DMAPort 3
      008308C0          4674* Dma3base       equ     $8308c0
      00000000          4675* DMACSR         equ     0
      00000001          4676* DMACER         equ     1
      00000004          4677* DMADCR         equ     4
      00000005          4678* DMAOCR         equ     5
      00000006          4679* DMASCR         equ     6
      00000007          4680* DMACCR         equ     7
      0000000A          4681* DMAMTC         equ    $a
      0000000C          4682* DMAMAR         equ    $c
      00000014          4683* DMADAR         equ    $14
      0000001A          4684* DMABTC         equ    $1a
      00000015          4685* DMANIV         equ    $15
      00000017          4686* DMAEIV         equ    $17
      00000019          4687* DMAMFC         equ    $19
      0000001D          4688* DMACPR         equ    $1d
      00000021          4689* DMADFC         equ    $21
      00000039          4690* DMABFC         equ    $39
      0000003F          4691* DMAGCR         equ    $3f
                        4692* 
                        4693* 
29AA  41F9  0083  08C0  4694* INITDMA3       lea     Dma3base.l,a0
29B0  30BC  0811        4695*                move    #DCROCRdata3,(a0)
29B4  117C  0005  0006  4696*                move.b  #SCRdata3,DMASCR(a0)
29BA  117C  0076  0015  4697*                move.b  #NIVdata3,DMANIV(a0)
29C0  117C  0077  0015  4698*                move.b  #EIVdata3,DMANIV(a0)
29C6  117C  0005  0019  4699*                move.b  #MFCdata3,DMAMFC(a0)
29CC  117C  0005  0021  4700*                move.b  #DFCdata3,DMADFC(a0)
29D2  117C  0000  001D  4701*                move.b  #CPRdata3,DMACPR(a0)
29D8  117C  0000  003F  4702*                move.b  #GCRdata3,DMAGCR(a0)
29DE  4E75              4703*                        rts ;from initDMA3
                        4704* 
29E0  217C  0088  00D0  4705* GO3            move.l  #secondline,DMAMAR(a0)
29E6  000C  
29E8  217C  0088  0068  4706*                move.l  #firstline,DMADAR(a0)
29EE  0014  
29F0  317C  7D54  000A  4707*                move    #32084,DMAMTC(a0)       ;number of words to move
29F6  117C  0080  0007  4708*                move.b  #CCRdata3,DMACCR(a0)      ;start transfer
29FC  0828  0007  0000  4709* wait           btst    #7,DMACSR(a0)
                        4710* 
2A02  61A6              4711* BEGIN          bsr.s   initdma3
2A04  323C  026A        4712*                move    #618,d1                 ;do this 618 times
2A08  41F9  0088  0068  4713* scroll         lea     Firstline.l,a0          ;move first line to buffer
File: C1.MAIN.TEXT                                                Page 113


2A0E  43F9  0000  0400  4714*                lea     $400.l,a1               ;buffer
2A14  303C  0012        4715*                move    #18,d0
2A18  22D8              4716* tobuffer       move.l  (a0)+,(a1)+
2A1A  51C8  FFFC        4717*                dbra    d0,tobuffer
2A1E  61C0              4718*                bsr.s   go3
2A20  43F9  0088  FB78  4719*                lea     lastline.l,a1            ;move first line to buffer
2A26  41F9  0000  0400  4720*                lea     $400.l,a0                ;buffer
2A2C  303C  0012        4721*                move    #18,d0
2A30  22D8              4722* frombuffer     move.l  (a0)+,(a1)+
2A32  51C8  FFE4        4723*                dbra    d0,tobuffer
2A36  51C9  FFD0        4724*                dbra    d1,scroll
                        4725* 
                        4726* 
                        4727* ;DEvice to memory
                        4728* ;chain cannot be used; it is only available for single address dma
                        4729* ;DCR Device Control Register
                        4730* ;    Cycle steal without hold   10......        (ignored)
                        4731* ;    68000 dual address         ..00....
                        4732* ;    Port Size 8                ....0...
                        4733* ;    Peripheral Control         .....000        = status
      00000080          4734* DCRdata0        equ     $80
                        4735* 
                        4736* ;OCR   Operation Control Register
                        4737* ;    Direction Device -> memory 1.......
                        4738* ;    Size = 8                   .000....
                        4739* ;    No Chain                   ....00..
                        4740* ;    Ext Request                ......10
      00000082          4741* OCRdata0        equ     $82
      00008082          4742* DCROCR0data     equ     $8082   ;load DCR and OCR together
      00008002          4743* DCROCR1data     equ     $8002   ;transmit
                        4744* ;SCR    Sequence Control Register
                        4745* ;first four bits                0000....
                        4746* ;    Memory Address Register    ....01..      increment
                        4747* ;    Device Address Register    ......00      no count
      00000004          4748* SCRdata0        equ     $04
                        4749* 
                        4750* ;CCR   Channel Control Register
                        4751* ;starts opertation with $80
      00000080          4752* CCRdata0        equ     $80
                        4753* 
                        4754* ;CPR   Channel Priority register  3 receiver top priority
      00000003          4755* CPRdata0        equ     $03
      00000002          4756* CPRdata1        equ     $02
                        4757* ;CSR   Channel Status Register
                        4758* ;CER   Channel Error Register
                        4759* ;GCR   General Control Register  to control bandwidth used on channel
      00000000          4760* GCRdata0        equ     $00
                        4761* 
                        4762* ;MFC DFC BFC function codes for memory, device, base
      00000005          4763* MFCdata0        equ     $05     ;supervisor
      00000005          4764* DFCdata0        equ     $05     ;supervisor
      00000005          4765* BFCdata0        equ     $05     ;supervisor
                        4766* 
      00000070          4767* NIVdata0        equ     $70
File: C1.MAIN.TEXT                                                Page 114


      00000071          4768* EIVdata0        equ     $71
                        4769* ;dmapor0               device to memory
      00830433          4770* Dusartrec       equ     $830433
      00830433          4771* Dusarttx        equ     $830433
      00830420          4772* Dusartb         equ     $830420
      00000001          4773* cmd             equ     $01
      00000003          4774* mod             equ     $03
      00000005          4775* int             equ     $05
      00000009          4776* syn             equ     $09
      0000000B          4777* rxc             equ     $0b
      0000000D          4778* txc             equ     $0d
      00000015          4779* tcb             equ     $15
      00000017          4780* brg             equ     $17
      00000019          4781* dmivr           equ     $19
      00000000          4782* cmdbdata        equ     $00
      00000020          4783* modbdata        equ     $20    ;sdlc x1 clock sync mode no parity
      00000000          4784* intbdata        equ     $00    ;dont interrupt
      0000007E          4785* syncdata        equ     $7e    ;sdlc flag
      000000C1          4786* rxcbdata        equ     $c1    ;8 bits/char rx enable maybe cshould be hunt
      000000C7          4787* txcbdata        equ     $c7    ;8 bits/char dtr rts tx enable
      00000001          4788* tcrbdata        equ     $01    ;div by 1 time const
      00000007          4789* brgbdata        equ     $07    ;tx internal, brg/4 rx external  ;switch switches!!
      00000060          4790* dmivrbda        equ     $60    ;proper place for dusart
                        4791* ;device to memory
                        4792* ;all same as channel 0 except direction and priority
2A3A  41F9  0083  0420  4793* INITDMA0       lea     Dusartb.l,a0
2A40  117C  0000  0001  4794*                move.b  #cmdbdata,cmd(a0)
2A46  117C  0020  0003  4795*                move.b  #modbdata,mod(a0)
2A4C  117C  0000  0005  4796*                move.b  #intbdata,int(a0)
2A52  117C  007E  0009  4797*                move.b  #syncdata,syn(a0)
2A58  117C  00C1  000B  4798*                move.b  #rxcbdata,rxc(a0)
2A5E  117C  00C7  000D  4799*                move.b  #txcbdata,txc(a0)
2A64  117C  0001  0015  4800*                move.b  #tcrbdata,tcb(a0)
2A6A  117C  0007  0017  4801*                move.b  #brgbdata,brg(a0)
2A70  117C  0060  0019  4802*                move.b  #dmivrbda,dmivr(a0)
                        4803* 
2A76  41F9  0083  0880  4804*                lea     Dma2base.l,a0
2A7C  30BC  8082        4805*                move    #DCROCR0data,(a0)
2A80  117C  0004  0006  4806*                move.b  #SCRdata0,DMASCR(a0)
2A86  117C  0070  0015  4807*                move.b  #NIVdata0,DMANIV(a0)
2A8C  117C  0071  0015  4808*                move.b  #EIVdata0,DMANIV(a0)
2A92  117C  0005  0019  4809*                move.b  #MFCdata0,DMAMFC(a0)
2A98  117C  0005  0021  4810*                move.b  #DFCdata0,DMADFC(a0)
2A9E  117C  0002  001D  4811*                move.b  #CPRdata1,DMACPR(a0)
2AA4  117C  0000  003F  4812*                move.b  #GCRdata0,DMAGCR(a0)
2AAA  4E75              4813*                        rts ;from initDMA0
                        4814* 
2AAC  217C  0088  0068  4815* GO0            move.l  #firstline,DMAMAR(a0)
2AB2  000C  
2AB4  217C  0083  0433  4816*                move.l  #Dusartrec,DMADAR(a0)
2ABA  0014  
2ABC  317C  7D54  000A  4817*                move    #32084,DMAMTC(a0)       ;number of words to move
2AC2  117C  0080  0007  4818*                move.b  #CCRdata3,DMACCR(a0)      ;start transfer
2AC8  0828  0007  0000  4819* wait0          btst    #7,DMACSR(a0)
File: C1.MAIN.TEXT                                                Page 115


2ACE  66F8              4820*                bne.s   wait0
2AD0  4E75              4821*                rts
                        4822* ;dmaport1              memory to device
                        4823* ;both have pcl only, no ack, have to be dual address 8 bit
2AD2  6100  FF66        4824*                bsr     initdma0
2AD6  60D4              4825*                bra.s   go0
                        4826* ;memory to device
                        4827* 
2AD8  41F9  0083  0420  4828* INITDMA1       lea     Dusartb.l,a0
2ADE  117C  0000  0001  4829*                move.b  #cmdbdata,cmd(a0)
2AE4  117C  0020  0003  4830*                move.b  #modbdata,mod(a0)
2AEA  117C  0000  0005  4831*                move.b  #intbdata,int(a0)
2AF0  117C  007E  0009  4832*                move.b  #syncdata,syn(a0)
2AF6  117C  00C1  000B  4833*                move.b  #rxcbdata,rxc(a0)
2AFC  117C  00C7  000D  4834*                move.b  #txcbdata,txc(a0)
2B02  117C  0001  0015  4835*                move.b  #tcrbdata,tcb(a0)
2B08  117C  0007  0017  4836*                move.b  #brgbdata,brg(a0)
2B0E  117C  0060  0019  4837*                move.b  #dmivrbda,dmivr(a0)
                        4838* 
2B14  41F9  0083  08C0  4839*                lea     Dma3base.l,a0
2B1A  30BC  8002        4840*                move    #DCROCR1data,(a0)
2B1E  117C  0004  0006  4841*                move.b  #SCRdata0,DMASCR(a0)
2B24  117C  0070  0015  4842*                move.b  #NIVdata0,DMANIV(a0)
2B2A  117C  0071  0015  4843*                move.b  #EIVdata0,DMANIV(a0)
2B30  117C  0005  0019  4844*                move.b  #MFCdata0,DMAMFC(a0)
2B36  117C  0005  0021  4845*                move.b  #DFCdata0,DMADFC(a0)
2B3C  117C  0003  001D  4846*                move.b  #CPRdata0,DMACPR(a0)
2B42  117C  0000  003F  4847*                move.b  #GCRdata0,DMAGCR(a0)
2B48  4E75              4848*                        rts ;from initDMA0
                        4849* 
2B4A  217C  0088  0068  4850* GO1            move.l  #firstline,DMAMAR(a0)
2B50  000C  
2B52  217C  0083  0433  4851*                move.l  #Dusarttx ,DMADAR(a0)
2B58  0014  
2B5A  317C  7D54  000A  4852*                move    #32084,DMAMTC(a0)       ;number of words to move
2B60  117C  0080  0007  4853*                move.b  #CCRdata3,DMACCR(a0)      ;start transfer
2B66  0828  0007  0000  4854* wait1          btst    #7,DMACSR(a0)
2B6C  66F8              4855*                bne.s   wait1
2B6E  4E75              4856*                rts
                        4857* ;dmaport1              memory to device
                        4858* ;both have pcl only, no ack, have to be dual address 8 bit
2B70  6100  FF66        4859*                bsr     initdma1
2B74  60D4              4860*                bra.s   go1
                        4861* ;              end     begin
                        4862* 
                        4863* 
                        4864* 
                        4865* 
File: C1.MAIN.TEXT                                                Page 116


                        4867*         ; ; Beep  -- output an error tone subroutine
                        4868* ;
                        4869* 
2B76  48E7  C0C2        4870* Beep    movem.l a0-a1/a6/d0-d1,-(sp);save registers
2B7A  2C7C  0083  0200  4871*         move.l  #mfpbase,a6     ;get pointer to mfp locations
2B80  002E  0070  001D  4872*         ori.b   #startCtrC,tcdcr(a6)
2B86  1D7C  0010  0023  4873*         move.b  #highbeep,$23(a6);output a high pitch error tone
2B8C  303C  FFFE        4874*         move.w  #$FFFE,d0       ;short delay
2B90  51C8  FFFE        4875* BP1     dbra    d0,BP1          ;*
2B94  323C  002E        4876*         move    #$002e,d1
                        4877*         ;******************************************************
2B98  1D41  0023        4878* bp3     move.b  d1,$23(a6);output a high pitch error tone
2B9C  303C  4FFE        4879*         move.w  #$4fFE,d0       ;short delay
2BA0  51C8  FFFE        4880* BP11    dbra    d0,BP11         ;*
2BA4  51C9  FFF2        4881*         dbra    d1,bp3
                        4882*         ;******************************************************
                        4883* 
2BA8  022E  000F  001D  4884*         andi.b  #StopCtrC,tcdcr(a6)
                        4885* ;       move.w  #$FFFE,d0       ;short delay
                        4886* ;BP2     dbra    d0,BP2          ;*
2BAE  4CDF  4303        4887*         movem.l  (sp)+,a0-a1/a6/d0-d1;restore registers
2BB2  4E75              4888*         rts                     ;return
                        4889* ;
2BB4  4BFA  0006+       4890* Help1   lea     msgHelp1,A5
2BB8  6000  F4BE        4891*         bra     DSoutst
2BBC  0D 0D 2020202020  4892* MsgHelp1 data.b DSCcr,DSCcr,'      DRAGONFLY commands',DSCcr
2BC3  20445241474F4E46
2BCB  4C5920636F6D6D61
2BD3  6E64730D 
2BD7  4D202D4D61696E20  4893*         data.b  'M -Main Menu',DSCcr
2BDF  4D656E750D 
2BE4  3F202D5468697320  4894*         data.b  '? -This Menu',DSCcr
2BEC  4D656E750D 
2BF1  416E2D5365742061  4895*         data.b  'An-Set altmap n: 0 or 1',DSCcr
2BF9  6C746D6170206E3A
2C01  2030206F7220310D 
2C09  4D532D4D656D6F72  4896*         data.b  'MS-Memory status',DSCcr
2C11  7920737461747573
2C19  0D 
2C1A  4E4D2D4E6577206D  4897*         data.b  'NM-New memory status',DSCcr
2C22  656D6F7279207374
2C2A  617475730D 
2C2F  446D2D446973706C  4898*         data.b  'Dm-Display  m: S-segments P-pages ',DSCcr
2C37  617920206D3A2053
2C3F  2D7365676D656E74
2C47  7320502D70616765
2C4F  73200D 
2C52  47202D476F746F20  4899*         data.b  'G -Goto command',DSCcr
2C5A  636F6D6D616E640D 
2C62  52532D5265737461  4900*         data.b  'RS-Restart',DSCcr
2C6A  72740D 
2C6D  72522D446973706C  4901*         data.b  'rR-Display Register r: C-context E-Error S-status',DSCcr
2C75  6179205265676973
2C7D  74657220723A2043
File: C1.MAIN.TEXT                                                Page 117


2C85  2D636F6E74657874
2C8D  20452D4572726F72
2C95  20532D7374617475
2C9D  730D 
2C9F  414D207361206969  4902*         data.b  'AM sa ii - change memory command',DSCcr
2CA7  202D206368616E67
2CAF  65206D656D6F7279
2CB7  20636F6D6D616E64
2CBF  0D 
2CC0  4478207361206363  4903*         data.b  'Dx sa cc ii - dump x: B-bytes W-words',DSCcr
2CC8  206969202D206475
2CD0  6D7020783A20422D
2CD8  627974657320572D
2CE0  776F7264730D 
2CE6  4378207361206363  4904*         data.b  'Cx sa cc dd ii - compare x: B-byte W-word',DSCcr
2CEE  206464206969202D
2CF6  20636F6D70617265
2CFE  20783A20422D6279
2D06  746520572D776F72
2D0E  640D 
2D10  4678207361206363  4905*         data.b  'Fx sa cc dd ii - fill x:B-byte W-word',DSCcr
2D18  206464206969202D
2D20  2066696C6C20783A
2D28  422D627974652057
2D30  2D776F72640D 
2D36  4379207361206363  4906*         data.b  'Cy sa cc dd ii - compare inc data y: I-word J-byte',DSCcr
2D3E  206464206969202D
2D46  20636F6D70617265
2D4E  20696E6320646174
2D56  6120793A20492D77
2D5E  6F7264204A2D6279
2D66  74650D 
2D69  4679207361206363  4907*         data.b  'Fy sa cc dd ii - fill inc data y: I-word J-byte',DSCcr
2D71  206464206969202D
2D79  2066696C6C20696E
2D81  6320646174612079
2D89  3A20492D776F7264
2D91  204A2D627974650D 
2D99  4D4D207361206461  4908*         data.b  'MM sa da cc - move memory',DSCcr
2DA1  206363202D206D6F
2DA9  7665206D656D6F72
2DB1  790D 
2DB3  73612D7374617274  4909*         data.b  'sa-start address cc-count dd-data ii-increment da-dest address'
2DBB  2061646472657373
2DC3  2063632D636F756E
2DCB  742064642D646174
2DD3  612069692D696E63
2DDB  72656D656E742064
2DE3  612D646573742061
2DEB  646472657373
2DF1  00                4910*         data.b  0
2DF2  0D 4D41494E204D45 4911* msgmainmenu data.b DSCcr,'MAIN MENU'
2DFA  4E55
2DFC  0D 302D447261676F 4912*            data.b DSCcr,'0-Dragonfly'
File: C1.MAIN.TEXT                                                Page 118


2E04  6E666C79
2E08  0D 312D52756E2061 4913*            data.b DSCcr,'1-Run all tests once'
2E10  6C6C207465737473
2E18  206F6E6365
2E1D  0D 322D4D61702052 4914*            data.b DSCcr,'2-Map Ram Menu'
2E25  616D204D656E75
2E2C  0D 332D44796E616D 4915*            data.b DSCcr,'3-Dynamic Ram Menu'
2E34  69632052616D204D
2E3C  656E75
2E3F  0D 342D50726F7465 4916*            data.b DSCcr,'4-Protection Test Menu'
2E47  6374696F6E205465
2E4F  7374204D656E75
2E56  0D 352D4F6D6E696E 4917*            data.b DSCcr,'5-Omninet Menu'
2E5E  6574204D656E75
2E65  0D 362D494F204D65 4918*            data.b DSCcr,'6-IO Menu'
2E6D  6E75
2E6F  0D 372D4C6F6F7020 4919*            data.b DSCcr,'7-Loop Menu'
2E77  4D656E75
2E7B  00                4920*            data.b 0
2E7C  0D 434F5256555320 4921* msginit data.b  DSCcr,'CORVUS CHEETAH Diagnostic 1',PROMvers+$30,'.'
2E84  4348454554414820
2E8C  446961676E6F7374
2E94  6963203130 2E
2E9A  32 67 0D          4922*         data.b  PROMLevl+$30,PROMilvl,DSCcr
2E9D  436F707972696768  4923* msgcpy   data.b 'Copyright '    ;Corvus Systems
2EA5  7420
2EA7  3139383520434F52  4924*          data.b '1985 CORVUS SYSTEMS' ;      copyright notice
2EAF  5655532053595354
2EB7  454D53
2EBA  00                4925*          data.b 0               ;
2EBB  0D 445241474F4E46 4926* msg1    data.b  DSCcr,'DRAGONFLY ',0
2EC3  4C592000 
2EC7  0D                4927* msgStatReg data.b DSCcr
2EC8  5374617475732052  4928* msgstatus  data.b 'Status Reg ',0
2ED0  65672000 
2ED4  0D                4929* msgErrReg  data.b DSCcr
2ED5  4572726F72205265  4930* msgerror   data.b 'Error Reg ',0
2EDD  672000 
2EE0  0D                4931* msgCtxReg  data.b DSCcr
2EE1  436F6E7465787420  4932* msgcontext data.b 'Context Reg ',0
2EE9  5265672000 
2EEE  0D 5761726E696E67 4933* msgWarn    data.b DSCcr,'Warning results may not be valid',0
2EF6  20726573756C7473
2EFE  206D6179206E6F74
2F06  2062652076616C69
2F0E  6400 
2F10  7072657373203C73  4934* msgKeypress data.b 'press <space> to continue, <esc> to exit',0
2F18  706163653E20746F
2F20  20636F6E74696E75
2F28  652C203C6573633E
2F30  20746F2065786974
2F38  00 
2F39  206973206E6F7420  4935* msgNotHex  data.b ' is not hex',DSCcr,0
2F41  6865780D 00 
File: C1.MAIN.TEXT                                                Page 119


2F46  0D 416C74203000   4936* msgalt0 data.b  DSCcr,'Alt 0',0
2F4D  0D 416C74203100   4937* msgalt1 data.b  DSCcr,'Alt 1',0
2F54  4875683F0D 00     4938* msgunkcmd  data.b 'Huh?',DSccr,0
2F5A  36346B00          4939* msg64k     data.b '64k',0
2F5E  3235366B00        4940* msg256k    data.b '256k',0
2F63  2052414D20747970  4941* msgRamtype  data.b ' RAM type ',0
2F6B  652000 
2F6E  206D656761627974  4942* msgcapacity data.b ' megabyte capacity ',0
2F76  6520636170616369
2F7E  74792000 
2F82  0D 36344B2052616D 4943* msgask64k data.b  DSCcr,'64K Ram size ?(Y/N):',0
2F8A  2073697A65203F28
2F92  592F4E293A00 
2F98  0D 52616D20657272 4944* msgSizErr data.b  DSCcr,'Ram error - Defaulting memory size to 1meg 256k rams.',0
2FA0  6F72202D20446566
2FA8  61756C74696E6720
2FB0  6D656D6F72792073
2FB8  697A6520746F2031
2FC0  6D6567203235366B
2FC8  2072616D732E00 
2FCF  0D 436F756E742069 4945* msgcnt  data.b  DSCcr,'Count is ',0
2FD7  732000 
2FDA  0D 546F74616C2000 4946* msgtotal data.b  DSCcr,'Total ',0
2FE2  20506173732000    4947* msgpass data.b  ' Pass ',0
2FE9  204661696C2000    4948* msglfail data.b  ' Fail ',0
      00812FF0+         4949* CodeLen equ     %
2FF0  00810030+         4950* Xit     end     dfinit

 ACR      00000009   BEGIN      812A02+  CCRDATA3 00000080   CMD      00000001   CMPWRD     8106D6+
 ACRD     0000000B   BENORM     8128F2+  CHEXBAD    810878+  CMDACPT  000000FE   CMPWRD2    8106DC+
 ACTNET     811A4A+  BEVEC    00000008   CHEXIT     810882+  CMDBDATA 00000000   CMPWRD3    8106EC+
 ACTNET1    811A58+  BFCDATA0 00000005   CHEXOK     810880+  CMDELCH    81088A+  CMPWRDE    8106F6+
 ACTNET2    811A74+  BFCDATA3 00000005   CHGMEM1    810828+  CMDOFST  00000000   CMSAMCH    81089C+
 ACTNET3    811A84+  BO2        812914+  CHGMEM2    810854+  CMDREGA  00000001   CMSC1      8108A4+
 ADDRERR    8128DC+  BO3        812916+  CHGMEME    8108F8+  CMDREGAD 00000000   CODELEN    812FF0+
 AER      00000003   BOOTOFF  0000008B   CHK64K     810946+  CMDREGB  00000021   COMMAND    81026C+
 AERD     00000000   BOOTON   00000000   CHKALPH    81046A+  CMDREGBD 00000000   COMNEXT    81027E+
 AETEND     8116C4+  BOOTSW1  00000005   CHKCTL     810482+  CMEC1      8108F0+  CONTLEN  00000000 
 AEVEC    0000000C   BOOTSW2  00000004   CHKHEX     81085A+  CMENDCH    8108E6+  CPRDATA0 00000003 
 ALFBIT   00000001   BOOTSW3  00000003   CHNGMEM    8107D2+  CMINLP     810800+  CPRDATA1 00000002 
 ALLERRTS   811694+  BOOTSW4  00000002   CLEAR      810196+  CMPBYT     8106B4+  CPRDATA3 00000000 
 ALT0DAT  00000010   BP1        812B90+  CLEARIT    811BD8+  CMPC1      8108B4+  CRA      00000005 
 ALT1DAT  00000050   BP11       812BA0+  CLNOFST  0000000A   CMPIB2     8106FE+  CRAD     00000019 
 ALTSW0     8109FE+  BP3        812B98+  CLOCKCAL 00000004   CMPIB3     81070E+  CRB      00000015 
 ALTSW1     8109EE+  BRG      00000017   CLRER      810A5C+  CMPIBEX    81071A+  CRBD     00000015 
 ALTVID   00000020   BRGBDATA 00000007   CLRVID     8101A8+  CMPIBYT    8106F8+  CSATTR1  00000010 
 AMABIT   00000007   BRGCTLA  00000017   CMADDR     8107AE+  CMPIW2     810722+  CSATTR2  00000011 
 ASK64K     8109D6+  BRGCTLAD 0000000D   CMBLA1     8108C8+  CMPIW3     810732+  CSBPCH   00000006 
 BACKSP     8103E6+  BRGCTLB  00000037   CMBLA2     8108CC+  CMPIWEX    81073E+  CSDATA   00000012 
 BADDEST  00000086   BRGCTLBD 0000000D   CMBLACH    8108BC+  CMPIWRD    81071C+  CSFRSTCH 00000008 
 BADENTRY   81280C+  BUFFLEN  00000064   CMBSCH     81088E+  CMPMEM2    8106BA+  CSLASTCH 0000000A 
 BADERRRE   8116E6+  BUSERR     8128E6+  CMBYTE     8107C0+  CMPMEM3    8106CA+  CSLPCH   00000004 
 BEEP       812B76+  CALBASE  00830500   CMCR1      8108E2+  CMPMEME    8106D4+  CSMASK   0000000C 
 BEFLAG   00800D94   CCRDATA0 00000080   CMCRCH     8108D8+  CMPRVCH    8108AC+  CSRA     00000003 
File: C1.MAIN.TEXT                                                Page 120


 CSRAD    00000066   DMABTC   0000001A   DSCBS    00000008   DSETBL     812482+  DSWRAPX    8122DC+
 CSRB     00000013   DMACCR   00000007   DSCCR    0000000D   DSEXIT     812118+  DSWRBIT  00000002 
 CSRBD    000000BB   DMACER   00000001   DSCDEL   0000007F   DSGORTN    8121BE+  DSXCRT     8120A2+
 CSRP     00830701   DMACINT  00000380   DSCDIFF  00000020   DSHOMEH  00880000   DSXCRT1    8120BA+
 CTL      0000000F   DMACPR   0000001D   DSCELLW  00000006   DSHOMEV  00880064   DSXIT      8120E0+
 CTLMISM  00000083   DMACSR   00000000   DSCELLY  0000000A   DSHOMHD  0088FB78   DUARTBAS 00830300 
 CTLR     0000000F   DMADAR   00000014   DSCEOT   00000004   DSINCX     812282+  DUARTI   00000140 
 CTU      0000000D   DMADCR   00000004   DSCESC   0000001B   DSINCY     8122AC+  DUSART0I 00000180 
 CTUR     0000000D   DMADFC   00000021   DSCLAL     812346+  DSINIT     81211E+  DUSART1I 00000184 
 CTXREG   00840003   DMAEIV   00000017   DSCLCA   00000061   DSINIT1    81214C+  DUSART2I 00000188 
 CURMEM   00800D66   DMAGCR   0000003F   DSCLCZ   0000007A   DSINIT2    812154+  DUSART3I 0000018C 
 CXOUT      811074+  DMAMAR   0000000C   DSCLEL     812384+  DSMAXXH  00000317   DUSART4I 00000190 
 CXOUT1     81108C+  DMAMFC   00000019   DSCLEL1    81239A+  DSMAXXV  00000269   DUSART5I 00000194 
 CXOUT2     81109E+  DMAMTC   0000000A   DSCLEL2    8123A0+  DSMAXYH  0000026B   DUSART6I 00000198 
 CXOUT3     8110B0+  DMANIV   00000015   DSCLES     81234A+  DSMAXYV  0000031F   DUSART7I 0000019C 
 CXPERMP  00000010   DMAOCR   00000005   DSCLES1    812358+  DSNXTST    81210E+  DUSARTB  00830420 
 DATREGA  00000013   DMASCR   00000006   DSCLES2    81236C+  DSOUT1     81207C+  DUSARTBA 00830400 
 DATREGB  00000033   DMIVR    00000019   DSCLES3    812370+  DSOUT9     812084+  DUSARTRE 00830433 
 DBGBIT   00000003   DMIVRBDA 00000060   DSCLES9    812382+  DSOUTCH    8120A2+  DUSARTTX 00830433 
 DBGENTRY 00820008   DMPLNW     81063A+  DSCLF    0000000A   DSOUTCR    812096+  ECHOBIT  00000002 
 DBGINIT  00820004   DMPLNW1    810646+  DSCLRH     8123C4+  DSOUTSP    81208A+  ECHOCMD    811AB6+
 DC0      00830300   DMPMAP     810CFA+  DSCLRH1    8123DA+  DSOUTST    812078+  ECHOED   000000C0 
 DC0CMND  00830315   DMPMAP2    810D02+  DSCLRH2    8123EC+  DSPBASE  00880000   ECHOOP   00000002 
 DC0D     00000017   DMPMAP3    810D0E+  DSCLRH3    8123F4+  DSPEND   0088FF00   ECHOOUT    811ACE+
 DC0DATA  00830317   DMPMEM1    8105E8+  DSCLRH4    8123F8+  DSPLEN   0000FF00   ECHOREQ    811B24+
 DC0STAT  00830313   DMPMEM2    8105EC+  DSCLRH5    8123FE+  DSPPGNO    8118F0+  EIVDATA0 00000071 
 DCRDATA0 00000080   DMPMEM3    8105FE+  DSCLRH6    812404+  DSPSTACK   812904+  EIVDATA3 00000077 
 DCRDATA3 00000008   DMPPAG     810D2E+  DSCLRV     8123A4+  DSPSTAT    81095E+  ENCLK    00000004 
 DCROCR0D 00008082   DMPPAG1    810D44+  DSCLRV1    8123BA+  DSPUTCH    8120E6+  ENDEXC0    8128FA+
 DCROCR1D 00008002   DMPPAG2    810D52+  DSCPORT  00830217   DSRESET    812114+  ENDOFLOO   812065+
 DCROCRDA 00000811   DMPPAG3    810D54+  DSCRSAD    812332+  DSRTRN     812298+  ENDOFTES   811516+
 DDR      00000005   DMPPAGX    810D70+  DSCRSD     8122AA+  DSRTRN1    81229A+  ENDPARA    8104A6+
 DDRD     00000000   DMPSEG     810CC0+  DSCRSH     8122D0+  DSSHOW1    8121D6+  ENDRXOP  00000010 
 DELAY      811412+  DMPSEG1    810CD6+  DSCRSH1    8122D2+  DSSHOW2    8121DA+  ENDVEC     8128BC+
 DESSOCK  00000080   DMPSEGX    810CF6+  DSCRSL     8122C2+  DSSHOW3    812210+  ERCMLEN  00000008 
 DFC2       81033C+  DMPWORD    810618+  DSCRSR     81227E+  DSSHOW6    812222+  ERDALEN  000000F8 
 DFCDATA0 00000005   DMPWRD1    810622+  DSCRSU     812294+  DSSHOW7    81222C+  ERDSOCK  00000080 
 DFCDATA3 00000005   DMPWRD2    81062C+  DSCSETH    8124BC+  DSSHOW9    81227C+  ERID     000001C0 
 DFCLOOP    810322+  DOBOOT     810232+  DSCSETV    8124F2+  DSSHW71    81223C+  ERMSGTY  00000000 
 DFINIT     810030+  DOFST    00000004   DSCTBL     812476+  DSSHW72    812246+  ERRADD   00800DB2 
 DFLYCMD    81036C+  DRAGON     8102F0+  DSCTL      812184+  DSSHW73    812250+  ERRCTR   00800DA6 
 DHOSTOF  0000000B   DRALL1     811248+  DSCURS     8122FE+  DSSHW74    81225A+  ERRDATA  00800DAE 
 DIAG     00000002   DRAMBIT  00000003   DSCURS0    812300+  DSSHW75    812264+  ERRMENU    811654+
 DIRTYPG    81183A+  DRAMDRAM   8115D1+  DSCURS1    81231E+  DSSHW76    81226E+  ERRPRMT    81165C+
 DISPLAY    8105DE+  DRBASE   00000000   DSCURS2    812322+  DSSHWCH    8121C6+  ERRREG   00840005 
 DLNOFST  00000008   DREXIT     811266+  DSCURS3    812324+  DSST0      81216E+  ERRTBL     81168C+
 DLY        81141C+  DRMENU     8111DE+  DSCVTU1    812076+  DSSTBL     812494+  ERRTST2    811674+
 DLYVAL   00800D96   DRTPRMT    8111F4+  DSCVTUC    812066+  DSTAB      812410+  ERSHOST  0000003F 
 DMA0BASE 00830800   DRTTBL     811212+  DSDECX     8122C4+  DSTAB1     81242A+  ETBERTN    8116C6+
 DMA1BASE 00830840   DRVDFLT  00800D95   DSDECY     8122E2+  DSUDA    00000000   ETEXIT     8117B2+
 DMA2BASE 00830880   DSADDR     812436+  DSDEFOF  00000068   DSUST    00000013   ETSTACK  00800D9E 
 DMA3BASE 008308C0   DSADDRH    812442+  DSESC      81219C+  DSWNDH     812498+  EXCBIT   00000007 
 DMABASE  00830800   DSADDRV    81245C+  DSESC1     8121A4+  DSWNDV     8124CE+  EXECEND    8105D8+
 DMABFC   00000039   DSCBLNK  00000020   DSESC2     8121B6+  DSWRAP     8122F0+  EXECLP     811516+
File: C1.MAIN.TEXT                                                Page 121


 EXECTST    8105C0+  GP3      00000130   INSEGD   00800D6A   KBCON    00000029   MAPPAG4    810C92+
 EXPDATA  00800DAA   GP4      00000124   INSTR    00810028   KBCOND   000000C0   MAPPAGES   810C42+
 FAST       8114D0+  GP5      00000110   INSTVEC  00000010   KBCPORT  00830217   MAPPRMT    810D7C+
 FASTERR    811506+  GP6      00000104   INT      00000005   KBDATA   0000002F   MAPSEG1    810B74+
 FASTLP0    8114E0+  GP7      00000100   INTBDATA 00000000   KBDRXERR 00000110   MAPSEG2    810B7E+
 FASTLP1    8114E2+  GPIR     00000001   INTCTLA  00000005   KBDRXFUL 0000010C   MAPSEG3    810B8A+
 FASTLP2    8114F4+  GRLED    00000006   INTCTLAD 00000077   KBDTXERR 00000118   MAPSEG4    810BAA+
 FASTLP3    8114FA+  GTSCDIW    81076C+  INTCTLB  00000025   KBDTXFUL 00000114   MAPSEG5    810BB4+
 FIB2       8106A4+  HALFBRIG 00000010   INTCTLBD 0000006F   KBGCHR0    8126A0+  MAPSEG6    810BC0+
 FILLBYT    810660+  HELP1      812BB4+  INTDC0     812836+  KBGCHRA    812690+  MAPSEGS    810B64+
 FILLINC    810684+  HEXTBL     8104DA+  INTDC1     812850+  KBGCHRE    8126BA+  MAPTBL     810D9A+
 FILLWRD    810672+  HEXTOA2    8108FA+  INTKYBD    81281A+  KBGETCH    81268C+  MAPTRAN    810B36+
 FIRSTCH    810458+  HIGHBEEP 00000010   INTLVL7    81287A+  KBGETUC    812686+  MARCH      811330+
 FIRSTCOM 0000000B   HIGHMAP  00400000   INTOMNI    812848+  KBRDBASE 00830200   MARTST     8112F6+
 FIRSTLIN 00880068   HOMEBYTE 00880000   INTSLOT    812862+  KBRDBIT  00000000   MCD0VBR  4E7B0801 
 FIWORD     810688+  IERA     00000007   INTTIMR    81282C+  KBRDTABL   81273E+  MCDATA     81052C+
 FIWORDL    81068C+  IERAD    00000018   INVALPG    811854+  KBRGCHR0   81270E+  MCVBRD0  4E7A0801 
 FLLBYT2    810664+  IERB     00000009   INVSOCK  00000084   KBRGCHRA   8126FE+  MDPERMP  00000002 
 FLLINCB    8106A0+  IERBD    0000008F   IOADDR   00800D9A   KBRGCHRE   812738+  MEMSIZE    810910+
 FMW2       810676+  ILLINST    8128AA+  IOBFEND  00800D63   KBRGETCH   8126FA+  MEMSTAT    810952+
 FOURMEG  00400000   IMR      0000000B   IOBOOTSW 00830701   KBRGETUC   8126FA+  MEMSZ    00800D65 
 FPUBASE  00830900   IMRA     00000013   IOBUFF   00800D00   KBRRDBIT 00000007   MEMSZ1     81091E+
 FROMBUFF   812A30+  IMRAD    000000D8   IOPBASE  00830000   KBSTAT   0000002B   MEMSZ1A    810934+
 FSTLP      8114C2+  IMRB     00000015   IP       0000001B   KBUDA    00000017   MEMSZ2     810938+
 FSTTST     8114B6+  IMRBD    000000CF   IPCR     00000009   KBUST    00000013   MEMSZ2A    81093A+
 GAVEUP   00000080   IMRD     000000F2   IPRA     0000000B   KEYPRESS   81056E+  MENUKEY    81028A+
 GCRDATA0 00000000   INC        8113C0+  IPRB     0000000D   LABELXXX   810B36+  MFCDATA0 00000005 
 GCRDATA3 00000000   INCCMP1    811EEE+  IRD        811E82+  LASTLINE 0088FB78   MFCDATA3 00000005 
 GETCHAR  00810020   INCLP1     811EA8+  IRD0       811E86+  LBDATCK    811C0C+  MFP        810044+
 GETCNTD    810786+  INCLP11    811EB2+  IRD1       811E8A+  LBDCLP     811C1A+  MFPBASE  00830200 
 GETCNTE    810790+  INCLP1A    811EC2+  ISR      0000000B   LBEXIT     811C28+  MISCMP     810514+
 GETCNTR    811508+  INCLP2     811F0E+  ISRA     0000000F   LBLOOP     811BAC+  MISCMPB    810564+
 GETCNTU    810782+  INCLP2A    811F18+  ISRB     00000011   LOADX      811722+  MISCMPL    810550+
 GETCNTX    811514+  INCLP2B    811F28+  ISTACK   00800FFC   LOOP1      811546+  MISCMPW    81055A+
 GETDATA    810792+  INCLP2C    811F40+  IT00       8113C6+  LOOP2      81154A+  MMENDLBL   8111DD+
 GETDEST    811A9A+  INCMIS1    811F00+  IT01       8113CA+  LOOPADD    811E92+  MOD      00000003 
 GETHEXP  00810024   INCMIS2    811F04+  IT02       8113EC+  LOOPBACK   811B2C+  MODBDATA 00000020 
 GETINCE    8107A4+  INCMIS3    811F06+  ITEND      811406+  LOOPCLR    81151E+  MODCTLA  00000003 
 GETINCR    81079A+  INCTST     811386+  ITERR      81140C+  LOOPCTR  00800DA2   MODCTLAD 00000044 
 GETIWXT    810778+  INDATLP    811B9A+  ITERROR    8113AA+  LOOPDAT    811E98+  MODCTLB  00000023 
 GETPAR1    810448+  INITCMD    811AD2+  ITEXIT     8113A8+  LOOPPAR    811E9C+  MODCTLBD 00000020 
 GETPARA    810440+  INITDMA0   812A3A+  IVLVL1   00000064   LOOPS      811D9E+  MOVEMEM    810740+
 GETRDM     811470+  INITDMA1   812AD8+  IVLVL2   00000068   LOOPXIT    81159C+  MOVMEM1    81074E+
 GETRDMX    81147C+  INITDMA3   8129AA+  IVLVL3   0000006C   LOWBEEP  000000D0   MOVMEM2    810758+
 GETSCDI    810764+  INITOP   00000020   IVLVL4   00000070   MAINMENU   8102B0+  MOVMEME    810762+
 GETSTRT    81077A+  INPAGD   00800D6C   IVLVL5   00000074   MAINPRMT   8102BE+  MR1        811338+
 GO0        812AAC+  INPDTP   00000000   IVLVL6   00000078   MAINTBL    8102E2+  MR1A     00000001 
 GO1        812B4A+  INPUT      8103FA+  IVLVL7   0000007C   MAINWIN    8101AE+  MR1AD    00000012 
 GO3        8129E0+  INPUT2     810408+  IVR      00000019   MAPBASE  00400000   MR1B     00000011 
 GOCMD      810AA6+  INPUT3     810416+  IVRD     00000050   MAPERR     810C34+  MR1BD    00000013 
 GODOIT     810AB2+  INPUT31    810420+  IWORD      81076E+  MAPMENU    810D74+  MR2        81134A+
 GP0      0000013C   INPUT4     810430+  IWR        811E72+  MAPPAG1    810C54+  MR2A     00000001 
 GP1      00000138   INPUTE     810436+  IWR0       811E76+  MAPPAG2    810C64+  MR2AD    00000007 
 GP2      00000134   INSDTP   00000F00   IWR1       811E7A+  MAPPAG3    810C82+  MR2B     00000011 
File: C1.MAIN.TEXT                                                Page 122


 MR2BD    00000007   MSGNMI     8129A3+  NOTRED   00000080   PETMSG2    8119A1+  RAMKBLEN 00000100 
 MR3        811366+  MSGNONE    811D72+  NUMPAGS  00000800   PETMSG3    8119B8+  RAMLEN   00001000 
 MREND      811380+  MSGNOTHE   812F39+  NUMSEGS  00000080   PETNEXT    81187C+  RAMWKSA  00800C00 
 MSG1       812EBB+  MSGOLAP    810AFF+  NXTADD1    8107E2+  PETOP    00000001   RAMWKSTA 00800700 
 MSG256K    812F5E+  MSGOMNME   811CCA+  NXTADDR    8107E0+  PETRET     811864+  RBA      00000007 
 MSG64K     812F5A+  MSGOPT     810ADF+  NXTBYT1    8107F0+  PGMAR1     810FDA+  RBB      00000017 
 MSGA2      8119D0+  MSGPAGE    8110EC+  NXTBYTE    8107EE+  PGPERCX  00000400   RCVCCB   00002000 
 MSGADDRE   812942+  MSGPASS    812FE2+  OCRDATA0 00000082   PGPERSG  00000010   RCVCLEN  00000000 
 MSGALT0    812F46+  MSGPMAPE   81114B+  OCRDATA3 00000011   PGWALK     810F8E+  RCVCTLA  0000000B 
 MSGALT1    812F4D+  MSGPRIVV   812966+  OFF      00000000   PGWALK0    810F84+  RCVCTLAD 000000C1 
 MSGASK64   812F82+  MSGPROTE   81192B+  OMCMD      811C2A+  PGWALK1    810F90+  RCVCTLB  0000002B 
 MSGBUSER   812936+  MSGRAMTY   812F63+  OMEND      811B22+  PGWALK2    810F9E+  RCVCTLBD 000000C1 
 MSGCAPAC   812F6E+  MSGRDM     8115BF+  OMERR      811B0E+  PMAPBIT  00000002   RCVDBLK  00002100 
 MSGCHR0    8126DA+  MSGREENT   810B2B+  OMINT    00000005   PMAPERR    810C18+  RCVDLEN  00000100 
 MSGCHRA    8126CA+  MSGSEGME   8110E2+  OMNIBF   00880000   PMCLR1     810FEE+  RCVRRA   00002010 
 MSGCHRE    8126F4+  MSGSF      811D8C+  OMNIGO     811C46+  PMCLR3     810FF8+  RCVSOCK  00000080 
 MSGCLEAR   810AF0+  MSGSIZER   812F98+  OMNIGO2    811C58+  PMEXIT     811072+  RDB        811E12+
 MSGCMPRI   812057+  MSGSMAPE   81112D+  OMNIWT     811C5C+  PMSUPHI  00000080   RDB1       811E18+
 MSGCNT     812FCF+  MSGSPURI   81297B+  OMNIWT1    811C66+  PMSUPLO  000000C0   RDMINIT    811452+
 MSGCONTE   812EE1+  MSGSTACK   81298F+  OMNIWT2    811C76+  PMTEST     810FDA+  RDMLOOP    81146A+
 MSGCPY     812E9D+  MSGSTATR   812EC7+  OMNPRMT    811A20+  PMUSRHI  00000090   RDMTEST    81142A+
 MSGCTXRE   812EE0+  MSGSTATU   812EC8+  OMNTBL     811A3E+  PMUSRLO  000000D0   RDMTST     811480+
 MSGDATEX   810AD1+  MSGSUCC    811D5E+  OMREADY  00000007   PPERR      8118E8+  RDMTST1    811484+
 MSGDATRD   810AC3+  MSGSUPER   8110F9+  OMTEST     811A18+  PPERR0     81189A+  RDMTST2    811492+
 MSGDONE    811163+  MSGTE      811D1F+  OMXXXXX    811D9D+  PPERR1     8118B2+  RDMTSTE    8114B0+
 MSGDRMEN   8115D1+  MSGTOTAL   812FDA+  ON       00000001   PPERR2     8118C4+  RDMTSTX    8114AE+
 MSGERRME   8119D5+  MSGUNKCM   812F54+  ONEMEG   00100000   PPERR3     8118D6+  RDW        811E42+
 MSGERROR   812ED5+  MSGUSER    8110F3+  OPCR     0000001B   PRIVILEG   8128B0+  RDW1       811E48+
 MSGERRPA   81196D+  MSGWALK    81159E+  OPCRD    000000FA   PRIVVEC  00000020   RDYADR   00830200 
 MSGERRRE   812ED4+  MSGWARN    812EEE+  OPTCONT    810594+  PROMILVL 00000067   REDLED   00000007 
 MSGERRSE   81195D+  MSGWHATH   811D51+  OUTBUFF    8104B2+  PROMLEVL 00000002   REGBIT   00000000 
 MSGERZER   81190A+  MSRDBIT  00000000   OUTCHAR  00810018   PROMPT0  0000003E   RESTART    81034E+
 MSGETCH    8126C6+  MSUDA    00000007   OUTDOT     8105B2+  PROMPT1  0000002A   ROM0BASE 00810000 
 MSGETUC    8126C0+  MSUST    00000003   OUTHEX     8104C0+  PROMPT2  00000023   ROM0END  00812000 
 MSGFAIL    811D6B+  MTAEXIT    810DC4+  OUTLINE    8104AE+  PROMPT3  0000002D   ROM0LEN  00002000 
 MSGHELP1   812BBC+  MTERROR    81131A+  OUTSTR   0081001C   PROMPT4  00000024   ROM1BASE 00820000 
 MSGHIMAP   81110E+  MTEXIT     811318+  OVERLAP    8107A6+  PROMPT5  00000021   ROM1END  00824000 
 MSGHNUM    811D79+  MTSTALL    810DA8+  OWEXIT     811C7A+  PROMPT6  0000002B   ROM1LEN  00004000 
 MSGILLIN   812951+  MWLTDR     811B44+  PAGERRTS   8117F0+  PROMPT7  00000026   ROPR     0000001F 
 MSGINC     8115B1+  NEWMEM     8109B0+  PAGEXEC    810F64+  PROMVERS 00000000   RRAOFST  00000010 
 MSGINIT    812E7C+  NEXTCH     810454+  PAGMAR     810FC4+  PROTBIT  00000004   RSRD     00000001 
 MSGKEYPR   812F10+  NIRQ0    00000001   PAGMAR1    81101A+  PRVADDR    8107DC+  RTERROR    81143C+
 MSGLADD    812042+  NIRQ1    00000003   PAGMAR3    811020+  PUT1HX     810500+  RTEXIT     81143A+
 MSGLDAT    81204E+  NIVDATA0 00000070   PAGMAR4    811048+  PUT2HX     8104F4+  RUBOUT     8103DE+
 MSGLFAIL   812FE9+  NIVDATA3 00000076   PAGMAR6    811052+  PUT4HX     8104EE+  RWB        811E32+
 MSGLOOP    811F50+  NM2        8109B8+  PAGOFST  00001000   PUT6HX     8104E8+  RWB1       811E3C+
 MSGLOOPB   811D35+  NMAGAIN    8109AA+  PAGTEST    810F3C+  PUT8HX     8104E0+  RWW        811E62+
 MSGLOWMA   811105+  NMI0     00000000   PAGTST     810F44+  PUTHX      810510+  RWW1       811E6C+
 MSGMAINM   812DF2+  NMI1     00000002   PAGTST1    810F52+  PWEXIT     810FC2+  RXC      0000000B 
 MSGMAPME   811169+  NORMOP   00000000   PAGTXIT    810F70+  PWTEST     810F72+  RXCBDATA 000000C1 
 MSGMAPPI   811118+  NOTBOOT  00000001   PET1       811806+  RAMBASE  00800000   SAV256K    810980+
 MSGMAPRA   8110D0+  NOTGREEN 00000040   PETEXIT    8118AA+  RAMDEBUG 00800400   SAVE64K    810996+
 MSGMARCH   8115A7+  NOTHEX     810494+  PETMSG0    81197B+  RAMEND   00801000   SBERR      811C9C+
 MSGMISCM   810AB4+  NOTRANS  00000090   PETMSG1    81198D+  RAMKBBUF 00800300   SBEXIT     811CA0+
File: C1.MAIN.TEXT                                                Page 123


 SBSTROB    811CA8+  SETOP    00000002   STRADR   00830601   TOINTVL  0002FFFF   WAITLP   00000500 
 SBW1       811CB4+  SETREG     81047A+  STROBIT    811C7C+  TOOLONG  00000081   WALKBIT    8112D4+
 SBWAIT     811CAE+  SETRET     811792+  SUMBIT   00000004   TRANBIT  00000004   WALKTST    81127A+
 SBWCHK     811CC0+  SETRXOP  000000F0   SWCTXLP    810E16+  TRAP0      8128A4+  WARN       81058C+
 SBWEXIT    811CC8+  SETSEL     81173E+  SWEXIT     810E74+  TRAP0VEC 00000080   WB1        8112D6+
 SCNOFS   00800D92   SETSR      810A76+  SWTEST     810E00+  TRAP1VEC 00000084   WB2        8112D8+
 SCR      00000027   SETSRXT    810AA0+  SYN      00000009   TRAP2VEC 00000088   WB3        8112E6+
 SCRD     00000000   SETTBL     81174E+  SYNC1A   00000007   TRAP3VEC 0000008C   WBEND      8112F4+
 SCRDATA0 00000004   SEVEC    0081002C   SYNC1AD  00000000   TRAP4VEC 00000090   WDPERPG  00000800 
 SCRDATA3 00000005   SEVECT     81002C+  SYNC1B   00000027   TRAP5VEC 00000094   WHOCMD     811AF0+
 SCREXIT    810A40+  SEXVEC     81279E+  SYNC2A   00000009   TRAP6VEC 00000098   WHOOP    00000001 
 SCROLL     812A08+  SGPERCX  00000040   SYNC2AD  00000000   TRAP7VEC 0000009C   WINLOOP0   8101C2+
 SECONCOM 0000000A   SGWALK     810E26+  SYNC2B   00000029   TRAP8VEC 000000A0   WINLOOP1   8101DE+
 SECONDLI 008800D0   SGWALK0    810E14+  SYNC2BD  0000007E   TRCEBIT  00000006   WINLOOP2   8101F6+
 SEED     00123456   SGWALK1    810E2A+  SYNCDATA 0000007E   TSEGBIT  00000005   WINLOOP3   81020C+
 SEGBIT   00000005   SGWALK2    810E44+  SYSBASE  00800000   TSR      0000002D   WNDRCD   00800D6E 
 SEGERRTS   8116F2+  SHOWA2B    8117CA+  SYSFLAG  00800D64   TSR0D    00000002   WRATTR1  00000020 
 SEGEXEC    810DF0+  SHOWCR     810A24+  TACR     00000019   TSR1D    00000004   WRATTR2  00000021 
 SEGMAR1    810ECA+  SIZERR     81092C+  TACRD    00000008   TSTFAIL    8105D4+  WRB        811E20+
 SEGMAR2    810ECC+  SLMBIT   00000006   TADR     0000001F   TSTLOOP    811524+  WRB1       811E2A+
 SEGMAR3    810ED8+  SMAPBIT  00000001   TADRD    000000A0   TSTSTAT  00800DB6   WRBASEX  0000000E 
 SEGMAR4    810F00+  SMAPERR    810BF0+  TBA      00000007   TWOMEG   00200000   WRBASEY  00000010 
 SEGMAR5    810F02+  SMCLR1     810E8C+  TBB      00000017   TXC      0000000D   WRBITOFS 0000001A 
 SEGMAR6    810F12+  SMCLR2     810E8E+  TBCR     0000001B   TXCBDATA 000000C7   WRCHARPT 00000000 
 SEGOFST  00010000   SMCLR3     810E9E+  TBCRD    00000001   UCR      00000029   WRCURADR 00000008 
 SEGRTST    811756+  SMEXIT     810F3A+  TBDR     00000021   UCRD     00000089   WRCURSX  00000016 
 SEGTEST    810DC6+  SMSUPHI  000000A0   TBDRD    00000030   UNKCMD     810346+  WRCURSY  00000018 
 SEGTST     810DCE+  SMSUPLO  000000E0   TCB      00000015   UNKSOCK  00000082   WRGRORGX 0000001C 
 SEGTST1    810DDE+  SMTEST     810E76+  TCDCR    0000001D   USEPAGE    811826+  WRGRORGY 0000001E 
 SEGTXIT    810DFE+  SMUSRHI  000000B0   TCDCRD   00000010   USESOCK  00000085   WRHOMEOF 0000000C 
 SEGWTST    811752+  SMUSRLO  000000F0   TCDR     00000023   USRBASE  00880030   WRHOMEPT 00000004 
 SEGXTST    81175A+  SOFST    00000004   TCDRD    00000010   USRMODE    810356+  WRLENGTH 00000024 
 SELCTX     811224+  SOPR     0000001D   TCRBDATA 00000001   USRTST     811268+  WRLNGTHX 00000012 
 SENDBLK  00001100   SPCC     0000001F   TCREGA   00000015   USTACK   00800C00   WRLNGTHY 00000014 
 SENDCCB  00001000   SPIVEC   00000060   TCREGAD  00000060   VECENDLA   8129A9+  WRRCDLEN 00000023 
 SENDLEN  00000100   SPRMODE    810366+  TCREGB   00000035   VECTRGA  00000019   WRSTATE  00000022 
 SENDOP   00000040   SPURIOUS   8128B6+  TCREGBD  00000060   VECTRGAD 00000060   WRW        811E50+
 SET1       811708+  SRA      00000003   TDDR     00000025   VECTRGB  00000039   WRW1       811E5A+
 SETALT0    8109FE+  SRAD     0000000C   TDDRD    00000000   VECTRGBD 00000060   WT1        81129C+
 SETALT1    8109EE+  SRB      00000013   TERMBP     81087A+  VERT     00000000   WTERROR    8112C0+
 SETCR      810A0E+  STACK    00800E00   TESTALL    8102A0+  VERTICAL 00000006   WTLOOP     8112A2+
 SETER      810A42+  STARTCTR 00000070   TESTBAD  00000040   VIDBASE  00880000   WTLOOP1    8112B0+
 SETERR     811760+  STAT0A   0000000F   TESTOK   00000080   VIDEND   00890000   XCRTBIT  00000000 
 SETERR1    811774+  STAT0B   0000002F   TESTON   0000003F   VIDEOON  00000008   XIT        812FF0+
 SETERRX    81178E+  STAT1A   00000011   THREEMEG 00300000   VIDLEN   00010000   XMTCTLA  0000000D 
 SETERXT    810A74+  STAT1B   00000031   TIMEOUT  00000091   VR       00000017   XMTCTLAD 000000C7 
 SETMOFF    81195A+  STAT256    81095A+  TIMERAI  00000108   VRD      00000044   XMTCTLB  0000002D 
 SETMSG0    811947+  STAT64K    81094C+  TIMERBI  0000011C   WAIT       8129FC+  XMTCTLBD 000000C7 
 SETMSG1    81194D+  STATREG  00840007   TIMERCI  00000128   WAIT0      812AC8+  XTEND      8117C8+
 SETMSG2    811952+  STCC     0000001D   TIMERDI  0000012C   WAIT1      812B66+  XTEST      8117BE+
 SETNEXT    811732+  STOPCTRC 0000000F   TOBUFFER   812A18+  WAITING  000000FF   ZERO       810000+

0 errors.  4951 lines.  File C1.MAIN.TEXT
