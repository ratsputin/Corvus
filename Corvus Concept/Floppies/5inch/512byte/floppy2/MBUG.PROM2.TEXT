;       2nd half of MacsBug used as include in first half *KB 8/18/82*
;       file : mbug.prom2.text                            *KB 8/18/82*
;                                                         *KB 8/18/82*

;
;       ***TD***        SET TRACE DISPLAY FORMAT
;
RCMD    CLR.L D7        ;FLAG FO ANY DONE?
        ADDA.L #2,A5    ;GET PAST 'TD'
R1      CMPA.L A6,A5    ;SEE IF AT END OF BUFFER
        BLE.S R11
        TST.L D7        ;SEE IF ANY DONE
        BNE.S R10
        BSR TDISPLY     ;JUST LETTER R ENTERED MEANS DISPLAY
R10     BRA MACSBUG
R11     MOVE.B (A5)+,D0 ;GET 1ST CHAR
        CMPI.B #' ',D0          ;IGNORE SPACES
        BEQ.S R1
        CMPI.B #',',D0  ;IGNORE COMMAS
        BEQ.S R1
        ASL.W #8,D0     ;SHIFT LEFT ONE BYTE
        MOVE.B (A5)+,D0 ;PICK UP 2ND LETTER
        CMPI.W #'AL',D0 ;SEE IF COMMAND 'AL'(L)
        BNE.S R2
        MOVE.L #'----',ADALL.W  ;SPECIAL FORMATS
        MOVE.W #$302,FORMAT.W   ;PC & SR        
        MOVE.W #$4040,FORMAT+18.W       ;SS & US
        BRA MACSBUG
R2      CMPI.W #'CL',D0 ;SEE IF COMMAND 'CL'(EAR)
        BNE.S R3
        CLR.L ADALL.W   ;SPECIAL FORMATS
        CLR.L D0
        MOVEQ.L #36,D2  ;SET ALL OFF
        BRA REGALL
R3      MOVE.L #ROM+REGNAMES-ZERO,A0    ;REGISTER NAMES TABLE
        MOVE.L #FORMAT,A1       ;FORMAT-(LENGTH) TABLE
R4      MOVE.W (A0)+,D1 ;GET REG NAME
        CMPI.W #'??',D1 ;SEE IF AT END OF TABLE
        BNE.S R43
        BSR FIXBUF      ;SET UP FOR ERROR MESSAGE
        MOVE.L #'WHAT',(A6)+
        MOVE.L #' IS ',(A6)+
        MOVE.W D0,(A6)+
        MOVE.B #'?',(A6)+
        BRA MSG ;GO PRINT BUFFER 
;       TEST SOME SPECIAL CASES
;                THIS 'L.' IMPLIES BOARDER BETWEEN TRACE DISPLAYS
R43     CMPI.W #'L.',D0 ;IMPLIES LINE
        BNE.S R45
        MOVE.B (A5)+,ADALL+2.W  ;THIS IS WHAT BOARD WILL BE
        BRA R61
R45     CMPI.W #'D.',D0 ;IMPLIES ALL DATA REGISTERS
        BNE.S R46
        MOVE.L #ADALL,A1        ;GET ADDRESS OF FORMAT THING
        BRA.S R51
R46     CMPI.W #'A.',D0 ;IMPLIES ALL ADDRESS REGISTERS
        BNE.S R47
        MOVE.L #ADALL+1,A1      ;GET ADDRESS OF FORMAT THING
        BRA.S R51
R47     CMP.W D1,D0     ;SEE IF NAME IS SAME
        BEQ.S R5
        ADDA.L #1,A1    ;BUMP FORMAT TABLE
        BRA.S R4
R5      MOVE.B #4,(A1)  ;DEFAULT TO 4 BYTES
        ADDQ.L #1,D7    ;FLAG AS REG DEF MODE
        MOVE.B (A5)+,D0 ;SEE IF DECIMAL POINT
        CMPI.B #'.',D0
        BNE R1
R51     MOVE.B (A5)+,D0 ;GET FORMAT NUMBER
        CMPI.B #'Z',D0  ;SEE IF ZERO SURPRESS
        BEQ.S R6
        CMPI.B #'R',D0  ;SEE IF RELATIVE
        BEQ.S R6
        CMPI.B #'D',D0  ;SEE IF DECIMAL
        BEQ.S R6
        CMPI.B #'S',D0  ;SEE IF SYMBOLIC
        BEQ.S R6
        BSR GETHEX
        CMPI.B #4,D0
        BLE.S R6
        MOVEQ.L #2,D0   ;ERROR NUMBER 2 SIZE TOO LARGE
        BGT ERROR
;
R6      MOVE.B D0,(A1)  ;SAVE FORMAT
R61     MOVEQ.L #1,D7   ;SOMETHING DEFINED
        BRA R1  ;GO DO NEXT ONE
REGALL  MOVE.L #FORMAT,A0       ;SET UP SCANNER
REGALL2 MOVE.B D0,(A0)+
        SUBQ.L #1,D2
        BNE.S REGALL2
        BRA MACSBUG
REGNAMES DATA.L 'PCSR'  ;TABLE OF NAMES OF REGISTERS
        DATA.L 'D0D1'
        DATA.L 'D2D3'
        DATA.L 'D4D5'
        DATA.L 'D6D7'
        DATA.L 'A0A1'
        DATA.L 'A2A3'
        DATA.L 'A4A5'
        DATA.L 'A6A7'
        DATA.L 'USSS'
        DATA.L 'W0M0'
        DATA.L 'W1M1'
        DATA.L 'W2M2'
        DATA.L 'W3M3'
        DATA.L 'W4M4'
        DATA.L 'W5M5'
        DATA.L 'W6M6'
        DATA.L 'W7M7'
        DATA.W '??'
        PAGE
;
;       PRINT TRACE DISPLAY SUBROUTINE
;
TDISPLY BSR FIXBUF      ;PRINT PRELUDE
        MOVE.L SCREEN1.W,(A6)+
        BSR OUTPUT
        MOVE.L #FORMAT,A3       ;FORMAT BYTES
        MOVE.L #ROM+REGNAMES-ZERO,A4    ;REGISTER NAMES
        MOVE.L #REGPC,A2        ;REGISTER DATA
TD0     BSR FIXBUF      ;SUT UP I/O BUFFER
TD1     MOVE.L A6,D0    ;CALCUATE BUFFER LENGTH
        SUB.L A5,D0     ;SEE IF FULL
        CMPI.W #64,D0   ;BUFFER FULL IF 64 CHAR?
        BLE.S TD2
        BSR OUT1CR      ;PRINT FULL BUFFER
        BRA.S TD0
TD2     MOVE.W (A4)+,D0 ;GET REG NAME
        MOVE.B (A3)+,D1 ;GET FORMAT
        MOVE.L (A2)+,D7 ;GET REG CONTENT
        CMPI.W #'??',D0 ;SEE IF AT END OF REGS
        BNE.S TD4
        CMPA.L A6,A5    ;AT END SEE IF PRINT NEEDED
        BEQ.S TD21
        BSR OUT1CR      ;PRINT BUFFER
TD21    TST.B ADALL.W   ;SEE IF D REGS NEED PRINTING
        BEQ.S TD25
        MOVE.B #'D',D7  ;CLASS=DATA
        MOVE.L #REGS,A3 ;OFFSET
        BSR PNTCLS      ;GO PRINT THE BLOCK
TD25    TST.B ADALL+1.W ;SEE IF A REGS NEED PRINTING
        BEQ.S TD26
        MOVE.B  #'A',D7 ;CLASS=ADDRESS
        MOVE.L #REGS+32,A3      ;OFFSET
        BSR PNTCLS      ;GO PRINT THE BLOCK
TD26    MOVE.B ADALL+2.W,D0     ;CHECK FOR BOARDER
        BEQ.S TD3
        CMPI.B #'0',D0  ;ZERO=NO BOARDER
        BEQ.S TD3
        BSR FIXBUF
        MOVEQ.L #64,D1  ;LOOP COUNTER
TD27    MOVE.B D0,(A6)+ ;FILL BUFFER WITH BOARDER
        SUBQ.L #1,D1
        BNE.S TD27
        BSR OUT1CR      ;PRINT BOARDER
TD3     BSR FIXBUF      ;PRINT END STUFF FOR SCREEN CONTROL
        MOVE.L SCREEN2.W,(A6)+
        BSR OUTPUT
        RTS             ;RETURN FOR MORE WORK
TD4     CMPI.B #0,D1    ;SEE IF ZERO FORMAT
        BEQ.S TD1       ;JUST SKIP IT
        MOVE.W D0,D2    ;PRINT REG NAME IN BUFFER
        ASR.W #8,D0     ;MOVE IT OVER
        MOVE.B D0,D3    ;SAVE REGISTER TYPE A,D,W,M ETC
        MOVE.B D0,(A6)+ ;SAVE FIRST LETTER
        MOVE.B D2,(A6)+ ;SAVE NEXT LETTER
        MOVE.B #'=',(A6)+       ;EQUAL SIGN
        CMPI.W #'A7',D2 ;SEE IF IRREGULAR STACK STUFF
        BNE.S T44
        MOVE.L REGSR.W,D0       ;GET STATUS
        ANDI.W #$2000,D0 ;CHECK SUPERVISOR
        BNE.S T448      ;IS SUPER
        MOVE.L REGUS.W,D0       ;IS NOT SUPER
        BRA.S T449
T44     CMPI.W #'SS',D2 ;SUPER STACK IS SPECIAL
        BNE.S T448
        MOVE.L REGA7.W,D0       ;GET A7
        BRA.S T449
T448    MOVE.L D7,D0    ;REGISTER VALUE
        CMPI.B #'W',D3  ;SEE IF IT IS A WINDOW
        BEQ.S TDW1
        CMPI.B #'M',D3  ;SEE IF MEMORY
        BNE.S T449
TDW1    MOVE.L D1,D6    ;SAVE FORMAT
        MOVE.B D3,D7    ;SAVE CLASS 'M' OR 'W'
        ANDI.L #$F,D2    ;COMPUTE MEMORY WINDOW TABLE
        MULU #8,D2      ;FROM REGISTER NUMBER
        ADDI.W #WINDOWS,D2
        MOVE.L D2,A1    ;POINTS TO TABLE ENTRY-6BYTES
        TST.B (A1)      ;SEE IF DEFINED
        BNE.S TDW2
        SUBA.L #4,A6    ;BACK UP        .M0=    4 SPOTS
        BRA TD9 ;PUT BACK IN SPACE
TDW2    BSR WINDA       ;GET ADDRESS INTO D3,D0,A0
        CMPI.B #'W',D7  ;IF WINDOW-PRINT ADDRESS
        BEQ.S TDW9
        BSR WINDM       ;GET CONTENT INTO DO
TDW9    MOVE.L D6,D1    ;RESTORE FORMAT
T449    CMPI.B #1,D1    ;SEE IF #1 FORMAT
        BNE.S TD5
T44A    BSR PNT2HX
        BRA.S TD9
TD5     CMPI.B #2,D1    ;SEE IF #2 FORMAT
        BNE.S TD6
TD51    BSR PNT4HX
        BRA.S TD9
TD6     CMPI.B #3,D1    ;SEE IF #3 FORMAT
        BNE.S TD7
TD61    BSR PNT6HX
        BRA.S TD9
TD7     CMPI.B #'Z',D1  ;SEE IF ZERO SURPRESS
        BNE.S TD71
        BSR PNTZHX      ;PRINT WITH ZERO SURPRESS
        BRA.S TD9
TD71    CMPI.B #'R',D1  ;SEE IF RELATIVE
        BNE.S TD72
        SUB.L OFFSET.W,D0 ;ADJUST VIA OFFSET
        BSR PNTZHX
        MOVE.B #'R',(A6)+       ;MARK AS RELATIVE
        BRA.S TD9
TD72    CMPI.B #'D',D1  ;SEE IF DECIMAL
        BNE.S TD73
        BSR HEX2DEC     ;GO PRINT DECIMAL
        BRA.S TD9
TD73    CMPI.B #'S',D1  ;SEE IF SYMBOLIC
        BEQ.S TDSYMB
TD8     CMPI.W #'SR',D2 ;SEE IF STATUS REGISTER
        BEQ.S TD51
        CMPI.W #'PC',D2 ;SEE IF PROGRAM COUNTER
        BEQ.S TD61
        CMPI.B #'1',D1  ;SEE IF ASCII 1
        BEQ.S T44A
        CMPI.B #'2',D1
        BEQ.S TD51
        CMPI.B #'3',D1
        BEQ.S TD61
        BSR PNT8HX
TD9     MOVE.B #' ',(A6)+       ;SPACE BETWEEN REGS
        BRA TD1
;
;       SYMBOLIC FORMAT D0 HAS VALUE...
;       SEARCH SYMBOL TABLE FOR VALUE
;       IF FOUND RETURN NAME IN D6,D7
;       IF NOT FOUND RETURN 8 HEX CHAR (VALUE) IN D6-D7
TDSYMB  BSR SNUMTAB     ;GET NAME INTO D6-D7
        MOVE.B #0,(A6)  ;NULL OUT CURRENT POSITION
        MOVE.L A6,D0    ;MAKE SURE A6 IS EVEN
        ADDQ.L #1,D0
        ANDI.B #$FE,D0   ;TURN OFF LOWEST BIT
        MOVE.L D0,A6
        MOVE.L D6,(A6)+ ;SAVE NAME OR HEX VALUE
        MOVE.L D7,(A6)+ ;LOWER PART
        BRA.S TD9
        PAGE
;
;       SAVE ALL REGISTERS ROUTINE-JMP (TEMP) BACK
;
SAVE
;       MOVE.L A7,REGA7.W       ;FREE UP FOR WORK               *KB 8/18/82*
;       MOVE.L #REGA7,A7        ;WHERE TO START STORING         *KB 8/18/82*
;       MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE REGISTERS         *KB 8/18/82*
;       MOVE.L #SYSTACK,A7      ;SET UP REAL MACSBUG STACK      *KB 8/18/82*
;       MOVE.L REGA7.W,A0       ;GET OLD SS                     *KB 8/18/82*
;       MOVE.W (A0)+,REGSR+2.W  ;GET SR                         *KB 8/18/82*
;       MOVE.L (A0)+,REGPC.W    ;GET PC                         *KB 8/18/82*
;       MOVE.L A0,REGA7.W       ;WHERE STACK REALLY POINTS      *KB 8/18/82*
                                        ;                       *KB 8/18/82*
        MOVE.W  (A7)+, REGSR+2.W        ;save status reg        *KB 8/18/82*
        MOVE.L  (A7)+, REGPC.W          ;save users PC          *KB 8/18/82*
        MOVE.L  A7, REGA7.W             ;save real PC           *KB 8/18/82*
        LEA     REGA7.W, A7             ;save users registers   *KB 8/18/82*
        MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE REGISTERS         *KB 8/18/82*
        LEA     SYSTACK.W, A7           ;use local stack        *KB 8/18/82*

        MOVE.L USP,A1           ;GET USERS STACK POINTER
        MOVE.L A1,REGUS.W       ;SAVE IT FOR DISPLAY ETC
        MOVE.L REGPC.W,D0       ;GET PROGRAM COUNTER
        CLR.L D1                ;FORM RETURN ADDRESS
        MOVE.W TEMP.W,D1        ;GET ADDRESS
        ADDI.L #ROM,D1           ;ADD IN START OF ROM
        MOVE.L D1,-(A7)         ;PUT ON STACK
        CLR.W RUN.W             ;USERS REGISTERS ON SAVE (DONT OVERWRITE)
        RTS                     ;RETURN TO SENDER
;
;
;       UNSAVE ALL REGISTERS-JMP (TEMP) BACK
;
UNSAVE  MOVE.L REGUS.W,A1       ;RESTORE USER'S STACK
        MOVE.L A1,USP
        MOVE.L #REGS,A7 ;RESTORE REGISTERS
        MOVEM.L (A7)+,D0-D7/A0-A6
        MOVE.L REGA7.W,A7       ;FIX UP SS
        MOVE.L REGPC.W,-(A7)    ;PUSH PROGRAM COUNTER
        MOVE.W REGSR+2.W,-(A7)  ;STATUS REGISTER
        MOVE.W TEMP.W,-(A7)     ;PUSH ON STACK RETURN ADDRESS
        MOVE.W #2,-(A7) ;ROM STARTS AT 20000
        MOVE.W #1,RUN.W ;USER STARTING TO RUN (SAVE HIS REG)
        RTS             ;GO BACK TO CALLER
        PAGE
;
;       ***TRACE***     TRACE ENTRY POINT
;
TRACE   MOVE.W #$2700,SR        ;MASK OFF INTERRUPTS
        MOVE.W #TRACE00-ZERO,TEMP.W     ;SET UP TO COME BACK FROM SAVE
        BRA.S SAVE      ;SAVE ALL REGISTERS
TRACE00 CLR.L D6        ;WHEN D6>0 MUST PRINT COUNTED BP
        BSR FIXBP       ;CHECK FOR BREAKPOINT
        MOVEQ.L #9,D7   ;8TH BP IS 'UNTILL' FEATURE
        MOVE.L REGPC.W,D1
TRACE01 CMP.L (A0),D1   ;SEE IF PC MATCHES ADDRESS IN TABLE
        BNE.S TRACE08
        MOVEQ.L #-1,D6  ;MUST PRINT
        MOVE.L (A2),D0  ;GET COUNT
        BEQ.S TRACE02
        SUBQ.L #1,D0    ;COUNT DOWN
        MOVE.L D0,(A2)  ;SAVE IT
        BNE.S OKTD
TRACE02 CLR.L TRACECNT.W        ;STOP AFTER PRINT
        BRA.S OKTD
TRACE08 ADDA.L #4,A0    ;BUMP TABLE POINTER
        ADDA.L #2,A2    ;BUMP COUNT TABLE POINTER
        SUBQ.L #1,D7    ;LOOP AROUND
        BNE.S TRACE01
        MOVE.L TRACECNT.W,D0    ;EXAMIN THE TRACE COUNTER
        BEQ.S OKTD      ;WAS ALREADY ZERO-PRINT DISPLAY
        SUBQ.L #1,D0    ;SUBTRACT 1
        MOVE.L D0,TRACECNT.W    ;SAVE NEW VALUE
        TST.B D6        ;SEE IF MUST PRINT
        BNE.S OKTD      ;NONZERO=MUST PRINT
        TST.L D0        ;CHECK TRACE COUNTER
        BEQ.S OKTD      ;COUNT=ZERO...PRINT IT
        BPL.S TRACE0    ;NEGATIVE=SPECIAL CASE
; END UP HERE AFTER BREAKPOINTING ONE
; INSTRUCTION-PUT BP BACK IN AND CONTINUE TO RUN
        MOVE.L REGSR.W,D0       ;TURN TRACE MODE OFF
        ANDI.L #$7FFF7FFF,D0
        MOVE.L D0,REGSR.W       ;SAVE IT
        CLR.L TRACECNT.W
        BSR SWAPIN      ;PUT BP BACK INTO USER'S MEMORY
        BRA UNSTACK     ;CONTINUE TO RUN
TRACE0  MOVE.L REGPC.W,D0       ;CHECK WHERE WE ARE
        CMP.L LOOPR1.W,D0       ;IS BELOW LOOP RANGE?
        BLT.S OKTD
        TST.L LOOPR2.W          ;SEE IF OTHER IS ZERO
        BEQ.S OKTD
        CMP.L LOOPR2.W,D0       ;IS ABOVE RANGE?
        BLE.S NOTD
OKTD    BSR TDISPLY     ;GO PRINT TRACE DISPLAY
        TST.L TRACECNT.W        ;CHK THE COUNTER
        BEQ MACSBUG     ;STOP WHEN ZERO
NOTD    BRA UNTRACE     ;CONTINUE WITH TRACE
        PAGE
;
;       ***T*** TRACE COMMAND
;
;
TCMD    MOVE.L #ROM+TRACE1-ZERO,A0      ;IF NO PARAMTERS
        MOVE.W #-1,TRACEON.W    ;SET FLAG FOR TRACE ON
        BSR FINDNP      ;FIND NEXT PARAMETER
        LSL.L #8,D0     ;GET ALL 4 CHARAC
        MOVE.B 2(A5),D0
        LSL.L #8,D0
        MOVE.B 3(A5),D0
        CMPI.L #'TILL',D0
        BNE.S TCMD1
        MOVE.B 4(A5),D0 ;SEE IF FOLLOWED BY A SPACE
        CMPI.B #' ',D0
        BEQ.S TCMD5
TCMD1   MOVEQ.L #1,D0   ;DEFAULT VALUE
        BSR GETNUMA     ;FIND NUMBER OF INST TO TRACE
        MOVE.L D0,TRACECNT.W
        BRA.S UNTRACE
TCMD5   BSR WHATNUM     ;GET NUMBER ELSE PRINT WHAT
        MOVE.L D0,BPTILL.W      ;9TH BP
        MOVE.L #$FFFF,TRACECNT.W        ;SET FOR A VERY LONG TIME
        BRA.S UNTRACE
TRACE1  MOVE.L #1,TRACECNT.W
UNTRACE BSR SWAPSOME    ;SWAP IN MOST BREAKPOINTS
        MOVE.L REGSR.W,D0       ;SET UP TRACE BIT!
        ORI.W #$8000,D0
        MOVE.L D0,REGSR.W
UNSTACK MOVE.W #UNSTACK2-ZERO,TEMP.W    ;WHERE TO RETURN
        BRA UNSAVE      ;RESTORE ALL REGISTERS
UNSTACK2 MOVE.L A0,A0   ;DELAY SOME
        RTE             ;GO BACK TO THE USER
;
        PAGE
;
;       ***GO***        RUN PROGRAM (NOT TRACE)
;
GOCMD   MOVE.L #ROM+GOCMD1-ZERO,A0      ;WHERE TO GO IF NO PARAMERS
        BSR FINDNP
        LSL.L #8,D0     ;GET ALL FOUR CHARACTERS
        MOVE.B 2(A5),D0
        LSL.L #8,D0
        MOVE.B 3(A5),D0
        CMPI.L #'TILL',D0
        BNE.S GOCMD0
        MOVE.B 4(A5),D0 ;SEE IF FOLLOWED BY SPACE
        CMPI.B #' ',D0
        BNE.S GOCMD0
GOUNTIL BSR WHATNUM     ;GET NUMBER ELSE PRINT WHAT
        MOVE.L D0,BPTILL.W      ;9TH BREAKPOINT
        BRA.S GOCMD1    ;NORMAL STARTUP
GOCMD0  CLR.L D0        ;DEFAULT ADDRESS
        BSR GETNUMR
        MOVE.L D0,REGPC.W
GOCMD1  MOVE.L #$FFFFFFFF,TRACECNT.W    ;FLAG THE COUNTER AS SPECIAL
        BRA.S UNTRACE   ;TRACE ONE GO GET PAST POSSIBLE BREAKPOINT
;
SWAPSOME BSR SWAPOUT    ;MAKE SURE THEY ARE ALL OUT
        MOVE.L #ROM+SWAPSOM1-ZERO,A6    ;ROUTINE FOR IT
        BRA.S SWAPINK
;
SWAPIN  BSR SWAPOUT     ;MAKE SURE THEY ARE ALL OUT
        MOVE.L #ROM+SWAPIN1-ZERO,A6     ;ROUTINE FOR IT
SWAPINK MOVE.L $BC.W,D0 ;SEE WHAT VECTOR
        CMPI.L #ROM+CHKBP-ZERO,D0       ;DONT OVERWRITE WITH THIS
        BEQ.S SWAPBP
        MOVE.L $BC.W,SAVETRAP.W ;SAVE USERS TRAP ADDRESS
        MOVE.L #ROM+CHKBP-ZERO,$BC.W    ;PUT IN OUR BREAKPOINT VECTOR
        BRA.S SWAPBP
SWAPOUT TST.W BPSTATUS.W        ;SEE IF ALREADY OUT
        BEQ.S SWAPEND   ;BPSTATUS=0 IF OUT
        MOVE.L SAVETRAP.W,$BC.W ;PUT USERS VECTOR BACK IN RAM
        MOVE.L #ROM+SWAPOUT1-ZERO,A6
SWAPBP  BSR FIXBP       ;GET POINTERS ETC.
        MOVEQ.L #9,D7   ;DO 9 BP
        MOVE.L #BPDATA,A3       ;CONTENT TABLE
SWAP1   MOVE.L (A0),A4  ;GET POSSIBLE ADDDRESS
        CMPA.L #0,A4    ;TEST A4
        BEQ.S SWAP99    ;ZERO MEANS NO BP DEFINED
        JMP (A6)        ;GO TO RIGHT ROUTINE
SWAPSOM1 CMPA.L REGPC.W,A4      ;SEE IF AT CURRENT ADDRESS
        BEQ SWAP99
SWAPIN1 MOVE.W (A4),(A3)        ;USER'S PROGRAM GOES INTO TABLE
        MOVE.W #$4E4F,(A4)      ;PUT BREAKPOINT IN (TRAP 15)
        MOVE.W #1,BPSTATUS.W    ;FLAG AS BP IN
        BRA.S SWAP99
SWAPOUT1 MOVE.W (A3),(A4)       ;PUT CONTENTS BACK INTO PROGRAM
        CLR.W BPSTATUS.W        ;FLAG AS BREAKPOINTS OUT
SWAP99  ADDA.L #4,A0    ;BUMP ADDRESS TABLE POINTER
        ADDA.L #2,A3    ;BUMP CONTENT TABLE POINTER
        SUBQ.L #1,D7
        BNE.S SWAP1
SWAPEND RTS
        PAGE
;
;       BREAKPOINT TEST
;       USER HIT A TRAP 7....
;       SEE IF IT MATCHES ANY BREAKPOINT
;
CHKBP   MOVE.W #$2700,SR        ;MASK OF INT.
        MOVE.W #CHKBP00-ZERO,TEMP.W     ;WHERE TO GO AFTER SAVE
        BRA SAVE        ;SAVE ALL REGISTERS
CHKBP00 BSR FIXBP       ;GET POINTER TO ADDRESS/COUNTES
        MOVEQ.L #9,D7   ;8TH PB IS 'UNITLL' FEATURE
        MOVE.L REGPC.W,D0       ;GET PROGRAM COUNTER TO COMPARE
        SUBQ.L #2,D0    ;BACKUP TO ADDRESS OF TRAP
CHKBP1  CMP.L (A0),D0   ;SEE IF WE ARE THERE
        BEQ.S CHKBP2
        ADDA.L #4,A0    ;BUMP BOTH POINTERS
        ADDA.L #4,A2
        SUBQ.L #1,D7
        BNE.S CHKBP1
; IS NOT A BREAKPOINT
        MOVE.W #CHKBP5-ZERO,TEMP.W      ;WHERE TO RETURN
        BRA UNSAVE
CHKBP5  MOVE.L SAVETRAP.W,-(A7) ;GO TO WHERE USER WANTS TO GO
        RTS
; IS BREAKPOINT...CHECK COUNT
CHKBP2  MOVE.L (A2),D0  ;GET COUNT
        BEQ.S CHKBP3
        SUBQ.L #1,D0    ;DECREMENT
        MOVE.L D0,(A2)  ;PUT COUNT AWAY
        BEQ.S CHKBP3
        BSR CHKBP4
        BRA GOCMD1      ;KEEP GOING
CHKBP3  BSR CHKBP4      ;COUNT IS ZERO
        BRA MACSBUG     ;COMMAND LINE
CHKBP4  BSR SWAPOUT     ;TAKE BP OUT OF MEMORY
        MOVE.L REGPC.W,D0       ;ADJUST THE PROGRAM COUNTER
        SUBQ.L #2,D0    ;MOVE IT BACK TO POINT AT BP ADDRESS
        MOVE.L D0,REGPC.W       ;SAVE IT
        BSR TDISPLY     ;PRINT TRACE DISPLAY
        RTS
        PAGE
;
;       HANDLE THE ABORT BUTTON
;
ABORTB  TST.W RUN.W     ;SEE IF USER WAS RUNNING
        BEQ MACSBUG     ;
        MOVE.W #ABORTB0-ZERO,TEMP.W     ;WHERE TO GO AFTER SAVE
        BRA SAVE        ;PUT ALL REG AWAY
ABORTB0 BSR TDISPLY
        BRA MACSBUG
;
;       OTHER TRAP AND EXCEPTION VECTORS INITIALIZED TO HERE
;
ABORTE  TST.W RUN.W     ;SEE IF USER WAS RUNNING
        BEQ ABORTE0
        MOVE.W #ABORTE0-ZERO,TEMP.W     ;WHERE TO GO AFTER SAVE
        BRA SAVE
ABORTE0 BSR FIXBUF      ;SEND MESAGE
        MOVE.L #'TRAP',(A6)+
        MOVE.L #' ERR',(A6)+
        MOVE.L #'OR ',(A6)+
        BRA MSG
;
;       THIS BRANCH INSERTED TO MATCH THE RELEASED 1.3 CODE
;
        BRA     ZERO    ;(SIMILAR TO "ADDA" IN PURPOSE).
;
        PAGE
;
;       PRINT HEX ROUTINES
;
;
; PRINT 8 HEX CHARACTERS
;
PNT8HX  SWAP D0         ;FLIP REG HALVES
        BSR PNT4HX      ;DO TOP WORD
        SWAP D0 ;NOW DO LOWER WORD
        BRA PNT4HX
; PRINT 6 HEX CHARACTERS
PNT6HX  SWAP D0 ;FLIP REGISTER HALVES
        BSR PNT2HX
        SWAP D0 ;FLIP BACK REG HALVES
; PRINT 4 HEX CHARACTERS IN D0.W
PNT4HX  MOVE.W D0,D1    ;SAVE IN TEMP
;
;******************************************************************OPT*
;                                                               *OPT*
;       NOTE ROXR AND ROR WERE REVERSED IN CROSS ASSEMBLER...   *OPT*
;       THE SOURCE      ;HERE IS SWITCHED TO MATCH OBJECT CODE IN 1.3 *OPT*
;
        ROXR.W #8,D0    ;GET BITS 15-8 INTO LOWER BYTE.         *OPT*
        BSR PNT2HX      ;PRINT IT
        MOVE.W D1,D0    ;PULL IT BACK
; PRINT 2 HEX CHARACTERS IN D0.B
PNT2HX  MOVE.W D0,D2    ;SAVE IN TEMP REG
        ROR.W #4,D0     ;FORM UPPER NIBBLE                      *OPT*
;
;******************************************************************OPT*
;
        BSR PUTHEX      ;PUT ASCII INTO PRINT BUFFER
        MOVE.W D2,D0    ;GET BACK FROM TEMP
; CONVERT D0.NIBBLE TO HEX & PUT IT IN PRINT BUFFER
;
PUTHEX  ANDI.B #$0F,D0   ;SAVE LOWER NIBBLE
        ORI.B #$30,D0    ;CONVERT TO ASCII
        CMPI.B #$39,D0  ;SEE IF IT IS>9
        BLE SAVHEX
        ADDQ #7,D0      ;ADD TO MAKE 10=>A
SAVHEX  MOVE.B D0,(A6)+ ;PUT IT IN PRINT BUFFER
        RTS
        PAGE
;
;
;       PRINT HEX (ZERO SURPRESS)
;
PNTZHX  CLR.L D4        ;IS ZERO WHEN SURPRESSING
        MOVE.L D0,D1    ;SAVE IN TEMP
        BEQ.S PNTZ81    ;IF ZERO
        BPL.S PNTZ0
        NEG.L D1        ;CHANGE TO POSITIVE VALUE
        MOVE.B #'-',(A6)+       ;PUT SIGN INTO BUFFER
PNTZ0   MOVEQ.L #8,D2   ;8 POSSIBLE CHARACTERS
PNTZ1   MOVE.L D1,D0    ;UNSAVE IT
        MOVE.L D2,D3    ;COUNT DOWN FROM HERE
        SUBQ.L #1,D3    ;BACK OFF ONE
        BEQ.S PNTZ4     ;IF NO ROTATE SKIP THIS
PNTZ2   ASR.L #4,D0     ;ROTATE LRIGHT
        ANDI.L #$FFFFFFF,D0      ;CLEAR TOP NIBBLE
        SUBQ.L #1,D3
        BNE.S PNTZ2
PNTZ4   ANDI.B #$F,D0    ;SAVE ONLY NIBBLE
        BNE.S PNTZ3
        TST.B D4        ;SEE IF STILL SURPRESSING
        BEQ.S PNTZ8
PNTZ3   BSR.S PUTHEX    ;PUT A HEX CHAR IN BUFFER
        MOVE.B D0,D4    ;MARK AS NON-SURPRESSING MODE
PNTZ8   SUBQ.L #1,D2    ;DO ANOTHER CHAR
        BNE.S PNTZ1
        TST.B D4        ;SEE IF ANYTHING PRINTED
        BNE.S PNTZ9
PNTZ81  MOVE.B #'0',(A6)+       ;MOVE AT LEAST ONE ZERO
PNTZ9   RTS
        PAGE
;*********************************************************
;*
;*      FIND NEXT PARAMETER IN COMMAND LINE
;*      ENTRY: (A5) POINTS TO CURRENT LOCATION IN LINE
;*      (A0) IS WHERE TO JUMP TO IF NO PARAMTERS FOUND
;*      RTS IF PARAMETER IF FOUND (A5) POINT TO IT
;*
;*********************************************************
;
FINDNP  CLR.L D1        ;0=SEARCH FOR DELIMITER
FINDNP1 CMPA.L A6,A5    ;SEE IF AT END OF BUFFER
        BEQ.S FINDNP2
        MOVE.B (A5),D0  ;GET CMMD LNE CHAR
        CMPI.B #$20,D0  ;IS IT SPACE
        BEQ.S FINDNP3
        CMPI.B #',',D0  ;IF IS COMMA
        BEQ.S FINDNP3
        CMPI.B #$3B,D0  ;SEMICOLEN?
        BNE.S FINDNP4
FINDNP2 JMP (A0)        ;NO PARAMETER-JUST OPTIONS?
FINDNP3 MOVEQ.L #-1,D1  ;MARK-SEARCH FOR NON SPACE
        BRA.S FINDNP5
FINDNP4 TST.B D1        ;SEE WHAT MODE
        BEQ.S FINDNP5
        ASL.W #8,D0     ;READY TO HOLD FIRST 2 CHAR
        MOVE.B 1(A5),D0 ;GET NEXT BYTE
        RTS             ;FOUND SOMETHING FOR REAL
FINDNP5 ADDA.L #1,A5    ;BUMP FOR NEXT CHAR
        BRA.S FINDNP1   ;GET NEXT ETC.
        PAGE
;
;       ***GETNUM***    GET A HEX NUMBER FROM THE BUFFER
;       BUFFER STARTS AT (A5)
;
GRABNUMA BSR.S FINDNP   ;FIND NEXT PARAMETER
        CLR.L D7        ;NORMAL ERROR
        BRA.S GETNUMA   ;ONE ABSOLUE PARAMETER
WHATNUM MOVE.L #WHAT-ZERO,D7    ;WHAT RESPONSE
        MOVE.L #ROM+ERROR-ZERO,A0       ;IF NO PARAMTER
GRABNUM BSR.S FINDNP    ;SCAN FOR NEXT PARAMTER
        CLR.L D7        ;SET FOR NORMAL PARAMETER
GETNUMR MOVE.L OFFSET.W,WORK2.W   ;SAVE OFFSET
        BSR.S GETNUMA   ;GET ABSOLUTE NUMBER
        MOVE.L D0,WORK1.W       ;SAVE IT FOR A MOMENT
        MOVE.B (A5),D0  ;SEE IF COMMA
        CMPI.B #',',D0
        BEQ.S GETNUMR3  ;HAS SECOND PARAMETER
        MOVE.L WORK1.W,D0       ;RESTORE
        ADD.L WORK2.W,D0        ;ADD IN DEFAULT OFFSET
        RTS
GETNUMR3 CLR.L D0       ;DEFAULT OFFSET
        ADDA.L #1,A5    ;GET PAST COMMA
        BSR.S GETNUMA   ;GET PARAMETER
        ADD.L WORK1.W,D0        ;ADD IN MAIN PART
        RTS
GETNUMA MOVE.W #16,BASE.W       ;SET BASE TO HEX
; FORM SYMBOL-CHECK     ;TABLE
GETNUMS MOVEM.L D0-D2/D6-D7/A1,-(A7)    ;FREE UP SOME ROOM
        BSR GETSY       ;GET SYMBOL INTO D6,D7
        TST D6  ;D6=NULL IF NOT A SYMBOL
        BEQ.S GETNUM0
;       SEARCH SYMBOL TABLE
        MOVE.L STRSYM.W,A1      ;START OF TABLE
GN5     CMPA.L ENDSYM.W,A1      ;SEE IF AT END
        BEQ.S GETNUM0
        BPL.S GETNUM0
        CMP.L (A1),D6   ;CHECK FIRST 4 LETTERS
        BNE.S GN6
        CMP.L 4(A1),D7  ;SECOND 4 BYTES
        BNE.S GN6
        ADDA.L D1,A5    ;BUMP TO END OF STUFF
;
        MOVE.L 8(A1),TEMP.L     ;FORCE LONG BACKWARD REF.
;
;
        MOVEM.L (A7)+,D0-D2/D6-D7/A1    ;RESTORE EVERYTHING
        MOVE.L TEMP.W,D0        ;GET VALUE
        TST.W SIGN.W    ;0=POSITIVE ELSE=MINUS THE VALUE
        BEQ RETURN
        NEG.L D0        ;MAKE IS MINUS
        RTS
GN6     ADDA.L #12,A1   ;PUMP POINTER
        BRA.S GN5
;       ITS NOT A SYMBOL-DECODE AS NUMBER
GETNUM0 MOVEM.L (A7)+,D0-D2/D6-D7/A1    ;RESTORE
GETNUM1 MOVE.L D0,D3    ;TRANSFER DEFAULT VALUE
        CLR.B SIGN.W    ;SET SIGN TO PLUS
        CLR.W TEMP.W    ;FLAG FOR CHARACTER HIT
        CLR.L D0
        CLR.L D1        ;WHERE TO PUT RESULTS
NXTNUM  CMPA.L A6,A5    ;SEE IF AT END OF BUFFER
        BEQ EXITGN
        MOVE.B (A5)+,D0 ;GRAB CHARACTER
        CMPI.B #$20,D0  ;CHECK FOR SPACE
        BNE.S GETNUM3
        TST.W TEMP.W    ;SEE IF ANYTHING ENTERED
        BEQ.S NXTNUM    ;IF NOT SCAN NEXT CHAR
GETNUM2 MOVE.B -(A5),D2 ;BACK UP TO POINT AT SPACE
        BRA EXITGN      ;IF SO-END
GETNUM3 CMPI.B #$27,D0  ;SEE IF SINGLE QUOTE
        BEQ GETNUMST    ;GET NUM STRING
        CMPI.B #$3B,D0
        BEQ.S GETNUM2   ;WHERE TO GO IF SEMICOLEN
        CMPI.B #',',D0  ;SEE IF COMMA
        BEQ.S GETNUM2
        CMPI.B #'/',D0  ;SEE IF SLASH
        BEQ.S GETNUM2
        CMPI.B #'^',D0  ;SEE IF UP ARROW
        BEQ.S GETNUM2
        CMPI.B #':',D0  ;SEE IF COLEN
        BEQ.S GETNUM2
        CMPI.B #'=',D0  ;SEE IF EQUAL SIGN
        BEQ.S GETNUM2
        CMPI.B #'(',D0  ;SEE IF LEFT PAREN
        BEQ.S GETNUM2
        CMPI.B #'R',D0  ;FOR RELATIVE
        BEQ EXITREL
        CMPI.B #'-',D0  ;SEE IF NEG SIGN
        BNE.S GETNUM4
        TST.W TEMP.W    ;SEE IF ANY CHARACTERS BEFORE?
        BNE     ERROR1
        MOVE.B #$FF,SIGN.W      ;SET FLAG AS NEGATIVE
        BRA.S NXTNUM
GETNUM4 CMPI.B #'&',D0  ;SEE IF FLAGGED AS DECIMAL
        BNE.S GETNUM41
        TST.W TEMP.W    ;SEE IF ANYTHING DECODED
        BNE ERROR1
        MOVE.W #10,BASE.W       ;BASE IS DECIMAL
;
        BRA NXTNUM      ;FORCE LONG, (SIMILAR TO "ADDA" MACRO).
;
GETNUM41 CMPI.B #'$',D0 ;SEE IF FLAGGED AS HEX
        BNE.S GETNUM5
        TST.W TEMP.W    ;SEE IF ANYTHING DECODED
        BNE.S ERROR1
        MOVE.W #16,BASE.W       ;BASE IS 16
        BRA NXTNUM
GETNUM5 BSR GETHEX      ;RETURNS WITH D0=BINARY
        CMP.W BASE.W,D0 ;IS INPUT LARGER THAN BASE
        BHI.S ERROR1
        MOVE.W #-1,TEMP.W       ;FLAG AS SOMETHING READ
        MOVE.L D1,D2    ;GET READY TO MULTIPLY D1*BASE
        SWAP D1
        MULU BASE.W,D1  ;TOP PART
        SWAP D1
        TST.W D1        ;CHECK FOR OVERFLOW
        BNE.S ERROR1    ;VALUE IS TOO LARGE
        MULU BASE.W,D2  ;NOW WORK ON LOW WORD
        ADD.L D2,D1     ;PUT IT BACK TOGETHER
        BVS.S ERROR1    ;OVERFLOW?
        ADD.L D0,D1     ;ADD IN NEW STUFF
        BVS.S ERROR1    ;ON OVERFLOW
        CLR.L D3        ;WIPE OUT DEFAULT VALUE
        BRA NXTNUM
GETNUMST TST.L D1       ;IF SOMETHING IS BEFORE THIS ERROR OUT
        BNE SYNTAX
        MOVEQ.L #5,D2   ;COUNTER
GETNUMS1 MOVE.B (A5)+,D0        ;LOAD CHARACTER
        CMPI.B #$27,D0  ;SEE IF SINGLE QUOTE
        BEQ GETNUM2     ;WHERE TO GO IF END
        LSL.L #8,D1     ;MAKE ROOM FOR NEW CHARACTER
        MOVE.B D0,D1    ;NEW BYTE
        CLR.L D3        ;WIPE   OUT DEFAULT VALUE
        CMPA.L A6,A5    ;SEE IF AT END OF BUFFER
        BEQ.S EXITGN    ;WHERE TO GO IF END OF BUFFER
        SUBQ.L #1,D2
        BNE.S GETNUMS1
        BRA SYNTAX      ;NO CLOSING QUOTE OR TOO LONG
EXITGN  MOVE.L D1,D0    ;SET UP RESULT FOR RETURN
        TST.B SIGN.W    ;SEE IF NEG
        BEQ.S RTS5
        NEG.L D0        ;CHANGE TO NEGATIVE NUMBER
RTS5    ADD.L D3,D0     ;ADD IN OLD DEFAULT VALUE
        RTS             ;END OF GETNUM-NORMAL RETURN
ERROR1  BRA ERROR       ;INDIRECT ERROR STUFF
;
;       EXIT RELATIVE
EXITREL CLR.L WORK2.W   ;CLEAR RELATIVE OFFSET
        TST.B SIGN.W
        BEQ.S EXITR2
        NEG.L D1        ;CHANGE TO NEGATIVE
EXITR2  MOVE.L D1,D0    ;RETURNS D0
        ADD.L OFFSET.W,D0
        RTS
        PAGE
;
;       ***GETHEX***    GET HEX (BINARY VALUE FROM ASCII)
;       D0.B HAS ASCII CHAR     RETURNS $0-$F BINARY OR $FF ON ERROR
;
GETHEX  ANDI.L #$FF,D0    ;STRIP OFF ALL BUT BYTE
        CMPI.B #$30,D0  ;IS IT LESS THAN ZERO
        BLT.S ERROR2
        CMPI.B #$39,D0  ;IS IT GREATER THAN 9
        BGT.S GTHX2
GTHX1   ANDI.L #$F,D0    ;SAVE ONLY LAST NIBBLE  HIGH 28 BITS OFF
        RTS
GTHX2   CMPI.B #$41,D0  ;IS IT LESS THAN 'A'
        BLT.S ERRDIG
        CMPI.B #$46,D0  ;IS IT GT 'F'
        BGT.S ERRDIG
        SUBQ.B #7,D0    ;MAKE IT SMALLER A=10
        BRA.S GTHX1
ERRDIG  CMPI.W #WHAT-ZERO,D7    ;SEE IF WHAT RESPONSE
        BEQ.S ERROR
        BSR FIXBUF      ;PRINT NOT A HEX DIGIT
        MOVE.B D0,(A6)+ ;PUT IN OFFENDING CHAR
        MOVE.B #' ',(A6)+       ;SPACE
        MOVE.L #'IS N',(A6)+
        MOVE.L #'OT A',(A6)+
        MOVE.L #' HEX',(A6)+
        MOVE.L #' DIG',(A6)+
        MOVE.W #'IT',(A6)+
        BRA MSG ;GO PRINT IT AND ENTER MACSBUG
ERROR2  MOVEQ.L #1,D0   ;ERROR NUMBER 1
ERROR   BSR FIXBUF      ;PRINT 'ERROR'
        CMPI.W #WHAT-ZERO,D7    ;SEE IF 'WHAT' RESPONSE
        BNE.S ERR1
        MOVE.L #'WHAT',(A6)+
        BRA.S ERR2
ERR1    MOVE.L #'ERRO',(A6)+
        MOVE.W #'R ',(A6)+
ERR2    BRA MSG ;PRINT MESSAGE-ENTER MACSBUG
;
;
SYNTAX  BSR FIXBUF      ;PRINT 'SYNTAX ERROR'
        MOVE.L #'SYNT',(A6)+
        MOVE.L #'AX E',(A6)+
        MOVE.L #'RROR',(A6)+
        BRA MSG         ;GO PRINT IT
        PAGE
;
;       ***#?***        NUMBER CONVERSTIONS
;
NUMCON0 MOVE.W #10,BASE.W       ;DECIMAL TO HEX
        MOVE.L #ROM+SYNTAX-ZERO,A0      ;IF NO PARAMETERS
        BSR FINDNP      ;POINT TO NEXT PARAMETER
        CLR.L D0        ;DEFAULT         
        MOVE.W #10,BASE.W       ;DEFAULT BASE
        BSR GETNUMS     ;GET NUMBER (MIGHT BE SYMBOLIC)
        MOVE.L D0,D7    ;SAVE IT FOR AWHILE
        MOVE.B (A5)+,D1 ;SEE IF COMMA
        CMPI.B #',',D1
        BNE.S NUMCON00
        CLR.L D0        ;DEFAULT OFFSET
        BSR GETNUMS     ;GET ANOTHER NUMBER
        ADD.L D0,D7
NUMCON00 BSR FIXBUF     ;SET UP FOR PRINT
        TST.L D7        ;SEE IF NEGATIVE
        BPL.S NUMCON1
        MOVE.B #'$',(A6)+
;
;       PATCHED *08/14/80*
        BSR PATCH2      ;MOVE D7>D0 THEN BSR PNT8HX
;
        MOVE.B #'=',(A6)+
NUMCON1 MOVE.L D7,D0    ;RESTORE
        BPL.S NUMCON2
        MOVE.B #'-',(A6)+
        NEG.L D0
NUMCON2 MOVE.B #'$',(A6)+
        BSR PNTZHX
        MOVE.B #'=',(A6)+       ;NOW PRINT DECIMAL VALUE
        MOVE.L D7,D0
        BPL.S NUMCON3
        MOVE.B #'-',(A6)+
        NEG.L D0
NUMCON3 MOVE.B #'&',(A6)+
        BSR HEX2DEC     ;PUT VALUE IN BUFFER
        BRA MSG ;GO PRINT IT
        PAGE
;
;       FORM SYMBOL FROM INPUT BUFFER
;       RTS WITH SYMBOL IN D6,D7
;       OR D6,D7=NULL IF NOT A SYMBOL
;
GETSY   MOVE.L #'    ',D7 ;BLANK FILL
        MOVE.L D7,D6    ;D6,D7 HOLD SYMBOL
        CLR.W SIGN.W    ;0=POSITIVE     ELSE=NEGATIVE
        CLR.L D1        ;USED AS INDEX
GETSY0  MOVE.B 0(A5,D1),D0      ;GET A CHAR FROM INPUT BUFFER
        CMPI.B #',',D0  ;SEE IF COMMA
        BEQ.S GETSY4
        CMPI.B #' ',D0  ;SEE IF SPACE
        BEQ.S GETSY4
        CMPI.B #':',D0  ;SEE IF COLEN
        BEQ.S GETSY4
        CMPI.B #'.',D0  ;SEE IF POINT
        BEQ.S GETSY3
        CMPI.B #'-',D0  ;SEE IF SIGN
        BEQ.S GETSY5
        CMPI.B #'A',D0  ;SEE IF LESS THAN LETTER
        BLT.S GETSY2
        CMPI.B #'Z',D0  ;SEE IF GREATER THAN LETTER
        BLE.S GETSY3
GETSY2  TST.W D1        ;SEE IF 1ST CHAR
        BEQ NOTSYM      ;NOT 'A'-'Z' OR '.' PRINT SYMBOL FROM HEX
        CMPI.B #'$',D0  ;ALLOW '$' IF NOT 1ST CHAR
        BEQ.S GETSY3
        CMPI.B #'0',D0  ;ALLOW DIGIT IF NOT 1ST
        BLT NOTSYM
        CMPI.B #'9',D0
        BGT NOTSYM
GETSY3  MOVE.L D6,VECTOR.W      ;CHECK TOP BYTE
        MOVE.B VECTOR.W,D2      ;SEE IF SPACE
        CMPI.B #' ',D2
        BNE.S NOTSYM
        MOVE.L D7,VECTOR.W      ;GET TOP BYTE OF D7...
        LSL.L #8,D6     ;...INTO LOW BYTE OF D6
        MOVE.B VECTOR.W,D6
        LSL.L #8,D7
        MOVE.B D0,D7    ;SAVE NEW LETTER
GETSY1  ADDQ.W #1,D1    ;BUMP INDEX
        BRA.S GETSY0
GETSY4  BSR NORM1       ;LEFT JUSTIFY IT
        RTS             ;RETURN TO SENDER
GETSY5  TST D1  ;SEE IF FIRST   COME HERE WHEN '-'
        BNE.S NOTSYM
        MOVE.W #-1,SIGN.W
        BRA.S GETSY1
NOTSYM  CLR.L D6        ;IS NOT A SYMBOL
        CLR.L D7
        RTS             ;RETURN TO SENDER
        PAGE
;
;       CONVERT BINARY TO DECIMAL       REG D0 PUT IN (A6) BUFFER AS ASCII
;
HEX2DEC MOVE.L D0,D7    ;SAVE IT HERE
        BPL.S HX2DC
        NEG.L D7        ;CHANGE TO POSITIVE
        MOVE.B #'-',(A6)+       ;PUT IN NEG SIGN
HX2DC   CLR.W TEMP.W    ;FOR ZERO SURPRESS
        MOVEQ.L #10,D6  ;COUNTER
HX2DC0  MOVEQ.L #1,D2   ;VALUE TO SUB
        MOVE.L D6,D1    ;COUNTER
        SUBQ.L #1,D1    ;ADJUST - FORM POWER OF TEN
        BEQ.S HX2DC2    ;IF POWER IS ZERO
HX2DC1  MOVE.W D2,D3    ;D3=LOWER WORD
        MULU #10,D3
        SWAP D2 ;D2=UPPER WORD
        MULU #10,D2
        SWAP D3 ;ADD UPPER TO UPPER
        ADD.W D3,D2
        SWAP D2 ;PUT UPPER IN UPPER
        SWAP D3 ;PUT LOWER IN LOWER
        MOVE.W D3,D2    ;D2=UPPER & LOWER
        SUBQ.L #1,D1
        BNE.S HX2DC1
HX2DC2  CLR.L D0        ;HOLDS SUB AMT
HX2DC22 CMP.L D2,D7
        BLT.S HX2DC3    ;IF NO MORE SUB POSSIBLE
        ADDQ.L #1,D0    ;BUMP SUBS
        SUB.L D2,D7     ;COUNT DOWN BY POWERS OF TEN
        BRA.S HX2DC22   ;DO MORE
HX2DC3  TST.B D0        ;ANY VALUE?
        BNE.S HX2DC4
        TST.W TEMP.W    ;ZERO SURPRESS
        BEQ.S HX2DC5
HX2DC4  ADDI.B #$30,D0   ;BINARY TO ASCII
        MOVE.B D0,(A6)+ ;PUT IN BUFFER
        MOVE.B D0,TEMP.W        ;MARK AS NON ZERO SURPRESS
HX2DC5  SUBQ.L #1,D6    ;NEXT POWER
        BNE.S HX2DC0
        TST.W TEMP.W    ;SEE IF ANYTHING PRINTED
        BEQ.S HX2DC6
        RTS             ;JUST END ROUTINE
HX2DC6  MOVE.B #'0',(A6)+       ;PRINT AT LEST A ZERO
        RTS             ;END OF ROUTINE
        PAGE
;
;       SEND LINE TO PORT1 WITH CR/LF
;
OUT1CR  TST.L OUTTO.W   ;SEE IF ALTERNATE ADDRESS
        BEQ.S OUT1CRX
        MOVE.L OUTTO.W,-(A7)    ;PUSH ON STACK
        RTS     ;GO DO IT
OUT1CRX MOVE.L OUTPORT1.W,-(A7) ;GO TO I/O ADDRESS
        RTS             ;(THIS NORMALLY GOES TO OUT1CR0)
;
OUT1CR0 BSR OUTPUT      ;SEND LINE
CRLF    BSR FIXBUF
        MOVE.W #$D0A,(A6)+      ;PUT CR LF AT END OF BUFFER
;       
;       OUTPUT BUFFER TO PORT1
; 
OUTPUT  MOVEM.L D0-D3/A0-A1,-(A7)       ;GET SOME WORKING ROOM
        CLR.L D3        ;NO OFFSET INTO NULL CHARACTERS
OUTP1   BSR GETACIA1    ;GET.ACIA ADDRESS INTO A0
        BRA OUTP2
;
;       SEND LINE TO PORT2 WITH CR
;
OUTPUT2 TST.L OUTTO.W   ;SEE IF ALTERNATE ADDRESS
        BEQ.S OUTPUT2X
        MOVE.L OUTTO.W,-(A7)    ;PUSH ON STACK
        RTS             ;GO DO IT
OUTPUT2X MOVE.L OUTPORT2.W,-(A7)        ;GO TO IO ROUTINE
        RTS             ;(THIS NORMALLY GOES TO OUTPUT20)
;
OUTPUT20 BSR OUTPUT21
        BSR FIXBUF
        MOVE.B #$D,(A6)+        ;PUT CR AT END OF BUFFER
;
;       OUTPUT BUFFER TO PORT2 
;
OUTPUT21 MOVEM.L D0-D3/A0-A1,-(A7)
        MOVEQ.L #1,D3   ;SIGNAL FOR PORT2
        BSR GETACIA2    ;RETURNS ADDRESS IN A0  
;
;       SEND BUFFER TO PORT
;
OUTP2   CMPA.L A6,A5    ;SEE IF AT OR BEYOUND END OF LINE
        BMI.S OUTP3
        MOVEM.L (A7)+,D0-D3/A0-A1       ;RESTORE REGISTERS
        RTS             ;END OF ROUTINE
OUTP3   MOVE.B (A5)+,D0 ;GRAB BYTE TO OUTPUT
        BSR.S OUTCH1    ;GO PRINT IT
        BRA.S OUTP2     ;GO DO ANOTHER
;
;       SEND CHARACTER IN D0.B TO PORT1 
;       THROUGH .ACIA ADDRESSED BY (A0)
;       D3=0 FOR PORT1  D3=1 FOR PORT2
;       PUTS IN NULL PADDING AS NEEDED
;
OUTCH1  BSR OUTCH       ;GO PRINT "D0"
        TST.B D0        ;SEE IF NULL
        BEQ.S OUTCHRTS  ;JUST END IF NULL
        CLR.L D2        ;CLEAR UPPER BYTES OF NULL LOOP COUNTER
        MOVE.L #NULLPADS,A1     ;FORM ADDRESS OF PADS
        ADDA.L D3,A1    ;D3=0 FOR PORT1 1=PORT2
        MOVE.B (A1),D2  ;DEFAULT NULL PADS
        CMPI.B #$D,D0   ;SEE IF CR
        BNE.S OUTCH2
        MOVE.L #CRPADS,A1       ;FORM ADDRESS OF CR PADS
        ADDA.L D3,A1    ;D3=0 FOR PORT1 1=PORT2
        MOVE.B (A1),D2  ;NULLS AFTER CR
OUTCH2  TST.L D2        ;SEE IF ANY PADDS TO BE SEND
        BEQ.S OUTCHRTS  ;0=NONE
        CLR.L D0        ;0=NULL CHAR TO BE SEND
OUTCH3  BSR OUTCH       ;SEND A NULL
        SUBQ.L #1,D2    ;LOOP AROUND
        BNE.S OUTCH3
OUTCHRTS RTS            ;END OF OUTCH ROUTINE
;
;       SEND CHARACTER IN D0.B TO .ACIA IN (A0) (NO NULL PADS)
;
;                                                       6/8/82 START
;OUTCH  BSR CHKBRK              ;CHECK FOR BREAK
OUTCH   MOVE.B $23(A0),D1       ;GET STATUS
        BTST #4,D1              ;TRANSMIT REG EMPTY
        BEQ.S OUTCH             ;NOT YET
        MOVE.B D0,$21(A0)       ;SEND CHARACTER
;       BSR CTLW                ;IGNORE CONTROL-W FOR NOW
        RTS                     ;CHARACTER SENT
;
;       CHECK FOR BREAK (JUST RETURNS: 6/8/82)
;
CHKBRK  RTS
;
;CHKBRK  MOVE.B $23(A0),D1 ;READ STATUS
;       BTST #1,D1      ;SEE IF BREAK
;       BNE BREAK
;       RTS
;                                                       6/8/82 END
        PAGE
;
;       CHECK FOR CONTROL W
;
;CTLW   MOVE.B $23(A0),D1  ;READ STATUS
;       BTST #3,D1
;       BEQ.S CTLW9        ;JUST RETURN
;       MOVE.B $21(A0),D0  ;READ CHARACTER
;       CMPI.B #$17,D0     ;SEE IF CTL W
;       BNE.S CTLW9
;CTLWH  BSR.S CHKBRK       ;CHECK FOR BREAK
;       MOVE.B $23(A0),D1  ;READ STATUS
;       BTST #3,D1         ;SEE IF SENT
;       BEQ.S CTLWH
;CTLW9  RTS                ;RETURN
;
;
;       WHAT DO YOU DO WHEN THE BREAK IS PRESSED
;
;                                                       6/8/82 START
;BREAK   BSR GETACIA1      ;INITIALIZE BOTH PORTS
;       MOVE.B $21(A0),D0 ;CLEAR FRAMING ERROR
;       CLR.L D0
;       MOVE.W #$100,D0
;WAIT    SUBQ #1,D0
;       BNE.S WAIT
;       BSR FIXBUF
;       MOVE.L #$0D0D0A0A,(A6)+
;       MOVE.L #$2A425245,(A6)+ ; "*BRE
;       MOVE.L #$414B2A20,(A6)+ ;      AK*"
;       MOVE.L #$0D0D0A0A,(A6)+
;       BSR.S INITACIA    ;INITIALIZE BOTH PORTS
;       BSR GETACIA1      ;RETURNS ADDRESS IN A0
;       MOVE.B $23(A0),D0 ;CHECK IF BREAK
;       BTST #1,D0
;       BNE.S BREAK
;                                                       6/8/82 END
;       BRA MSG         ;PRINT MESSAGE AND REENTER MACSBUG
;
;       INITIALIZE BOTH ACIAs
;
;                                                       6/8/82 START
INITACIA MOVEM.L D0/A0,-(A7)    ;FREE UP SOME WORKING REGISTERS
        BSR GETACIA1            ;MOVE ADDRESS INTO A0
        MOVE.B D0,$23(A0)       ;MASTER RESET
        MOVE.B COMM1.W,$25(A0)  ;COMMAND
        MOVE.B CON1.W,$27(A0)   ;CONTROL
        BSR GETACIA2            ;MOVE ADDRESS INTO A0
        MOVE.B D0,$23(A0)       ;MASTER RESET
        MOVE.B COMM2.W,$25(A0)  ;COMMAND
        MOVE.B CON2.W,$27(A0)   ;CONTROL
        MOVE.W #$200,D0         ;WAIT DELAY
INITAC3 DBRA D0,INITAC3         ;LOOP AROUND
        MOVEM.L (A7)+,A0/D0     ;RESTORE REGISTERS
        RTS
;                                                       6/8/82 END
;
;       INPUT A LINE FROM PORT1
;
PORTIN1 TST.L INFROM.W  ;SEE IF ALTERNAT ADDRESS
        BEQ.S PORTIN1X
        MOVE.L INFROM.W,-(A7)   ;PUSH ON STACK
        RTS             ;GO DO IT
PORTIN1X MOVE.L INPORT1.W,-(A7) ;GO TO IO ROUTINE
        RTS             ;(THIS NORMALLY GOES TO PORTIN10)
;
PORTIN10 MOVEM.L        D0-D4/A0-A2,-(A7)       ;FREE UP SOME WORK REGISTERS
        CLR.L D3        ;FLAG AS PORT1
        BSR GETACIA1    ;MOVE ADDRESS INTO A0
READBUF BSR INCHNE      ;GO GET SOME DATA       (NO ECHO)
        TST.B D0        ;CHECK FOR NULLS
        BEQ.S READBUF
RB1     MOVE.W D0,D4    ;SAVE FOR A WHILE
        BSR OUTCH1      ;ECHO WHAT IS IN D0
        MOVE.W D4,D0    ;RESTORE IT
        CMPI.B #$0A,D0  ;SEE IF LINE FEED
        BEQ.S READBUF   ;DONT PUT IT IN BUFFER
        CMPI.B #$18,D0  ;SEE IF CTL X=CANCEL LINE
        BNE.S RB2
        MOVE.B #'\',D0  ;SENT A SLASH
        BSR OUTCH1
        MOVE.B #$0D,D0  ;SEND A CARRIAGE RETURN
        BSR OUTCH1
        MOVE.B #$0A,D0  ;SEND LINE FEED
        BSR OUTCH1
        MOVE.L A5,A6    ;START BUFFER OVER AGAIN
        BRA.S READBUF
;                                               6/8/82 START
RB2     CMPI.B #$08,D0   ;SEE IF CTL H=BACKSPACE
        BNE.S RB4
RB3     MOVE.B #$20,D0  ;SEND A SPACE
        BSR OUTCH1
        CMPA.L A5,A6    ;START OF BUFFER?
        BEQ.S READBUF   ;YES, SO RETURN
        MOVE.B #$08,D0  ;SEND ANOTHER BS
        BSR OUTCH1
        SUBQ #1,A6
        BRA READBUF     ;DON'T PUT IN BUFFER
;                                               6/8/82 END
RB4     CMPI.B #$04,D0  ;SEE IF CTL D (REPRINT)
        BNE.S RB5
        MOVEQ.L #$0D,D0 ;PRINT CR
        BSR OUTCH1
        MOVEQ.L #$0A,D0 ;PRINT LF
        BSR OUTCH1
        MOVE.L A5,-(A7) ;SAVE ON STACK FOR A MOMENT
RB45    BSR OUTPUT      ;GO PRINT BUFFER
        MOVE.L (A7)+,A5 ;GET BACK FROM STACK
        BRA READBUF
RB5     CMPI.B #$0D,D0  ;SEE IF AT END OF LINE
        BNE.S RB6
        MOVE.B #$0A,D0  ;GIVE LF
        BSR OUTCH1
        MOVEM.L (A7)+,D0-D4/A0-A2       ;PULL FROM STACK
        RTS             ;RETURN TO CALLER
RB6     MOVE.B D0,(A6)+ ;SAVE DATA INTO BUFFER
        BRA READBUF
;
;       INPUT CHARACTER FROM PORT1
;       ACIA ADDRESS IN (A0)
;
INCH    BSR INCHNE      ;INPUT CHARACTER
        BSR OUTCH1      ;ECHO TO CONSOLE
        RTS
;       INCH (NO ECHO)
;                                               6/8/82 START
INCHNE  MOVE.B $23(A0),D1  ;GET STATUS
        BTST #3,D1        ;INBOUND CHARACTER
        BEQ.S INCHNE
;       BSR CHKBRK        ;WAS IT A BREAK
        MOVE.B $21(A0),D0 ;GET CHAR
        ANDI.B #$7F,D0     ;GET RID OF PARITY BIT
        CMPI.B #$60,D0     ;CHANGE LOWER CASE TO UPPER CASE
        BLE.S INCHNE0
        CMPI.B #$7A,D0
        BGT INCHNE0
        BCLR #5,D0
INCHNE0 RTS
;                                               6/8/82 END
;
;       INPUT A LINE FROM PORT2 (ACIA2)
;
PORTIN2 TST.L INFROM.W  ;SEE IF ALTERNATE ADDRESS
        BEQ.S PORTIN2X
        MOVE.L INFROM.W,-(A7)
        RTS             ;GO DO IT
PORTIN2X MOVE.L INPORT2.W,-(A7) ;GO TO IO ROUTINE
        RTS             ;(THIS NORMALLY GOES TO PORTIN20)
;
PORTIN20 MOVEM.L D1-D3/A0-A3,-(A7)      ;SAVE WORKING REGISTERS
        BSR GETACIA2    ;MOVE ADDRESS INTO A0   
        MOVE.L A0,A3    ;USE ADDRESS IN A3
        BSR GETACIA1    ;MOVE ADDRESS INTO A0
;                                               6/8/82 START
POR2IN2 CMPA.L A0,A3    ;SEE IF THE SAME PORT ADDRESS
        BEQ.S PORTIN21    ;IGNORE BREAKS ETC
        BSR CHKBRK      ;CHECK FOR BREAKS ETC
        MOVE.B $23(A0),D1 ;SEE IF CHARACTER SENT
        BTST #3,D1
        BEQ.S PORTIN21  ;NONE SENT
        MOVE.B $21(A0),D1 ;READ WHAT WAS SENT
        ANDI.B #$7F,D1   ;GET RID OF PARITY BIT
        CMPI.B #1,D1    ;SEE IF CTL A
        BNE.S PORTIN21  ;
        BSR FIXBUF      ;
        MOVE.L #$2A41424F,(A6)+ ;"*ABO
        MOVE.L #$52542A20,(A6)+ ;     RT *"
        BRA MSG
PORTIN21 MOVE.B $23(A3),D1 ;READ STATUS OF PORT2
        BTST #3,D1      ;SEE IF CHARACTER SENT
        BEQ.S POR2IN2   ;LOOP AROUND
        MOVE.B $21(A3),D1 ;READ CHARACTER SENT
        ANDI.B #$7F,D1   ;DROP PARITY BIT
        TST.W WORK2.W   ;SEE IF ECHO ON
        BEQ.S PORTIN25
        MOVE.B D1,$21(A0) ;SEND TO DATA SIDE
;                                               6/8/82 END
PORTIN25 CMPI.B #$D,D1  ;SEE IF END OF LINE
        BNE.S PORTIN22
        MOVEM.L (A7)+,D1-D3/A0-A3       ;RESTORE THE REGISTERS
        RTS
PORTIN22 BRA PATCH1     ;******GO TO PATCH AREA*****
        NOP
        MOVE.B D1,(A6)+ ;SAVE CHAR IN BUFFER
        BRA.S POR2IN2   ;GO DO ANOTHER
;
;       TRANSPARENT MODE
;
P2CMD   MOVEQ.L #1,D7   ;DEFAULT IS CNTL 'A'
        MOVE.L #ROM+P2CMD0-ZERO,A0
        BSR FINDNP      ;FIND NEXT PARAMETER
        MOVE.B (A5),D7  ;QUIT CHARACTER
;                                                   *KB 8/18/82*
P2CMD0                          ;                   *KB 8/18/82*
        BSR     INITACIA        ;INIT ACIA REGISTERS*KB 8/18/82*
        BSR GETACIA1    ;ADDRESS FOR PORT1 INTO A0  *KB 8/18/82*
        BSR FIXBUF      ;SET UP FOR MESSAGE
        MOVE.W #$0D0A,(A6)+
        MOVE.L #'*TRA',(A6)+
        MOVE.L #'NSPA',(A6)+
        MOVE.L #'RENT',(A6)+
        MOVE.W #'* ',(A6)+
        MOVE.L #'EXIT',(A6)+
        MOVE.W #'=$',(A6)+
        MOVE.L D7,D0    ;EXIT CHARACTER
        BSR PNT2HX      ;PRINT 2 HEX CHARACTERS
        MOVE.W #$0D0A,(A6)+
        BSR OUT1CR      ;GO PRINT BUFFER WITH CRLF
;
;                                                       6/8/82 START
;       MOVE.B COMM1.W,D0       *KB 8/18/82*
        MOVE.B #$FD,$21(A0) ;SEND "TURN OFF SPECIAL CHAR"
P2CMD1  MOVE.B $23(A0),D0 ;READ STATUS
        BTST #3,D0
;       BNE.S P2CMD3                    *KB 8/18/82*
;       MOVE.B 3(A0),D0 ;KEYBOARD INPUT?*KB 8/18/82*
;       BTST #3,D0                      *KB 8/18/82*
        BEQ.S   INCHNE2         ;NO LOCAL INPUT SE IF SOMETHING FROM OTHER SIDE
;                               *KB 8/18/82*
P2CMD3  MOVE.B $21(A0),D0 ;LISTEN IN
        ANDI.B #$7F,D0   ;NO PARITY BIT
        CMP.B D0,D7     ;SEE IF QUIT CHAR
        BEQ.S UNTRANS   ;EXIT TRANSPARENT MODE
        BSR.S OUTCH4    ;TRANSMIT NORMAL STUFF
INCHNE2 MOVE.B $43(A0),D1 ;GET STATUS
        BTST #3,D1      ;INBOUND CHAR?
        BEQ.S P2CMD1
        MOVE.B $41(A0),D0 ;GET CHAR
        ANDI.B #$7F,D0   ;NO PARITY BIT
        BSR OUTCH
        BRA.S P2CMD1    ;LOOP TO INBOUND CHAR
UNTRANS BSR INITACIA
        BSR.S FIXBUF
        MOVE.L #$0D0A,(A6)+
        MOVE.L #'*MAC',(A6)+ ;"*MAC             *KB 8/18/82*
        MOVE.L #'SBUG',(A6)+ ;     SBUG         *KB 8/18/82*
        MOVE.L #'*   ',(A6)+ ;         *"       *KB 8/18/82*
        BSR.S GETACIA2
        MOVE.B #$18,$21(A0)     ;SEND CTRL-X TO HOST
        BRA MSG

OUTCH4  MOVE.B $43(A0),D1 ;GET STATUS
        BTST #4,D1      ;TRANS REG READY?
        BEQ.S OUTCH4
        MOVE.B D0,$41(A0) ;SEND CHAR
        RTS
;                                                       6/8/82 END
;       
;       GET ADDRESS OF ACIA1 PORT1 CONSOLE INTO A0              *KB 8/18/82*
;                                                               *KB 8/18/82*
;GETACIA1 MOVE.L ALTACIA1.W,A0   ;GET ALTERNATE ACIA ADDRESS    *KB 8/18/82*
;       BNE.S RET                                               *KB 8/18/82*
GETACIA1                        ;No Alternates                  *KB 8/18/82*
        MOVE.L #$030F00,A0      ;USE DEFAULT                    *KB 8/18/82*
RET     RTS                     ;                               *KB 8/18/82*
;                                                               *KB 8/18/82*
;       GET ADDRESS OF ACIA2 PORT2 HOST INTO A0                 *KB 8/18/82*
;                                                               *KB 8/18/82*
;GETACIA2 MOVE.L ALTACIA2.W,A0   ;ALTERNATE                     *KB 8/18/82*
;       BNE.S RET                                               *KB 8/18/82*
GETACIA2                        ;No Alternates                  *KB 8/18/82*
        MOVE.L #$030F20,A0      ;USE DEFAULT                    *KB 8/18/82*
        RTS                     ;                               *KB 8/18/82*
;                                                       6/8/82 END
;       FIX THE BUFFER A5 & A6 SET TO START OF BUFFER QUE
;
FIXBUF  MOVE.L #BUFFER,A5
        MOVE.L A5,A6
        RTS
        PAGE
;
;       SCAN COMMAND LINE FOR PORT NUMBER
;       PU2     RE1     ;SY3    PR2 etc.
;
SCANPORT MOVE.L A5,A4   ;LOAD UP A TEMP SCANNER
        CLR.L INFROM.W  ;DEFAULT IS WHATEVER IS CALLED
        CLR.L OUTTO.W
SCANP1  CMPA.L A6,A4    ;SEE IF AT END OF BUFFER
        BMI.S SCANP3
SCANP2  RTS
SCANP3  MOVE.B (A4)+,D0 ;GET A CHARACTER
        CMPI.B #' ',D0  ;SEE IF IT IS A SPACE
        BEQ.S SCANP2
        CMPI.B #'1',D0  ;SEE IF PORT 1 OVERRIDE
        BNE.S SCANP4
        MOVE.L INPORT1.W,INFROM.W
        MOVE.L OUTPORT1.W,OUTTO.W
        RTS
SCANP4  CMPI.B #'2',D0  ;SEE IF PORT 2 OVERRIDE
        BNE.S SCANP5
        MOVE.L INPORT2.W,INFROM.W
        MOVE.L OUTPORT2.W,OUTTO.W
        RTS
SCANP5  CMPI.B #'3',D0  ;SEE IF PORT3 OVERRIDE
        BNE.S SCANP1
        MOVE.L INPORT3.W,INFROM.W
        MOVE.L OUTPORT3.W,OUTTO.W
        RTS
                PAGE
;
;       ***TRAP 15*** USER CALLS THE IO ROUTINES
;
TRAP15                                         ;                        *KB 8/18/82*
        MOVE.W  #$2700, SR      ;stop all interrupts                    *KB 8/18/82*
        MOVE.L D0,REGS.W        ;save D0                                *KB 8/18/82*
        MOVE.L A0,REGS+32.W     ;save A0                                *KB 8/18/82*
;
        MOVE.L 2(A7),A0 ;GET USERS PC                                   *KB 8/18/82*
        MOVE.W (A0)+,D0 ;GET PARAMETER
        MOVE.L A0,2(A7) ;NEW PROGRAM COUNTER
;
        TST.W D0        ;SEE IF ZERO
        BNE.S UIO1
        MOVE.L REGS.W,D0        ;RESTORE D0                             *KB 8/18/82*
        MOVE.L REGS+32.W,A0     ;RESTORE A0                             *KB 8/18/82*
        MOVE.W  #T15A1-ZERO,TEMP.W              ;RETURN ADDRESS         *KB 8/18/82*
        BRA     SAVE    ;returns D0 = REGPC     ;SAVE USERS REGISTERS   *KB 8/18/82*
;                                                                       *KB 8/18/82*
T15A1                                           ;                       *KB 8/18/82*
        BSR SWAPOUT     ;TAKE BREAKPOINTS OUT
        BSR TDISPLY
        BRA MACSBUG     ;PUT USER IN MACSBUG
;
UIO1    CMPI.W #1,D0    ;SEE WHAT FLAVOR ETC.
        BNE.S UIO2
        BSR PORTIN1X    ;TAKE IN LINE FROM CONSOLE
        BRA.S UIO9
UIO2    CMPI.W #2,D0
        BNE.S UIO3
        BSR OUT1CRX     ;SEND LINE TO CONSOLE WITH CRLF
        BRA.S UIO9
UIO3    CMPI.W #3,D0
        BNE.S UIO4
        BSR PORTIN2X    ;TAKE IN LINE FROM PORT 2
        BRA.S UIO9
UIO4    CMPI.W #4,D0
        BNE.S UIO7
        BSR OUTPUT2X    ;SEND LINE TO CONSOLE WITH CRLF
        BRA.S UIO9
UIO7    CMPI.W #7,D0    ;ADDED 12/13/79.....
        BNE ERROR
        BSR OUTPUT      ;SEND LINE TO CONSOLE WITH NO CRLF
;                PATCHED 12/13/79
UIO9    MOVE.L REGS.W,D0        ;RESTORE D0
        MOVE.L REGS+32.W,A0     ;RESTORE A0
        RTE             ;RETURN TO USER
        PAGE
;***********************************************************************
;                                                               *
;       PATCH AREA *
;       1) IGNORE DEL CHARACTER HEX($7F) FROM PORT2 INPUT       *10/11/79*
;                                                               *
;       2) DISPLAY CORRECT DATA FROM THE DATA CONVERT ROUTINE.  *08/14/80*
;                                                               *
;       3) MOVE STOP BITS TO ACIA AT END OF "FO" COMMAND.       *08/14/80*
;                                                               *
;***********************************************************************
;
PATCH1  CMPI.B #$20,D1  ;SEE IF CTL CHAR
        BLT POR2IN2
        CMPI.B #$7F,D1  ;SEE IF GREATER OR EQUAL TO DEL
        BGE POR2IN2
        MOVE.B D1,(A6)+ ;SAVE CHARACTER
        BRA POR2IN2     ;READ ANOTHER
;
PATCH2  MOVE.L  D7,D0   ;MOVE RESULT TO D0
        BRA     PNT8HX  ;GO SET UP 8 HEX CHARS... (STACK IS SET FOR RTS)
;
PATCH3  BSR     INITACIA        ;GO INIT ACIA
        BRA     MACSBUG ;AND RE-ENTER MACSBUG.
        PAGE
;
; FILL ANY REMAINING MEMORY WITH HIGH VALUES
;

        END START
